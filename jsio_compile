#!/usr/local/bin/node
jsio=function T(z){function F(a,c,d){a=j.splitPath(a+".js");if(c){a.baseMod=c;a.basePath=d}return a}function U(){var a=require("fs"),c=require("sys");this.name="node";this.global=GLOBAL;this.getCwd=process.cwd;this.log=function(){var d;try{c.error(d=Array.prototype.map.call(arguments,function(b){if(b instanceof Error&&b.message)return"Error:"+b.message+"\nStack:"+b.stack+"\nArguments:"+b.arguments;return typeof b=="string"?b:JSON.stringify(b)}).join(" "))}catch(f){c.error(d=Array.prototype.join.call(arguments,
" ")+"\n")}return d};this.getPath=function(){var d=__filename.split("/");d.pop();return j.makeRelativePath(d.join("/")||".",this.getCwd())};this.eval=process.compile;this.fetch=function(d){try{return a.readFileSync(d,"utf8")}catch(f){}return false};this.require=require}function V(){var a=window.XMLHttpRequest||function(){return new ActiveXObject("Msxml2.XMLHTTP")},c=null,d=null;this.name="browser";this.global=window;this.global.jsio=g;this.log=function(){var b=G.call(arguments,0);if(typeof console!=
"undefined"&&console.log)console.log.apply?console.log.apply(console,arguments):console.log(b);return b.join(" ")};this.getCwd=function(){if(!c){var b=window.location,e=b.pathname;c=b.protocol+"//"+b.host+e.substring(0,e.lastIndexOf("/")+1)}return c};this.getPath=function(){if(!d){try{for(var b=RegExp("(.*?)"+g.__filename+"(\\?.*)?$"),e=document.getElementsByTagName("script"),h=0,k;k=e[h];++h){var r=k.src.match(b);if(r){d=r[1];if(/^[A-Za-z]*:\/\//.test(d))d=j.makeRelativePath(d,this.getCwd());break}}}catch(l){}d||
(d=".")}return d};this.debugPath=function(b){return b};var f=typeof eval("(function(){})")=="undefined"?function(b){return(new Function("return "+b))()}:function(b,e){b=b+"\n//@ sourceURL="+e;return window.eval(b)};this.eval=function(b,e,h){try{return f(b,this.debugPath(e))}catch(k){if(k instanceof SyntaxError){i.log("a syntax error is preventing execution of "+e);W&&this.checkSyntax&&this.checkSyntax(h,e)}throw k;}};this.checkSyntax=function(b,e){try{var h=g("import util.syntax",{suppressErrors:true,
dontExport:true}),k=h(b);h.display(k,e)}catch(r){}};this.fetch=function(b){var e=new a;try{e.open("GET",b,false);e.send(null)}catch(h){i.log("e:",h);return false}if(e.status==404||e.status==-1100||0)return false;return e.responseText}}function L(a,c,d,f){for(var b=0,e=d.length;b<e;++b)(p=typeof d[b]=="function"?d[b]:g.__modules["preprocessors."+d[b]]||g("import preprocessors."+d[b],{dontExport:true}))&&p(a,c,f)}function X(a,c,d,f){a||(a={});if(!a.exports)a.exports={};a.jsio=j.bind(this,H,a,d.directory,
d.filename);a.require=function(b,e){e||(e={});e.dontExport=true;e.suppressErrors=true;try{var h=a.jsio(b,e);if(h===false)throw"module failed to load";else return h}catch(k){try{return require(b)}catch(r){i.log("Error loading request "+b+":");i.log(k);i.log("Also could not load using standard CommonJS");i.log(r);throw k;}}};a.module={id:c,exports:a.exports};if(!f&&c!="base"){a.jsio("from base import *");a.logging.__create(c,a)}a.jsio.__jsio=g;a.jsio.__env=g.__env;a.jsio.__dir=d.directory;a.jsio.__filename=
d.filename;a.jsio.__path=c;a.jsio.path=g.path;return a}function H(a,c,d,f,b){b=b||{};c=c||"./";d=d||"<initial file>";a=b.exportInto||a||i.global;for(var e=b,h=g.__cmds,k=[],r=false,l=0,s;s=h[l];++l)if(r=s(a,f,e,k))break;if(r!==true)throw new (typeof SyntaxError!="undefined"?SyntaxError:Error)(String(r||"invalid jsio command: jsio('"+f+"')"));e=k.length;h=e>1?{}:null;for(r=0;r<e;++r){l=k[r];var o=l.from;s=g.__modules;try{var v;a:{for(var t=c,q=d,m=o,x=b,y=j.resolveModulePath(m,t),w=0,M=void 0;y[w];++w){var N=
y[w].path;if(!x.reload&&N in g.__modules){v=y[w];break a}N in O&&y.splice(w--,1)}if(!y.length){if(x.suppressErrors){v=false;break a}var P=Error("Module failed to load (again)");P.jsioLogged=true;throw P;}var n;b:{for(var B=y,I=void 0,Q=0,A=void 0;A=B[Q];++Q){var J=A.path,R=D[J];if(R){A.src=R.src;n=A;break b}I=i.fetch(J);if(I!==false){A.src=I;n=A;break b}else O[J]=true}n=false}B=void 0;if(!n){if(x.suppressErrors){v=false;break a}b=[];for(w=0;M=y[w];++w)b.push(M.path);throw Error(t+q+": \n\tcurrent directory: "+
i.getCwd()+"\n\tlooked in:\n\t\t"+b.join("\n\t\t")+"\n\tImport Stack:\n\t\t"+E.join("\n\t\t")+"\n\tError: requested import ("+m+") not found.");}n.friendlyPath=m;if(n.baseMod&&!(n.baseMod in g.path.cache))g.path.cache[n.baseMod]=n.basePath;for(;n.src.charAt(0)=='"'&&(B=n.src.match(Y));){n.src=n.src.substring(B[0].length-1);L(t,n,B[1].split(","),x)}x.preprocessors&&L(t,n,x.preprocessors,x);v=n}if(v===false)return false}catch(K){if(!K.jsioLogged){i.log("\nError loading module:\n\trequested:",o,"\n\tfrom:",
c+d,"\n\tfull request:",f,"\n");K.jsioLogged=true}throw K;}E.push(E.length+" : "+v.friendlyPath+" ("+v.path+")");t=v.path;if(!(t in s)){o=X(b.context,o,v,l.dontAddBase);s[t]=o.exports;if(l.dontUseExports){q=[";(function(){"];var u=1;for(var C in l["import"]){o.exports[C]=undefined;q[u++]="if(typeof "+C+'!="undefined"&&exports.'+C+"==undefined)exports."+C+"="+C+";"}q[u]="})();";v.src+=q.join("")}q=o;m=v;w="(function(_){with(_){delete _;return function $$"+m.friendlyPath.replace(/[\/.]/g,"_")+"(){"+
m.src+"\n}}})";m=i.eval(w,m.path,m.src);m=m(q);m.call(q.exports);s[t]=o.exports}E.pop();o=s[t];if(e==1)h=o;if(!b.dontExport)if(l.as){l=l.as.match(/^\.*(.*?)\.*$/)[1];s=l.split(".");t=s.length-1;q=a;for(u=0;u<t;++u)if(m=s[u]){q[m]||(q[m]={});q=q[m]}q[s[t]]=o;if(e>1)h[l]=o}else if(l["import"])if(l["import"]["*"])for(u in s[t])a[u]=o[u];else try{for(u in l["import"])a[l["import"][u]]=o[u]}catch(Z){i.log("module: ",s);throw Z;}}return h}var W=true,G=Array.prototype.slice,i,S=/\/$/,j={bind:function(a,
c){var d=G.call(arguments,2);return function(){c=typeof c=="string"?a[c]:c;return c.apply(a,d.concat(G.call(arguments,0)))}},addEndSlash:function(a){return S.test(a)?a:a+"/"},removeEndSlash:function(a){return a.replace(S,"")},makeRelativePath:function(a,c){var d=c.length;if(a.substring(0,d)==c)return a.slice((a.charAt(d)=="/")+d);d=j.removeEndSlash(a).split("/");for(var f=j.removeEndSlash(c).split("/"),b=0;d[b]==f[b];)++b;if(b){a=d.slice(b).join("/");for(d=f.length-b;d>0;--d)a="../"+a}return a},buildPath:function(){return j.resolveRelativePath(Array.prototype.join.call(arguments,
"/"))},resolveRelativePath:function(a){var c=a.match(/^(\w+:\/\/)(.*)$/);if(c)a=c[2];for(a=a.replace(/\/+/g,"/").replace(/\/\.\//g,"/");a!=(a=a.replace(/(^|\/)(?!\.?\.\/)([^\/]+)\/\.\.\//g,"$1")););return c?c[1]+a:a},resolveRelativeModule:function(a,c){for(var d=[],f=a.split("."),b=f.length,e=b>1&&!f[0],h=e?0:-1;++h<b;)d.push(f[h]?f[h]:"..");return j.buildPath(e?c:"",d.join("/"))},resolveModulePath:function(a,c){if(a.charAt(0)==".")return[F(j.resolveRelativeModule(a,c))];var d=a.split("."),f=d[0];
d=d.join("/");if(g.path.cache.hasOwnProperty(f))return[F(j.buildPath(g.path.cache[f],d))];for(var b=[],e=g.path.get(),h=e.length,k=0;k<h;++k)b.push(F(j.buildPath(e[k],d),f,e[k]));return b},splitPath:function(a){var c=a.lastIndexOf("/")+1;return{path:a,directory:a.substring(0,c),filename:a.substring(c)}}},g=j.bind(this,H,null,null,null);g.__util=j;g.__init__=T;var D=g.__srcCache={};if(z&&z.__srcCache)D=g.__srcCache=z.__srcCache;(function(){this.__filename="jsio.js";this.__preprocessors={};this.__cmds=
[];this.__jsio=this;this.__importer=H;this.__modules={preprocessors:{}};this.path={set:function(a){this.value=typeof a=="string"?[a]:a},get:function(){return this.value.slice(0)},add:function(a){for(var c=this.value,d=c.length,f=0;f<d;++f)if(c[f]==a)return;c.push(a)},remove:function(a){for(var c=this.value,d=c.length,f=0;f<d;++f)c[f]==a&&c.splice(f,1)},value:[],cache:{}};this.addPath=j.bind(this.path,"add");this.setCachedSrc=function(a,c){D[a]={path:a,src:c}};this.getCachedSrc=function(a){return D[a]};
this.addPreprocessor=function(a,c){this.__preprocessors[a]=c};this.addCmd=function(a){this.__cmds.push(a)};this.setEnv=function(a){if(!a&&z)i=z.__env;else if(typeof a=="string")switch(a){case "node":i=new U(j);break;case "browser":default:i=new V(j);break}else i=new a(j);this.__env=i;this.__dir=i.getCwd();this.path.set(i.getPath())}}).call(g);if(z)g.setEnv();else if(typeof process!=="undefined"&&process.version)g.setEnv("node");else if(typeof XMLHttpRequest!="undefined"||typeof ActiveXObject!="undefined")g.setEnv("browser");
var Y=/^"use (.*?)"\s*;\s*\n/,O={},E=[];g.addCmd(function(a,c,d,f){if(a=c.match(/^\s*(from|external)\s+([\w.$]+)\s+(import|grab)\s+(.*)$/)){f.push({from:a[2],dontAddBase:a[1]=="external",dontUseExports:a[3]=="grab"||a[1]=="external","import":{}});a[4].replace(/\s*([\w.$*]+)(?:\s+as\s+([\w.$]+))?/g,function(b,e,h){f[0]["import"][e]=h||e});return true}});g.addCmd(function(a,c,d,f){if(a=c.match(/^\s*import\s+(.*)$/)){a[1].replace(/\s*([\w.$]+)(?:\s+as\s+([\w.$]+))?,?/g,function(b,e,h){f.push(h?{from:e,
as:h}:{from:e,as:e})});return true}});g.addCmd(function(a,c,d,f){if(a=c.match(/^\s*[\w.0-9$\/]+\s*$/)){a=j.resolveRelativePath(a[0]);c=a.charAt(0)==".";a=a.replace(/\.\.\//g,".").replace(/\.\//g,"").replace(/\//g,".");f[0]={from:(c?".":"")+a};return true}});g.install=function(){g("from base import *");GLOBAL.logger=logging.get("jsiocore")};g.clone=function(){var a=g.__init__(g);if(i.name=="browser")window.jsio=g;return a};return g}();jsio.path.set(["../../packages"]);
jsio.path.cache={base:"../../packages",util:"../../packages",preprocessors:"../../packages",std:"../../packages",lib:"../../packages",math:"../../packages",math2D:"../../packages",net:"../../packages",index:"../../packages",logging:"../../packages"};jsio.setCachedSrc("../../packages/preprocessors/compiler.js","jsio('import std.js as JS');\n\n// compiler should be able to compile itself, so use a different name for calls to jsio that we don't want to try to compile\nvar JSIO = jsio.__jsio; \n\nvar sourceCache = /jsio.__srcCache\\s*=\\s*\\{\\s*\\}/,\n\tjsioAddPath = /jsio\\.path\\.add\\s*\\(\\s*(['\"][^'\"]+?['\"])\\s*\\)/g,\n\tjsioNormal = /jsio\\s*\\(\\s*(['\"].+?['\"])\\s*(,\\s*\\{[^}]+\\})?\\)/g,\n\tjsioDynamic = /jsio\\s*\\(\\s*DYNAMIC_IMPORT_(.*?)\\s*(,\\s*\\{[^}]+\\})?\\)/g,\n\tgSrcTable = {};\n\nexports = function(path, moduleDef, opts) {\n\topts = opts || {};\n\t\n\tif (gSrcTable[moduleDef.path]) {\n\t\tmoduleDef.src = '';\n\t\treturn;\n\t}\n\t\n\tlogger.info('compiling', moduleDef.path);\n\t\n\t// prevent double import\n\tgSrcTable[moduleDef.path] = true;\n\t\n\tvar self = moduleDef.path;\n\t\n\tif (opts.path) {\n\t\tif (JS.isArray(opts.path)) {\n\t\t\tfor (var i = 0, len = opts.path.length; i < len; ++i) {\n\t\t\t\tjsio.path.add(opts.path);\n\t\t\t}\n\t\t} else if (typeof opts.path == 'string') {\n\t\t\tjsio.path.add(opts.path);\n\t\t}\n\t}\n\t\n\tif (opts.autoDetectPaths) {\n\t\tjsioAddPath.lastIndex = 0;\n\t\tlogger.debug('detecting paths for', self);\n\t\twhile (true) {\n\t\t\tvar match = jsioAddPath.exec(moduleDef.src);\n\t\t\tif (!match) { break; }\n\t\t\ttry {\n\t\t\t\tjsio.path.add(eval(match[1]));\n\t\t\t\tlogger.info('added path ' + match[1]);\n\t\t\t} catch(e) {\n\t\t\t\tlogger.info('failed to add path ' + match[1]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tjsioNormal.lastIndex = 0;\n\twhile (true) {\n\t\tvar match = jsioNormal.exec(moduleDef.src);\n\t\tif (!match) { break; }\n\t\t\n\t\tlogger.debug('detected', match[0])\n\t\t\n\t\tvar cmd = match[1],\n\t\t\tinlineOpts = match[2] ? match[2].substring(1) : '';\n\t\t\n\t\ttry {\n\t\t\tcmd = eval(cmd);\n\t\t} catch(e) {\n\t\t\tlogger.warn('could not compile import from', self + ':', cmd);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tinlineOpts = eval(inlineOpts);\n\t\t} catch(e) {\n\t\t\tlogger.warn('could not parse opts for jsio in', self + ':', inlineOpts);\n\t\t\tinlineOpts = {};\n\t\t}\n\t\t\n\t\trun(moduleDef, cmd, opts, inlineOpts);\n\t}\n\t\n\tjsioDynamic.lastIndex = 0;\n\twhile(true) {\n\t\tvar match = jsioDynamic.exec(moduleDef.src);\n\t\tif (!match) { break; }\n\t\t\n\t\tvar cmd = match[1],\n\t\t\tinlineOpts = match[2] || '';\n\t\t\n\t\tif (opts.dynamicImports && cmd in opts.dynamicImports) {\n\t\t\tvar dynamicImports = opts.dynamicImports[cmd];\n\t\t\tif (!dynamicImports) {\n\t\t\t\tlogger.debug('Dynamic import ' + cmd + ': <nothing>');\n\t\t\t\tcontinue;\n\t\t\t} else if (JS.isArray(dynamicImports)) {\n\t\t\t\tfor (var j = 0, line; line = dynamicImports[j]; ++j) {\n\t\t\t\t\tlogger.debug('Dynamic import ' + cmd + ': ' + line);\n\t\t\t\t\trun(moduleDef, line, opts, inlineOpts);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlogger.debug('Dynamic import ' + cmd + ': ' + dynamicImports);\n\t\t\t\trun(moduleDef, dynamicImports, opts, inlineOpts);\n\t\t\t}\n\t\t} else {\n\t\t\tlogger.error('Missing: import definition\\nConstant', cmd, 'for DYNAMIC_IMPORT_' + cmd, ' was not provided to the compiler');\n\t\t}\n\t}\n\t\n\tgSrcTable[moduleDef.path] = JS.shallowCopy(moduleDef);\n\tmoduleDef.src = '';\n}\n\nexports.setDebugLevel = function(debugLevel) { logger.setLevel(debugLevel); }\n\nexports.reset = function() {\n\tgSrcTable = {};\n}\n\n/**\n * set the compressor function, which has the signature:\n *    function (string source, function callback)\n */\nvar gActiveCompressor;\nexports.setCompressor = function(compressor) { gActiveCompressor = compressor; }\n\n/**\n * opts.compressSources: compress each source file ** requires an active compressor (see exports.setCompressor)\n * opts.compressResult: compress the resulting file ** requires an active compressor (see exports.setCompressor)\n * opts.includeJsio: include a copy of jsio.js in the output\n * opts.preserveJsioSource: don't modify the included copy of jsio.js (useful if the code will be used in another run of the jsio compiler)\n */\nexports.generateSrc = function(opts, callback) {\n\t\n\tvar opts = JS.merge(opts, {\n\t\t\tcompressSources: false,\n\t\t\tincludeJsio: true,\n\t\t\tpreserveJsioSource: false\n\t\t});\n\n\tvar cb = bind(this, buildJsio, opts, callback);\n\tif (opts.compressSources) {\n\t\tcompressTable(gSrcTable, opts, cb);\n\t} else {\n\t\tcb();\n\t}\n}\n\nexports.getPathJS = function() {\n\treturn 'jsio.path.set(' + JSON.stringify(jsio.path.get()) + ');jsio.path.cache=' + JSON.stringify(jsio.path.cache) + ';';\n}\n\nfunction buildJsio(opts, callback) {\n\tfunction getJsioSrc() {\n\t\tvar src = jsio.__jsio.__init__.toString(-1);\n\t\tif (src.substring(0, 8) == 'function') {\n\t\t\tsrc = 'jsio=(' + src + ')();';\n\t\t}\n\t\treturn src;\n\t}\n\n\tvar src,\n\t\tjsioSrc = (opts.includeJsio ? getJsioSrc() : '')\n\t\t\t\t+ exports.getPathJS();\n\n\t// if we're not allowed to modify the jsio source or we're not including the jsio source\n\t// then use jsio.setCachedSrc to include the source strings\n\tif (opts.preserveJsioSource || !opts.includeJsio) {\n\t\tlogger.info('source include method: jsio.setCachedSrc');\n\t\t\n\t\tvar lines = [];\n\t\tfor (var i in gSrcTable) {\n\t\t\tlines.push(\"jsio.setCachedSrc('\" + gSrcTable[i].path + \"',\" + JSON.stringify(gSrcTable[i].src) + \");\");\n\t\t}\n\t\tsrc = jsioSrc + lines.join('\\n');\n\t} else {\n\t\tlogger.info('source include method: setting jsio.__srcCache');\n\t\t\n\t\t// otherwise we can just look for the jsio.__srcCache variable and inline the compiled\n\t\t// source as a JSON string.  We need to use a function here to avoid some ugly escaping\n\t\t// of '$' in the replacement string.\n\t\tsrc = jsioSrc.replace(sourceCache, function(match) { return \"jsio.__srcCache=\" +  JSON.stringify(gSrcTable); });\n\t}\n\t\n\tif (opts.compressResult) {\n\t\tlogger.info('compressing final code...');\n\t\tgActiveCompressor(null, src, callback, opts);\n\t} else {\n\t\tcallback(src);\n\t}\n}\n\nfunction compressTable(table, opts, callback) {\n\tlogger.info('compressing sources');\n\t\n\tvar queue = [];\n\tfor (var i in table) { queue.push(i); }\n\t\n\tcompressStep(queue, table, opts, queue.pop(), callback);\n}\n\nfunction compressStep(queue, table, opts, key, callback) {\n\tif (key) {\n\t\tlogger.log('compressing', key + '...');\n\t\tgActiveCompressor(key, table[key].src, function(result) {\n\t\t\ttable[key].src = result;\n\t\t\tcompressStep(queue, table, opts, queue.pop(), callback);\n\t\t}, opts);\n\t} else {\n\t\tcallback();\n\t}\n}\n\nexports.getTable = function() { return gSrcTable; }\n\nexports.compile = function(statement, opts) {\n\tvar newOpts = mergeOpts({reload: true}, opts);\n\tJSIO(statement, newOpts);\n}\n\nfunction run(moduleDef, cmd, opts, inlineOpts) {\n\tvar newOpts = mergeOpts(opts, inlineOpts);\n\tJSIO.__importer({}, moduleDef.directory, moduleDef.filename, cmd, newOpts);\n}\n\nfunction mergeOpts(opts, inlineOpts) {\n\tvar newOpts = JS.merge(JS.shallowCopy(opts), inlineOpts);\n\t\n\t// add compiler to the end of the preprocessors list\n\tif (newOpts.preprocessors) {\n\t\tfor (var i = 0, len = newOpts.preprocessors.length; i < len; ++i) {\n\t\t\tif (newOpts.preprocessors[i] == 'compiler') {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == len) {\n\t\t\tnewOpts.preprocessors.push('compiler');\n\t\t}\n\t} else {\n\t\tnewOpts.preprocessors = ['compiler'];\n\t}\n\treturn newOpts;\n}\n\n");
jsio.setCachedSrc("../../packages/std/js.js","var SLICE = Array.prototype.slice;\n\nexports.vargs = function(args, n) { return SLICE.call(args, n || 0); }\nexports.isArray = function(input) { return Object.prototype.toString.call(input) === '[object Array]'; }\n\nexports.shallowCopy = function(input) {\n\tif (exports.isArray(input)) {\n\t\treturn input.slice(0);\n\t} else {\n\t\tvar out = {};\n\t\tfor (var key in input) {\n\t\t\tif (input.hasOwnProperty(key)) {\n\t\t\t\tout[key] = input[key];\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn out;\n}\n\nexports.merge = function(base, extra) {\n\tbase = base || {};\n\t\n\tfor (var i = 1, len = arguments.length; i < len; ++i) {\n\t\tvar copyFrom = arguments[i];\n\t\tfor (var key in copyFrom) {\n\t\t\tif (copyFrom.hasOwnProperty(key) && !base.hasOwnProperty(key)) {\n\t\t\t\tbase[key] = copyFrom[key];\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn base;\n}\n\nexports.curry = function(method /*, VARGS*/) {\n\tvar args = SLICE.call(arguments, 1),\n\t\tf = typeof method == 'string'\n\t\t\t\t? function() { this[method].apply(ctx, args.concat(SLICE.call(arguments))); }\n\t\t\t\t: function() { method.apply(this, args.concat(SLICE.call(arguments))); }\n\tf.curried = true;\n\treturn f;\n}\n\nexports.unbind = function(method /*, VARGS*/) {\n\tvar args = SLICE.call(arguments, 1),\n\t\tf = typeof method == 'string'\n\t\t\t\t? function(ctx) { ctx[method].apply(ctx, args.concat(SLICE.call(arguments, 1))); }\n\t\t\t\t: function(ctx) { method.apply(ctx, args.concat(SLICE.call(arguments, 1))); }\n\tf.unbound = true;\n\treturn f;\n}\n\n");
jsio.setCachedSrc("./compiler.js","jsio('from base import *');\nvar logger = logging.get('jsio_compiler');\n\nvar JSIO = 'jsio';\n\nvar supportedEnvs = {\n\tnode: true,\n\tbrowser: true\n};\n\nvar interface = null;\n\nexports.start = function(/*optional*/ args, opts) {\n\tif (!jsio.__env.name in supportedEnvs) {\n\t\tlogger.error(\"autostart failed: unknown environment.\\n\\n\\tTry using compiler.run(args, opts) instead.\");\n\t\treturn;\n\t}\n\t\n\tvar DYNAMIC_IMPORT_COMPILER = 'import .' + jsio.__env.name + '_interface';\n\t\n\tinterface = jsio(DYNAMIC_IMPORT_COMPILER);\n\t\n\t// expects the interface to eventually call startWithOpts to do the actual compile\n\tinterface.init(exports, args, opts);\n}\n\nfunction getPackage(fileName) {\n\ttry {\n\t\tvar pkg = eval('(' + jsio.__env.fetch(fileName) + ')');\n\t\tlogger.info('Package definition loaded from', fileName);\n\t\treturn pkg;\n\t} catch(e) {\n\t\tlogger.log(jsio.__env.getCwd())\n\t\tlogger.warn('If \"' + fileName + '\" is a package file, it could not be read.', e);\n\t}\n\treturn false;\n}\n\n/**\n * args : array of arguments\n *   - args[0] : string - initial import string (optional if opts.package is provided)\n * opts : see optsDef.js\n *   - package : string - filename of a package definition\n *   - debug : integer - debug level (1 - 5)\n */\nexports.run = function(args, opts) {\n\t\n\tvar debugLevel = 'debug' in opts ? opts.debug : 5;\n\n\tlogger.setLevel(debugLevel);\n\tinterface.logger.setLevel(debugLevel);\n\t\n\tif (debugLevel >= 3) {\n\t\tvar strOpts = JSON.stringify(opts, null, '\\t');\n\t\tlogger.info('Starting compiler with args: ', args, 'and options:', strOpts.substring(1, strOpts.length - 1));\n\t}\n\t\n\t// use external copy of jsio rather than cached copy\n\tif (opts.jsioPath) {\n\t\t// force the path\n\t\tjsio.path.set([opts.jsioPath]);\n\t\t\n\t\t// hack to 'set' the js.io source code\n\t\tjsio.__jsio.__init__.toString = function() { return jsio.__env.fetch(jsio.__jsio.__util.buildPath(opts.jsioPath, 'jsio.js')); }\n\t\t\n\t\t// reset cached path\n\t\tfor (var key in jsio.path.cache) {\n\t\t\tdelete jsio.path.cache[key];\n\t\t}\n\t\t\n\t\t// delete the cache copy\n\t\tvar sourceCache = jsio.__jsio.__srcCache;\n\t\tfor (var i in sourceCache) {\n\t\t\tdelete sourceCache[i];\n\t\t}\n\t}\n\t\n\tif (opts.path) {\n\t\tfor(var i = 0, len = opts.path.length; i < len; ++i) {\n\t\t\tif (opts.path[i]) {\n\t\t\t\tjsio.path.add(opts.path[i]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlogger.info('js.io path:', JSON.stringify(jsio.path.get()));\n\t\n\tvar initial;\n\t\n\t// -- parse options --\n\t// try to maintain consistency with pyjsiocompile\n\t\n\t// accept a pkg file as the first argument\n\tif (/\\.pkg$/.test(args[2])) {\n\t\tvar pkg = getPackage(args[2]);\n\n\t\t// was it a valid pkg file?\n\t\t// (our test would also return true for \"import foo.bar.pkg\")\n\t\tif (pkg != false) {\n\t\t\targs.splice(2, 1); // consume the argument\n\t\t\topts.package = pkg; // treat the package the same as if it was specified on the command line\n\t\t}\n\t}\n\t\n\t// opts.package is probably the filename of the package\n\tif (typeof opts.package == 'string' && /\\.pkg$/.test(opts.package)) {\n\t\topts.package = getPackage(opts.package);\n\t} \n\n\t// parse the package contents\n\tif (opts.package) {\n\t\tvar pkgDef = opts.package;\n\t\t\n\t\tlogger.debug(pkgDef);\n\t\t\n\t\t// in pyjsiocompile, root does two things:\n\t\tif ('root' in pkgDef) {\n\t\t\t// 1. provide the initial import\n\t\t\tinitial = pkgDef.root;\n\n\t\t\t// pyjsiocompile package files don't have a relative import indicator (a prefix dot: '.')\n\t\t\t// to indicate that the first import is relative, so manually add one here\n\t\t\tif (!/^\\./.test(initial)) { initial = '.' + initial; }\n\t\t\t\n\t\t\t// 2. generate a statement to include at the bottom of the file\n\t\t\topts.appendImport = true;\n\t\t}\n\t\n\n\t\t// pyjsiocompile has keys for building the dynamic import ENV for the jsio net module.\n\t\t// All pairs of (environment, transport) should be included as dependencies.\n\t\t\n\t\tfunction extendArray(destKey, srcKey) {\n\t\t\topts[destKey] = (opts[destKey] || []).concat(pkgDef[srcKey || destKey]);\n\t\t}\n\t\t\n\t\tfunction extendObject(destKey, srcKey) {\n\t\t\topts[destKey] = JS.merge((opts[destKey] || {}), pkgDef[srcKey || destKey]);\n\t\t}\n\t\t\n\t\tif (pkgDef.environments) { extendArray('environments'); }\n\t\tif (pkgDef.transports) { extendArray('transports'); }\n\t\t\n\t\t// pyjsiocompile never supported additional dependencies, but the package files\n\t\t// have an empty key, so let's implement it anyway\n\t\tif (pkgDef.additional_dependancies) { extendArray('additionalDeps', 'additional_dependancies'); }\n\n\t\t// introduce new key 'dynamicImports' for handling dynamic import resolution\n\t\t//  -> a statement of jsio(DYNAMIC_IMPORT_foo) looks up 'foo' in the dynamicImports\n\t\t//     dictionary (each key maps to a string or array of strings)\n\t\tif (pkgDef.dynamicImports) { extendObject('dynamicImports'); }\n\t}\n\t\n\t// default argument is an import statement:\n\t//    jsio_compile \"import .myModule\"\n\t// (this will be args[2])\n\t// We do this after package resolution since the arguments on the\n\t// command-line should override any settings in the package file.\n\tif (args.length > 2) { initial = args[2]; }\n\t\n\tif (!initial) {\n\t\tinterface.onError('No initial import specified');\n\t\treturn;\n\t}\n\t\n\t// pyjsiocompile built the dynamic import table for the net environment\n\t// which depends on runtime environment and desired transports.  This\n\t// code does the same thing, building a list of imports that need to\n\t// happen upon import of the net.env module.  \n\tlogger.info('dynamic imports: ', opts.dynamicImports);\n\tif (!opts.dynamicImports) { opts.dynamicImports = {}; }\n\tif (!opts.dynamicImports.ENV) { opts.dynamicImports.ENV = null; }\n\tif (opts.transports && opts.environments) {\n\t\tvar ENV = opts.dynamicImports.ENV = opts.dynamicImports.ENV || [];\n\t\tfor (var i = 0, numT = opts.transports.length; i < numT; ++i) {\n\t\t\tfor (var j = 0, numE = opts.environments.length; j < numE; ++j) {\n\t\t\t\topts.dynamicImports.ENV.push('import net.env.' + opts.environments[j] + '.' + opts.transports[i]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvar result = initial.match(/^(.*)\\.js$/);\n\tif (result) {\n\t\tinitial = result[1];\n\t\tif (initial.charAt[0] != '/' && initial.charAt[0] != '.') {\n\t\t\tinitial = './' + initial;\n\t\t}\n\t}\n\t\n\t// run the actual compiler\n\tvar compiler = jsio('import preprocessors.compiler');\n\t\n\tcompiler.setDebugLevel(debugLevel);\n\t\n\tif (opts.compressor) { compiler.setCompressor(opts.compressor); }\n\t\n\tcompiler.compile('import base');\n\t\n\tif (opts.additionalDeps) {\n\t\tvar deps = opts.additionalDeps,\n\t\t\tn = deps.length;\n\t\tlogger.info('compiling dependencies...');\n\t\tfor (var i = 0; i < n; ++i) {\n\t\t\tcompiler.compile(deps[i]);\n\t\t}\n\t}\n\t\n\tvar compileOpts = {\n\t\tautoDetectPaths: true,\n\t\tdynamicImports: opts.dynamicImports\n\t};\n\t\n\tlogger.info('compiling main program', initial, JSON.stringify(compileOpts));\n\tcompiler.compile(initial, compileOpts);\n\t\n\tcompiler.generateSrc(opts, function(src) {\n\t\tif (opts.appendImport) {\n\t\t\tsrc = src + JSIO + '(\"import ' + initial + '\")';\n\t\t}\n\t\t\n\t\tif (opts.footer) {\n\t\t\tsrc = src + (opts.footer || '');\n\t\t}\n\t\t\n\t\tinterface.onFinish(opts, src);\n\t});\n}\n\n");
jsio.setCachedSrc("../../packages/base.js","exports.log = jsio.__env.log;\nexports.GLOBAL = jsio.__env.global;\n\nvar SLICE = Array.prototype.slice;\n\nexports.isArray = function(obj) {\n\treturn Object.prototype.toString.call(obj) === '[object Array]';\n}\n\nexports.bind = function(context, method /*, VARGS*/) {\n\tif(arguments.length > 2) {\n\t\tvar args = SLICE.call(arguments, 2);\n\t\treturn typeof method == 'string'\n\t\t\t? function __bound() {\n\t\t\t\tif (context[method]) {\n\t\t\t\t\treturn context[method].apply(context, args.concat(SLICE.call(arguments, 0)));\n\t\t\t\t} else {\n\t\t\t\t\tthrow logger.error('No method:', method, 'for context', context);\n\t\t\t\t}\n\t\t\t}\n\t\t\t: function __bound() { return method.apply(context, args.concat(SLICE.call(arguments, 0))); }\n\t} else {\n\t\treturn typeof method == 'string'\n\t\t\t? function __bound() {\n\t\t\t\tif (context[method]) {\n\t\t\t\t\treturn context[method].apply(context, arguments);\n\t\t\t\t} else {\n\t\t\t\t\tthrow logger.error('No method:', method, 'for context', context);\n\t\t\t\t}\n\t\t\t}\n\t\t\t: function __bound() { return method.apply(context, arguments); }\n\t}\n}\n\nexports.Class = function(parent, proto) {\n\tif (typeof parent == 'string') {\n\t\tvar name = arguments[0],\n\t\t\tparent = arguments[1],\n\t\t\tproto = arguments[2],\n\t\t\tlogger = exports.logging.get(name);\n\t}\n\t\n\tif (!parent) { throw new Error('parent or prototype not provided'); }\n\tif (!proto) { proto = parent; parent = null; }\n\telse if (exports.isArray(parent)) { // multiple inheritance, use at your own risk =)\n\t\tproto.prototype = {};\n\t\tfor(var i = 0, p; p = parent[i]; ++i) {\n\t\t\tif (p == Error && ErrorParentClass) { p = ErrorParentClass; }\n\t\t\tfor (var item in p.prototype) {\n\t\t\t\tif (!(item in proto.prototype)) {\n\t\t\t\t\tproto.prototype[item] = p.prototype[item];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tparent = parent[0]; \n\t} else {\n\t\tif (parent == Error && ErrorParentClass) { parent = ErrorParentClass; }\n\t\tproto.prototype = parent.prototype;\n\t}\n\t\n\tvar cls = function() { if (this.init) { return this.init.apply(this, arguments); }},\n\t\tsupr = parent ? function(context, method, args) {\n\t\t\tvar f = parent.prototype[method];\n\t\t\tif (!f) { throw new Error('method ' + method + ' does not exist'); }\n\t\t\treturn f.apply(context, args || []);\n\t\t} : null;\n\t\n\tcls.prototype = new proto(logger || supr, logger && supr);\n\tcls.prototype.constructor = cls;\n\tcls.prototype.__parentClass__ = parent;\n\tif (name) { cls.prototype.__class__ = name; }\n\treturn cls;\n}\n\nvar ErrorParentClass = exports.Class(Error, function() {\n\tthis.init = function() {\n\t\tvar err = Error.prototype.constructor.apply(this, arguments);\n\t\tfor (var prop in err) {\n\t\t\tif (err.hasOwnProperty(prop)) {\n\t\t\t\tthis[prop] = err[prop];\n\t\t\t}\n\t\t}\n\t}\n});\n\nexports.Class.defaults = \nexports.merge = function(base, extra) {\n\tbase = base || {};\n\t\n\tfor (var i = 1, len = arguments.length; i < len; ++i) {\n\t\tvar copyFrom = arguments[i];\n\t\tfor (var key in copyFrom) {\n\t\t\tif (copyFrom.hasOwnProperty(key) && !base.hasOwnProperty(key)) {\n\t\t\t\tbase[key] = copyFrom[key];\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn base;\n}\n\nexports.delay = function(orig, timeout) {\n\tvar _timer = null;\n\tvar ctx, args;\n\tvar f = function() { orig.apply(ctx, arguments); }\n\treturn function() {\n\t\tctx = this;\n\t\targs = arguments;\n\t\tif (_timer) { clearTimeout(_timer); }\n\t\t_timer = setTimeout(f, timeout || 0);\n\t}\n}\n\nexports.Class.ctor = function(proto, supr, defaults, post) {\n\tif (!supr) {\n\t\tsupr = function(ctx, method, args) {\n\t\t\tctx._opts = args[0];\n\t\t}\n\t}\n\n\tif (post) {\n\t\tproto.init = function(opts) {\n\t\t\tsupr(this, 'init', [opts = exports.merge(opts, defaults)]);\n\t\t\tpost.apply(this, [opts].concat(SLICE.call(arguments, 1)));\n\t\t}\n\t} else {\n\t\tproto.init = function(opts) {\n\t\t\tsupr(this, 'init', [exports.merge(opts, defaults)]);\n\t\t}\n\t}\n}\n\n// keep logging local variables out of other closures in this file!\nexports.logging = (function() {\n\t\n\t// logging namespace, this is what is exported\n\tvar logging = {\n\t\t\tDEBUG: 1,\n\t\t\tLOG: 2,\n\t\t\tINFO: 3,\n\t\t\tWARN: 4,\n\t\t\tERROR: 5\n\t\t},\n\t\tloggers = {}, // effectively globals - all loggers and a global production state\n\t\tproduction = false;\n\tvar gPrefix = '';\n\tlogging.setPrefix = function(prefix) { gPrefix = prefix + ' '; }\n\tlogging.setProduction = function(prod) { production = !!prod; }\n\tlogging.get = function(name) {\n\t\treturn loggers.hasOwnProperty(name) ? loggers[name]\n\t\t\t: (loggers[name] = new Logger(name));\n\t}\n\tlogging.set = function(name, _logger) {\n\t\tloggers[name] = _logger;\n\t}\n\t\n\tlogging.getAll = function() { return loggers; }\n\n\tlogging.__create = function(pkg, ctx) { ctx.logger = logging.get(pkg); }\n\t\n\tvar Logger = exports.Class(function() {\n\t\tthis.init = function(name, level) {\n\t\t\tthis._name = name;\n\t\t\tthis._level = level || logging.LOG;\n\t\t}\n\t\t\n\t\tthis.setLevel = function(level) { this._level = level; }\n\t\n\t\tfunction makeLogFunction(level, type) {\n\t\t\treturn function() {\n\t\t\t\tif (!production && level >= this._level) {\n\t\t\t\t\tvar prefix = type + ' ' + gPrefix + this._name,\n\t\t\t\t\t\tlistener = this._listener || exports.log;\n\t\t\t\t\t\n\t\t\t\t\treturn listener && listener.apply(this._listener, [prefix].concat(SLICE.call(arguments)));\n\t\t\t\t}\n\t\t\t\treturn arguments[0];\n\t\t\t}\n\t\t}\n\t\n\t\tthis.setListener = function(listener) { this._listener = listener; }\n\t\tthis.debug = makeLogFunction(logging.DEBUG, \"DEBUG\");\n\t\tthis.log = makeLogFunction(logging.LOG, \"LOG\");\n\t\tthis.info = makeLogFunction(logging.INFO, \"INFO\");\n\t\tthis.warn = makeLogFunction(logging.WARN, \"WARN\");\n\t\tthis.error = makeLogFunction(logging.ERROR, \"ERROR\");\n\t});\n\n\treturn logging;\n})();\n\nvar logger = exports.logging.get('jsiocore');\n\n");
jsio.setCachedSrc("./node_interface.js","\njsio(\"import util.optparse;\");\njsio(\"import .optsDef;\");\n\nvar fs = require('fs');\nvar path = require('path');\n\nvar closurePath = '';\n(function() {\n\tvar path = require('path');\n\tvar defaultPath = path.join(path.dirname(jsio.__filename), 'jsio_minify.jar');\n\tif (path.existsSync(defaultPath)) {\n\t\tclosurePath = defaultPath;\n\t}\n})();\n\nexports.logger = logger;\n\nfunction findMinifier(jarPath) {\n\tvar path = require('path');\n\tif (path.existsSync(jarPath)) {\n\t\tclosurePath = jarPath;\n\t}\n}\n\nfunction usage() {\n\tutil.optparse.printUsage('<node> compile.js <initial import>\\n\\t where <initial import> looks like \"import .myModule\"', optsDef);\n}\n\nexports.init = function(compiler, args, opts) {\n\tif (!args) {\n\t\tvar result = util.optparse(process.argv, optsDef),\n\t\t\targs = result.args,\n\t\t\topts = result.opts;\n\t}\n\t\n\tif (opts.help) {\n\t\tusage();\n\t\tprocess.exit();\n\t}\n\t\n\tfindMinifier(opts.closurePath);\n\t\n\topts.compressor = exports.compressor;\n\tcompiler.run(args, opts);\n};\n\nexports.onError = function(msg) {\n\tusage();\n\tjsio.__env.log('');\n\tlogger.error('\\n' + msg);\n\tjsio.__env.log('');\n\tprocess.exit(1);\n}\n\nexports.onFinish = function(opts, src) {\n\tif (opts.outputFile) {\n\t\tlogger.info('Writing output to', opts.outputFile);\n\t\tvar fs = require('fs');\n\t\tfs.writeFileSync(opts.outputFile, src);\n\t} else {\n\t\tlogger.info('Writing output to stdout');\n\t\trequire('sys').print(src);\n\t}\n}\n\nexports.compressor = function(filename, src, callback, opts) {\n\t\n\t\n\tfunction fail(err) {\n\t\tif (err) {\n\t\t\tlogger.error(err);\n\t\t}\n\t\tcallback(src);\n\t}\n\t\n\tif (!closurePath) { return fail(); }\n\t\n\tif (opts.compressorCachePath && filename) {\n\t\ttry {\n\t\t\tvar stat = fs.statSync(filename);\n\t\t\tvar mtime = stat.mtime;\n\t\t\t\n\t\t\tcacheFilename = (/^\\.\\//.test(filename) ? 'R-' + filename.substring(2) : 'A-' + filename).replace(/\\//g, '---')\n\t\t\tvar cachePath = path.join(opts.compressorCachePath, cacheFilename);\n\n\t\t\tif (path.existsSync(cachePath)) {\n\t\t\t\tvar cachedContents = fs.readFileSync(cachePath, 'utf8');\n\t\t\t\tvar i = cachedContents.indexOf('\\n');\n\t\t\t\tvar cachedMtime = cachedContents.substring(0, i);\n\t\t\t\tif (mtime == cachedMtime) {\n\t\t\t\t\tcallback(cachedContents.substring(i + 1));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch(e) {\n\t\t\tlogger.error(e);\n\t\t}\n\t}\n\t\n\tvar spawn = require('child_process').spawn,\n\t    closure = spawn('java', ['-jar', closurePath || 'jsio_minify.jar', '--compilation_level', 'SIMPLE_OPTIMIZATIONS']),\n\t\tstdout = [],\n\t\tstderr = [];\n\t\n\tclosure.stdout.on('data', function(data) { stdout.push(data); });\n\tclosure.stderr.on('data', function(data) { stderr.push(data); });\n\tclosure.on('exit', function(code) {\n\t\tif (code == 0) {\n\t\t\tvar compressedSrc = stdout.join('');\n\t\t\ttry {\n\t\t\t\tif (cachePath) {\n\t\t\t\t\tfs.writeFileSync(cachePath, mtime + '\\n' + compressedSrc);\n\t\t\t\t}\n\t\t\t} catch(e) {\n\t\t\t\tlogger.error(e);\n\t\t\t}\n\t\t\t\n\t\t\tcallback(compressedSrc);\n\t\t} else {\n\t\t\tfail(stderr.join(''));\n\t\t}\n\t});\n\t\n\tclosure.stdin.write(src);\n\tclosure.stdin.end();\n}\n\n");
jsio.setCachedSrc("../../packages/util/optparse.js","\njsio(\"import util.jsonSchema\");\njsio(\"import lib.Enum;\");\n\n/* optparser */\n\n/*\n\noptsDef = {\n\t'-v': {\n\t\tname: 'version',\n\t\tdescription: 'prints the version information',\n\t\targs: {\n\t\t\t0: '\n\t\t}\n\t}\n}\n\n*/\n\njsio(\"import std.js as JS;\");\n\nfunction ERROR(msg) {\n\tlogger.error(msg);\n\tprocess.exit(1);\n}\n\nfunction addAlso(optsDef, also, value) {\n\tif (typeof also == 'string') {\n\t\toptsDef[also] = value;\n\t} else {\n\t\tlogger.warn('Key specified in option', optsDef.name, 'is invalid.  Ignoring:', also);\n\t}\n}\n\nvar truthyValues = lib.Enum('true', '1', 'yes'),\n\tfalsyValues = lib.Enum('false', '0', 'no');\n\nfunction addArg(result, optsDef, argv, i) {\n\tvar val,\n\t\tsrcName = argv[i],\n\t\titemSchema = optsDef[argv[i]],\n\t\tlen = argv.length,\n\t\titemType = itemSchema.type.toLowerCase();\n\t\n\t++i;\n\tswitch(itemType) {\n\t\tcase 'boolean':\n\t\t\tif (typeof argv[i] == 'undefined') {\n\t\t\t\tval = true;\n\t\t\t\t--i;\n\t\t\t} else if (argv[i].toLowerCase() in truthyValues) {\n\t\t\t\tval = true;\n\t\t\t} else if (argv[i].toLowerCase() in falsyValues) {\n\t\t\t\tval = false;\n\t\t\t} else {\n\t\t\t\tval = true;\n\t\t\t\t--i;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'int':\n\t\tcase 'integer':\n\t\t\tval = parseInt(argv[i]);\n\t\t\tbreak;\n\t\tcase 'float':\n\t\tcase 'double':\n\t\tcase 'number':\n\t\t\tval = parseFloat(argv[i]);\n\t\t\tbreak;\n\t\tcase 'array':\n\t\tcase 'object':\n\t\t\tvar buf = argv[i];\n\t\t\twhile(true) {\n\t\t\t\ttry {\n\t\t\t\t\tvar val = eval('(' + buf + ')');\n\t\t\t\t\tbreak;\n\t\t\t\t} catch(e) {}\n\t\t\t\t++i;\n\t\t\t\tif (i >= len) { ERROR('Could not parse \"' + srcName + '\": ' + itemSchema.type + '\\n' + buf + '\\n' + JSON.stringify(argv)); }\n\t\t\t\tbuf += argv[i];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'any':\n\t\tcase 'string':\n\t\tdefault:\n\t\t\tval = argv[i];\n\t\t\tbreak;\n\t}\n\t\n\tvar status = util.jsonSchema.validate(val, itemSchema);\n\tif (status.valid) {\n\t\tresult[itemSchema.name] = val;\n\t\treturn i + 1;\n\t} else {\n\t\tvar log = [];\n\t\tfor(var k = 0, e; e = status.errors[k]; ++k) {\n\t\t\tlog.push('\\n\\t\\t' + (e.property ? e.property + ': ' : '') + e.message)\n\t\t}\n\t\t\n\t\tERROR('\\n' + srcName + ': provided value ' + argv[i] + '\\n\\t' + itemSchema.name + ' option:' + log.join(''));\n\t}\n}\n\nexports = function(argv, origDef) {\n\tvar optsDef = JS.shallowCopy(origDef),\n\t\tresult = {};\n\tfor (var i in optsDef) {\n\t\tvar opt = optsDef[i];\n\t\tif ('default' in opt) { result[opt.name] = opt.default; }\n\t\t\n\t\tvar also = opt.also;\n\t\tif (also) {\n\t\t\tif (JS.isArray(also)) {\n\t\t\t\tfor (var j = 0, len = also.length; j < len; ++j) {\n\t\t\t\t\taddAlso(optsDef, also[j], opt);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\taddAlso(optsDef, also, opt);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvar unprocessed = [],\n\t\ti = 0,\n\t\tlen = argv.length;\n\t\n\twhile (i < len) {\n\t\tif (argv[i] in optsDef) {\n\t\t\ti = addArg(result, optsDef, argv, i);\n\t\t} else {\n\t\t\tunprocessed.push(argv[i]);\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\treturn {\n\t\targs: unprocessed,\n\t\topts: result\n\t};\n}\n\nexports.printUsage = function(usage, optsDef) {\n\tjsio(\"import util.wordWrap;\");\n\t\n\tvar print = jsio.__env.log;\n\tprint('Usage:');\n\tprint('\\t' + usage);\n\tprint('Options:');\n\tfor (var i in optsDef) {\n\t\tvar opt = [i];\n\t\tif (optsDef[i].also) {\n\t\t\tif (JS.isArray(optsDef[i].also)) {\n\t\t\t\topt = opt.concat(optsDef[i].also);\n\t\t\t} else {\n\t\t\t\topt.push(optsDef[i].also);\n\t\t\t}\n\t\t}\n\t\tprint('\\t'+opt.join(', '));\n\t\tif (optsDef[i].description) {\n\t\t\tprint(util.wordWrap(optsDef[i].description, 80, '\\t\\t'));\n\t\t}\n\t}\n}\n");
jsio.setCachedSrc("../../packages/util/jsonSchema.js","\n/** \r\n* JSONSchema Validator\r\n* ====================\r\n*\r\n* Validates JavaScript objects using JSON Schemas\r\n* http://json-schema.org/\r\n*\r\n* Based on jsonschema-b4.js:\r\n*   Copyright (c) 2007 Kris Zyp SitePen (www.sitepen.com)\r\n*   Licensed under the MIT (MIT-LICENSE.txt) license.\r\n* \r\n* To use the validator call JSONSchema.validate with an instance object\r\n* and an optional schema object. If a schema is provided, it will be used\r\n* to validate. If the instance object refers to a schema\r\n* (self-validating), that schema will be used to validate and the schema\r\n* parameter is not necessary (if both exist, both validations will\r\n* occur). The validate method will return an array of validation errors.\r\n* If there are no errors, then an empty list will be returned. A\r\n* validation error will have two properties: \r\n*\t1. \"property\" - the property that had the error\r\n*\t2. \"message\" - the error message\r\n*/\r\n\r\njsio(\"import std.js as JS;\");\r\n\r\n// JSONSchema:\r\nexports = {\r\n\t// function (instance, schema):\r\n\t// \t\tTo use the validator call JSONSchema.validate with an instance object and an optional schema object.\r\n\t// \t\tIf a schema is provided, it will be used to validate. If the instance object refers to a schema (self-validating), \r\n\t// \t\tthat schema will be used to validate and the schema parameter is not necessary (if both exist, \r\n\t// \t\tboth validations will occur). \r\n\t// \t\tThe validate method will return an object with two properties:\r\n\t// \t\t\tvalid: A boolean indicating if the instance is valid by the schema\r\n\t// \t\t\terrors: An array of validation errors. If there are no errors, then an \r\n\t// \t\t\t\t\tempty list will be returned. A validation error will have two properties: \r\n\t// \t\t\t\t\t\tproperty: which indicates which property had the error\r\n\t// \t\t\t\t\t\tmessage: which indicates what the error was\r\n\t//\r\n\tvalidate: validate,\r\n\r\n\t// Summary:\r\n\t// \t\tThe checkPropertyChange method will check to see if a value can legally be in a property with the given schema\r\n\t// \t\tThis is slightly different than the validate method in that it will fail if the schema is readonly and it will\r\n\t// \t\tnot check for self-validation, it is assumed that the passed in value is already internally valid.  \r\n\t// \t\tThe checkPropertyChange method will return the same object type as validate, see JSONSchema.validate for \r\n\t// \t\tinformation.\r\n\t//\r\n\tcheckPropertyChange: function(/*Any*/value,/*Object*/schema, /*String*/ property) {\r\n\t\treturn validate(value, schema, property || \"property\");\r\n\t}\r\n}\r\n\r\nvar gCheckPropChange = false;\r\nfunction validate(instance, schema, property) {\r\n\tgCheckPropChange = property;\r\n\t\r\n\tvar errors = schema ? checkProp(instance, schema, '', property || '') : [];\r\n\tif (!property && instance && instance.$schema) {\r\n\t\tcheckProp(instance, instance.$schema, '', '', errors);\r\n\t}\r\n\t\r\n\treturn {\r\n\t\tvalid: !errors.length,\r\n\t\terrors: errors\r\n\t};\r\n}\r\n\r\n// validate a value against a property definition\r\nfunction checkProp(value, schema, path, i, errors) {\r\n\tif (!errors) { errors = []; }\r\n\t\r\n\tpath += \r\n\t\tpath ? typeof i == 'number' ? '[' + i + ']'\r\n\t\t\t : typeof i == 'undefined' ? '' : '.' + i : i;\r\n\t\r\n\tfunction addError(message) {\r\n\t\terrors.push({\r\n\t\t\tproperty: path,\r\n\t\t\tmessage:message\r\n\t\t});\r\n\t}\r\n\r\n\tvar schemaType = typeof schema,\r\n\t\tisObject = schemaType == 'object',\r\n\t\tisFunction = schemaType == 'function';\r\n\t\r\n\tif ((!isObject || JS.isArray(schema)) && (path || !isFunction)) {\r\n\t\tif (isFunction) {\r\n\t\t\tif (!(value instanceof schema)) {\r\n\t\t\t\taddError(\"is not an instance of the class/constructor \" + schema.name);\r\n\t\t\t}\r\n\t\t} else if (schema) {\r\n\t\t\taddError(\"Invalid schema/property definition \" + schema);\r\n\t\t}\r\n\t\t\r\n\t\treturn errors;\r\n\t}\r\n\t\r\n\tif (gCheckPropChange && schema.readonly) { addError(\"is a readonly field, it can not be changed\"); }\r\n\t\r\n\t// if it extends another schema, it must pass that schema as well\r\n\tif (schema['extends']) { checkProp(value, schema['extends'], path, i, errors); }\r\n\t\r\n\tif (value === undefined) {\r\n\t\tif (!schema.optional) { addError(\"is missing and it is not optional\"); }\r\n\t} else {\r\n\t\terrors = errors.concat(checkType(schema.type,value));\r\n\t\tif (schema.disallow && !checkType(schema.disallow,value).length) { addError(\" disallowed value was matched\"); }\r\n\t\t\r\n\t\tif (value !== null) {\r\n\t\t\tif (JS.isArray(value)) {\r\n\t\t\t\tif (schema.items) {\r\n\t\t\t\t\tif (JS.isArray(schema.items)) {\r\n\t\t\t\t\t\tfor (i=0,l=value.length; i<l; i++) {\r\n\t\t\t\t\t\t\terrors.concat(checkProp(value[i],schema.items[i],path,i, errors));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tfor (i=0,l=value.length; i<l; i++) {\r\n\t\t\t\t\t\t\terrors.concat(checkProp(value[i],schema.items,path,i, errors));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\t\t\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\tif (schema.minItems && value.length < schema.minItems) {\r\n\t\t\t\t\taddError(\"There must be a minimum of \" + schema.minItems + \" in the array\");\r\n\t\t\t\t}\r\n\t\t\t\tif (schema.maxItems && value.length > schema.maxItems) {\r\n\t\t\t\t\taddError(\"There must be a maximum of \" + schema.maxItems + \" in the array\");\r\n\t\t\t\t}\r\n\t\t\t} else if (schema.properties) {\r\n\t\t\t\terrors.concat(checkObj(value, schema.properties, path, schema.additionalProperties, errors));\r\n\t\t\t}\r\n\t\t\tif (schema.pattern && typeof value == 'string' && !value.match(schema.pattern)) {\r\n\t\t\t\taddError(\"does not match the regex pattern \" + schema.pattern);\r\n\t\t\t}\r\n\t\t\tif (schema.maxLength && typeof value == 'string' && value.length > schema.maxLength) {\r\n\t\t\t\taddError(\"may only be \" + schema.maxLength + \" characters long\");\r\n\t\t\t}\r\n\t\t\tif (schema.minLength && typeof value == 'string' && value.length < schema.minLength) {\r\n\t\t\t\taddError(\"must be at least \" + schema.minLength + \" characters long\");\r\n\t\t\t}\r\n\t\t\tif (typeof schema.minimum !== undefined\r\n\t\t\t\t\t&& typeof value == typeof schema.minimum\r\n\t\t\t\t\t&& schema.minimum > value)\r\n\t\t\t{\r\n\t\t\t\taddError(\"must have a minimum value of \" + schema.minimum);\r\n\t\t\t}\r\n\t\t\tif (typeof schema.maximum !== undefined\r\n\t\t\t\t\t&& typeof value == typeof schema.maximum\r\n\t\t\t\t\t&& schema.maximum < value)\r\n\t\t\t{\r\n\t\t\t\taddError(\"must have a maximum value of \" + schema.maximum);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (schema['enum']) {\r\n\t\t\t\t\r\n\t\t\t\tvar enumer = schema['enum'],\r\n\t\t\t\t\tfound;\r\n\t\t\t\t\r\n\t\t\t\tvar l = enumer.length;\r\n\t\t\t\tfor(var j = 0; j < l; j++) {\r\n\t\t\t\t\tif (enumer[j]===value) {\r\n\t\t\t\t\t\tfound=1;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif (!found) { addError(\"does not have a value in the enumeration \" + enumer.join(\", \")); }\r\n\t\t\t}\r\n\t\t\tif (typeof schema.maxDecimal == 'number' && \r\n\t\t\t(value.toString().match(new RegExp(\"\\\\.[0-9]{\" + (schema.maxDecimal + 1) + \",}\")))) {\r\n\t\t\t\taddError(\"may only have \" + schema.maxDecimal + \" digits of decimal places\");\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn errors;\r\n}\r\n\r\n// validate an object against a schema\r\nfunction checkObj(instance, objTypeDef, path, additionalProp, errors) {\r\n\r\n\tif (typeof objTypeDef =='object') {\r\n\t\tif (typeof instance != 'object' || JS.isArray(instance)) {\r\n\t\t\terrors.push({\r\n\t\t\t\tproperty: path,\r\n\t\t\t\tmessage: \"an object is required\"\r\n\t\t\t});\r\n\t\t}\r\n\t\t\r\n\t\tfor(var i in objTypeDef) { \r\n\t\t\tif (objTypeDef.hasOwnProperty(i) && !(i.charAt(0) == '_' && i.charAt(1) == '_')) {\r\n\t\t\t\tvar value = instance[i];\r\n\t\t\t\tvar propDef = objTypeDef[i];\r\n\t\t\t\tcheckProp(value,propDef,path,i, errors);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tfor(i in instance) {\r\n\t\tif (instance.hasOwnProperty(i)\r\n\t\t\t\t&& !(i.charAt(0) == '_'\r\n\t\t\t\t&& i.charAt(1) == '_')\r\n\t\t\t\t&& objTypeDef\r\n\t\t\t\t&& !objTypeDef[i]\r\n\t\t\t\t&& additionalProp === false)\r\n\t\t{\r\n\t\t\terrors.push({\r\n\t\t\t\tproperty: path,\r\n\t\t\t\tmessage: (typeof value) + \"The property \" + i +\r\n\t\t\t\t\t\" is not defined in the schema and the schema does not allow additional properties\"\r\n\t\t\t});\r\n\t\t}\r\n\t\t\r\n\t\tvar requires = objTypeDef && objTypeDef[i] && objTypeDef[i].requires;\r\n\t\tif (requires && !(requires in instance)) {\r\n\t\t\terrors.push({\r\n\t\t\t\tproperty: path,\r\n\t\t\t\tmessage: \"the presence of the property \" + i + \" requires that \"\r\n\t\t\t\t\t+ requires + \" also be present\"\r\n\t\t\t});\r\n\t\t}\r\n\t\t\r\n\t\tvalue = instance[i];\r\n\t\tif (objTypeDef && typeof objTypeDef == 'object' && !(i in objTypeDef)) {\r\n\t\t\tcheckProp(value, additionalProp, path, i, errors); \r\n\t\t}\r\n\t\t\r\n\t\tif (!gCheckPropChange && value && value.$schema) {\r\n\t\t\terrors = errors.concat(checkProp(value, value.$schema, path, i, errors));\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn errors;\r\n}\r\n\r\n// validate a value against a type definition\r\nfunction checkType(type, value, errors) {\r\n\tif (type) {\r\n\t\tvar actualType = typeof value;\r\n\t\t\r\n\t\tif (typeof type == 'string') {\r\n\t\t\ttype = type.toLowerCase();\r\n\t\t\tswitch(type) {\r\n\t\t\t\tcase 'any':\r\n\t\t\t\t\treturn [];\r\n\t\t\t\tcase 'array':\r\n\t\t\t\t\tif (!JS.isArray(value)) {\r\n\t\t\t\t\t\treturn [{\r\n\t\t\t\t\t\t\tproperty: path,\r\n\t\t\t\t\t\t\tmessage: 'expected an array, but ' + actualType + ' found instead'\r\n\t\t\t\t\t\t}];\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'integer':\r\n\t\t\t\tcase 'int':\r\n\t\t\t\t\ttype = 'integer';\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'float':\r\n\t\t\t\tcase 'double':\r\n\t\t\t\tcase 'number':\r\n\t\t\t\t\ttype = 'number';\r\n\t\t\t\t\t// fall through\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tif (actualType != type) {\r\n\t\t\t\t\t\treturn [{\r\n\t\t\t\t\t\t\tproperty: path,\r\n\t\t\t\t\t\t\tmessage: 'expected ' + type + ', but ' + actualType + ' found instead'\r\n\t\t\t\t\t\t}];\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\treturn [];\r\n\t\t}\r\n\t\t\r\n\t\tif (JS.isArray(type)) {\r\n\t\t\tvar unionErrors = [];\r\n\t\t\tfor(var j = 0; j < type.length; j++) { // a union type\r\n\t\t\t\tvar errs = checkType(type[j], value, errors);\r\n\t\t\t\tif (!errs.length) { return []; }\r\n\t\t\t\tunionErrors = unionErrors.concat(errs);\r\n\t\t\t}\r\n\t\t\treturn unionErrors;\r\n\t\t} else if (typeof type == 'object') {\r\n\t\t\treturn checkProp(value, type, path);\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn [];\r\n}\r\n");
jsio.setCachedSrc("../../packages/lib/Enum.js","exports = function() {\n\tif (arguments.length == 1) {\n\t\tif (typeof arguments[0] == 'object') {\n\t\t\tvar obj = arguments[0];\n\t\t\tfor (var i in obj) {\n\t\t\t\tif (!(obj[i] in obj)) {\n\t\t\t\t\tobj[obj[i]] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn obj;\n\t\t} else if (typeof arguments[0] != 'string') {\n\t\t\tkeys = arguments[0];\n\t\t}\n\t}\n\t\n\tif (!keys) { var keys = arguments; }\n\tvar obj = {};\n\tfor(var i = 0, len = keys.length; i < len; ++i) {\n\t\tif (keys[i]) {\n\t\t\tobj[keys[i]] = i + 1;\n\t\t}\n\t\tobj[i + 1] = keys[i];\n\t}\n\treturn obj;\n}");
jsio.setCachedSrc("../../packages/util/wordWrap.js","exports = function(str, maxWidth, prefix, tabWidth) {\n\tprefix = prefix || '';\n\tmaxWidth -= exports.getLengthWithTabs(prefix, tabWidth);\n\t\n\tif (!maxWidth) { return prefix + str; }\n\t\n\tvar words = str.split(' '),\n\t\tnumWords = words.length,\n\t\tlines = [{\n\t\t\tstr: [],\n\t\t\tlen: 0\n\t\t}],\n\t\ti = 0;\n\t\n\tfunction finalize() {\n\t\tlines[i] = prefix + curLine.str.join(' ');\n\t\t++i;\n\t}\n\t\n\tvar curLine = lines[i];\n\tfor (var j = 0; j < numWords; ++j) {\n\t\tvar word = words[j],\n\t\t\twordLen = word.length;\n\t\tif (curLine.len && curLine.len + wordLen + 1 > maxWidth) {\n\t\t\tfinalize();\n\t\t\tcurLine = lines[i] = {str: [word], len: wordLen};\n\t\t} else {\n\t\t\tcurLine.str.push(word);\n\t\t\tif (curLine.len) { curLine.len++; }\n\t\t\tcurLine.len += wordLen;\n\t\t}\n\t}\n\t\n\tif (curLine.len) {\n\t\tfinalize();\n\t} else {\n\t\tlines.pop();\n\t}\n\t\n\treturn lines.join('\\n');\n}\n\nexports.getLengthWithTabs = function(str, tabWidth) {\n\tvar tabs = 0;\n\tstr = str.replace(/\\t/g, function() { ++tabs; });\n\treturn str.length + tabs * (tabWidth || 8);\n}\n");
jsio.setCachedSrc("./optsDef.js","exports = {\n\t'-g': {\n\t\talso: '--compressResult',\n\t\tname: 'compressResult',\n\t\ttype: 'boolean',\n\t\tdescription: \"Compress final output with Google's Closure Compiler\"\n\t},\n\t'-c': {\n\t\talso: '--compress',\n\t\tname: 'compressSources',\n\t\ttype: 'boolean',\n\t\tdefault: false,\n\t\tdescription: \"Compress individual source files with Google's Closure Compiler\"\n\t},\n\t'--closure': {\n\t\tname: 'closurePath',\n\t\ttype: 'string',\n\t\tdescription: \"Path to closure.jar, if using compression (default: cwd)\"\n\t},\n\t'-d': {\n\t\talso: '--debug',\n\t\tname: 'debug',\n\t\ttype: 'integer',\n\t\tminimum: 0,\n\t\tmaximum: 5,\n\t\tconstants: {\n\t\t\t'DEBUG': 1,\n\t\t\t'LOG': 2,\n\t\t\t'INFO': 3,\n\t\t\t'WARN': 4,\n\t\t\t'ERROR': 5\n\t\t},\n\t\tdescription: \"Turn on the compiler logger. A value of i logs all levels i and higher. 1: DEBUG, 2: LOG, 3: INFO, 4: WARN, 5: ERROR\"\n\t},\n\t'--dynamic': {\n\t\tname: 'dynamicImports',\n\t\ttype: 'object',\n\t\tdescription: 'Specify dynamic jsio imports'\n\t},\n\t'-p': {\n\t\tname: 'package',\n\t\talso: '--package',\n\t\ttype: 'object',\n\t\tdescription: \"Specifies a package file.  The compiler looks for configuration parameters from the command line as well as the package file.  Command line options have precedence over package settings provided in the package file.\"\n\t},\n\t'-j': {\n\t\tname: 'jsioPath',\n\t\ttype: 'string',\n\t\talso: '--jsio',\n\t\tdescription: \"Provides an alternative path for jsio.  This path must contain the file 'jsio.js'.  The compiler contains a copy of jsio, so this is optional (can be used to compile against custom versions of jsio).\"\n\t},\n\t'--path': {\n\t\tname: 'path',\n\t\ttype: 'array',\n\t\tdescription: \"Provide extra paths (follow --path with a JSON literal array of strings)\"\n\t},\n\t'-o': {\n\t\tname: 'outputFile',\n\t\ttype: 'string',\n\t\talso: '--output',\n\t\tdescription: \"The filename to write the compiled code to.  Defaults to stdout (prints to the console).\"\n\t},\n\t'--preserveJsioSource': {\n\t\tname: 'preserveJsioSource',\n\t\ttype: 'boolean',\n\t\tdefault: false,\n\t\tdescription: \"(advanced option) Specify this option if the compiler shouldn't modify the core jsio JavaScript.  This option wraps compiled source in the jsio API call setCachedSrc rather than inserting the source into the jsio cache table.\"\n\t},\n\t'--includeJsio': {\n\t\tname: 'includeJsio',\n\t\ttype: 'boolean',\n\t\tdefault: true,\n\t\tdescription: \"(advanced option) Defaults to true.  Set to false to exclude jsio from the resulting source.  Setting to false enables --preserveJsioSource.\"\n\t},\n\t'--appendImport': {\n\t\tname: 'appendImport',\n\t\ttype: 'boolean',\n\t\tdefault: true,\n\t\tdescription: \"Defaults to true.  When true, the import statement passed to the compiler is appended to the end of the file.\"\n\t},\n\t'--compressorCachePath': {\n\t\tname: 'compressorCachePath',\n\t\ttype: 'string',\n\t\tdescription: \"Provide a path to cache compressed source.\"\n\t},\n\t'--help': {\n\t\ttype: 'boolean',\n\t\tdescription: \"prints this help message\"\n\t}\n}\n");
jsio.setCachedSrc("../../packages/lib/Callback.js","\njsio(\"import std.js as JS;\");\n\nexports = Class(function() {\n\tthis.init = function() {\n\t\tthis._fired = false;\n\t\tthis._run = [];\n\t\tthis._id = 0;\n\t\tthis._pending = 0;\n\t\tthis._stat = {};\n\t}\n\t\n\tthis.fired = function() { return this._fired; } \n\tthis.reset = function() { this._args = []; this._fired = false; }\n\tthis.clear = function() { this.reset(); this._run = []; }\n\tthis.forward = function(args) { this.run.apply(this, args); }\n\tthis.run = function(ctx, method) {\n\t\tvar f = method ? bind.apply(this, arguments) : ctx;\n\t\tif (f) {\n\t\t\tif (this._fired) {\n\t\t\t\tf.apply(this, this._args);\n\t\t\t} else {\n\t\t\t\tthis._run.push(f);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\t\n\tthis.fire = function() {\n\t\tif (this._fired) { return; }\n\t\tthis._fired = true;\n\t\t\n\t\tvar cbs = this._run;\n\t\tthis._run = [];\n\t\tthis._args = arguments;\n\t\tfor(var i = 0, len = cbs.length; i < len; ++i) {\n\t\t\tif (cbs[i]) { cbs[i].apply(this, arguments); }\n\t\t}\n\t}\n\t\n\tthis.chain = function(id) {\n\t\t++this._pending;\n\t\tthis.reset();\n\t\treturn bind(this, '_deferred', id || (this._id++));\n\t}\n\n\tthis._deferred = function(id) {\n\t\tif (this._stat.hasOwnProperty(id)) { return; }\n\n\t\tthis._stat[id] = JS.vargs(arguments, 1);\n\t\tif (this._pending) { --this._pending; }\n\t\tif (!this._pending) { this.fire(this._stat); }\n\t}\n});\n");
jsio.setCachedSrc("../../packages/lib/Hash.js","/**\n * Summary: a basic Hash/Set class for number and string values.\n * Methods:\n *  - init(args...) - if args is a single JS object, this will be used to define\n *      the keys and values for the Hash.  \n *  - contains(value) \n * Example:\n *  var h = new Hash('a', 'b', 'c');\n *  h.contains('a') ==> true\n *\n *  var h = new Hash({a: '1', b: '2', c: '3'});\n *  h.contains('1') ==> true\n *  h.hasKey('a') ==> true\n */\nexports = Class(function() {\n\tthis.init = function() {\n\t\tthis._keys = {};\n\t\tthis._dict = {};\n\t\tthis._values = {};\n\t\tif (arguments.length == 1 && typeof arguments == 'object') {\n\t\t\tvar dict = arguments[0];\n\t\t\tfor (var i in dict) {\n\t\t\t\tif (dict.hasOwnProperty(i)) {\n\t\t\t\t\tthis._keys[i] = true;\n\t\t\t\t\tthis._values[i] = dict[i];\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (var i = 0, len = arguments.length; i < len; i++) {\n\t\t\t\tthis._keys[arguments[i]] = true;\n\t\t\t\tthis._values[arguments[i]] = true;\n\t\t\t};\n\t\t}\n\t}\n\t\n\tthis.contains = function(val) { return this._values.hasOwnProperty(val); }\n\tthis.hasKey = this.containsKey = function(key) { return this._keys.hasOwnProperty(key); }\n\tthis.each = function(f, ctx) {\n\t\tfor (var i in keys) {\n\t\t\tif (this._keys.hasOwnProperty(i)) {\n\t\t\t\tf.call(ctx || GLOBAL, i, this._values[i], this);\n\t\t\t}\n\t\t}\n\t}\n});\n");
jsio.setCachedSrc("../../packages/lib/Iterator.js","\n/**\n * Summary: Provides an object for iterating over the keys and values of\n * an object or array.  \n * Methods: \n *  - init(src) - src is the object to iterate over\n *  - next(): returns the current value and advances the iterator to the next value\n *  - loop(cb): iterate over all items immediately, calling cb with each item\n *  - asyncLoop(cb): iterate over all items asynchronously.  First argument to\n *     the callback is the item.  Second argument is a function `nextItem` that, \n *     when called, will cause the iterator to advance to the next element and \n *     call cb again.\n * Usage notes: asyncLoop is implemented to not be vulnerable to stack overflows.\n *     If cb immediately calls the nextItem function, it will not immediately \n *     result in a call to cb -- the stack will unwind to the asyncLoop call \n *     before continuing.\n */\n\njsio(\"import std.js as JS;\");\n\nexports = Class(function() {\n\tthis.init = function(src) {\n\t\tthis._src = src;\n\t\tthis._i = 0;\n\t\t\n\t\t// a call count prevents a stack overflow if the callback in\n\t\t// an aysncloop is called repeatedly for large arrays\n\t\tthis._calls = 0;\n\t\tif (JS.isArray(src)) {\n\t\t\tthis._isArray = true;\n\t\t} else if (Object.keys) {\n\t\t\tthis._keys = Object.keys(src);\n\t\t} else {\n\t\t\tvar k = this._keys = [];\n\t\t\tfor (var i in src) { if (src.hasOwnProperty(i)) { k.push(i); } }\n\t\t}\n\t}\n\t\n\tthis.nextKey = function() {\n\t\treturn this._keys[this._i++];\n\t}\n\t\n\tthis.next = function() {\n\t\tif (this._isArray) {\n\t\t\treturn this._src[this._i++] || exports.END_OF_LOOP;\n\t\t} else {\n\t\t\tvar key = this._keys[this._i++];\n\t\t\treturn key ? this._src[key] : exports.END_OF_LOOP;\n\t\t}\n\t}\n\t\n\tthis.loop = function(cb) {\n\t\tif (arguments.length > 1) { cb = bind.apply(this, arguments); }\n\t\tvar next;\n\t\tif (this._isArray) {\n\t\t\twhile((next = this.next())) {\n\t\t\t\tcb(next);\n\t\t\t}\n\t\t} else {\n\t\t\twhile((next = this.nextKey())) {\n\t\t\t\tcb(this._src[next], next);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tthis.asyncLoop = function(cb) {\n\t\tif (arguments.length > 1) { cb = bind.apply(this, arguments); }\n\t\tthis._next = bind(this, '_onReturn', cb);\n\t\tthis._calls++;\n\t\tthis._asyncLoop(cb);\n\t}\n\t\n\tthis._asyncLoop = function(cb) {\n\t\tthis._inLoop = true;\n\t\twhile (this._calls) {\n\t\t\t--this._calls;\n\t\t\tcb(this.next(), this._next);\n\t\t}\n\t\tthis._inLoop = false;\n\t}\n\t\n\tthis._onReturn = function(cb) {\n\t\tthis._calls++;\n\t\tif (!this._inLoop) { this._asyncLoop(cb); }\n\t}\n});\n\nexports.END_OF_LOOP = new Error('jsio.Iterator.END_OF_LOOP');\n");
jsio.setCachedSrc("../../packages/lib/LogClass.js","exports = function(name, parent, proto) {\n\tif (!proto) { proto = parent; parent = null; }\n\tvar protoRef = {},\n\t\tloggingProto = bind(this, LogClassProto, name, proto, logging.get(name), protoRef);\n\tprotoRef.proto = loggingProto;\n\treturn parent ? Class(parent, loggingProto) : Class(loggingProto);\n}\n\nfunction LogClassProto(name, proto, logger, protoRef, supr) {\n\tproto.prototype = protoRef.proto.prototype;\n\tvar p = new proto(logger, supr);\n\tp.__class__ = name;\n\treturn p;\n}\n\n");
jsio.setCachedSrc("../../packages/lib/PubSub.js","/**\n * Summary: inherit from lib.PubSub if a class wants publish/subscribe ability\n * Methods:\n *  - publish(signal, args...) - all subscribers to signal will be called\n *     with the list of arguments provided.\n *  - subscribe(signal, ctx, method, args...) - register a bound method\n *     to a signal.  Any args that are passed in will be the first args\n *     when the method is invoked during a publish.\n *  Usage notes: There is one special signal '__any'.  Any subscribers to\n *     '__any' will be called on every publish with the first publish\n *     argument being the signal itself (after any args passed in during\n *     the corresponding subscribe). \n *     Calling the super constructor is not required for descendants of \n *     lib.PubSub. \n */\nvar ctx = jsio.__env.global,\n\tSLICE = Array.prototype.slice;\n\nexports = Class(function() {\n\tthis.init = function() {}\n\t\n\tthis.publish = function(signal) {\n\t\tif(this._subscribers) {\n\t\t\tvar args = SLICE.call(arguments, 1);\n\t\t\tif(this._subscribers.__any) {\n\t\t\t\tvar anyArgs = [signal].concat(args),\n\t\t\t\t\tsubs = this._subscribers.__any.slice(0);\n\t\t\t\tfor(var i = 0, sub; sub = subs[i]; ++i) {\n\t\t\t\t\tsub.apply(ctx, anyArgs);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(!this._subscribers[signal]) { return; }\n\t\t\t\n\t\t\tvar subs = this._subscribers[signal].slice(0);\n\t\t\tfor(var i = 0, sub; sub = subs[i]; ++i) {\n\t\t\t\tsub.apply(ctx, args);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\t\n\tthis.subscribe = function(signal, ctx, method) {\n\t\tvar cb;\n\t\tif (arguments.length == 2) {\n\t\t\tcb = ctx;\n\t\t} else {\n\t\t\tcb = bind.apply(GLOBAL, SLICE.call(arguments, 1));\n\t\t\tcb._ctx = ctx; // references for unsubscription\n\t\t\tcb._method = method;\n\t\t}\n\t\t\n\t\tvar s = this._subscribers || (this._subscribers = {});\n\t\t(s[signal] || (s[signal] = [])).push(cb);\n\t\treturn this;\n\t}\n\t\n\tthis.subscribeOnce = function(signal, ctx, method) {\n\t\tvar args = arguments,\n\t\t\tcb = bind(this, function() {\n\t\t\t\tthis.unsubscribe(this, cb);\n\t\t\t\tif (args.length == 2) {\n\t\t\t\t\tctx.apply(GLOBAL, arguments);\n\t\t\t\t} else {\n\t\t\t\t\tbind.apply(GLOBAL, SLICE.call(args, 1))\n\t\t\t\t\t\t.apply(GLOBAL, arguments);\n\t\t\t\t}\n\t\t\t});\n\t\t\n\t\treturn this.subscribe(signal, cb);\n\t}\n\t\n\t// if no method is specified, all subscriptions with a callback context of ctx will be removed\n\tthis.unsubscribe = function(signal, ctx, method) {\n\t\tif (!this._subscribers || !this._subscribers[signal]) { return; }\n\t\tvar subs = this._subscribers[signal];\n\t\tfor (var i = 0, c; c = subs[i]; ++i) {\n\t\t\tif (c == ctx || c._ctx == ctx && (!method || c._method == method)) {\n\t\t\t\tsubs.splice(i--, 1);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n});\n\n");
jsio.setCachedSrc("../../packages/lib/Resource.js","exports = Class(function() {\n\tthis.init = function(opts) {\n\t\topts = opts || {};\n\t\t\n\t\tif (opts.key) {\n\t\t\tthis._key = opts.key;\n\t\t\tthis._keyed = {};\n\t\t}\n\t\t\n\t\tthis._creator = opts.creator || function() { return {}; };\n\t\tthis._count = 0;\n\t\tthis._limit = opts.limit || -1;\n\t\tthis._queue = [];\n\t}\n\t\n\tthis.create = function() {\n\t\tif (this._limit < 0 || this._count < this._limit) {\n\t\t\tvar item = this._creator();\n\t\t\tthis._queue.push(item);\n\t\t\tif (this._key) {\n\t\t\t\tthis._keyed[item[this._key]] = item;\n\t\t\t}\n\t\t\treturn item;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tthis.get = function(key) {\n\t\tif (key && this._keyed) {\n\t\t\treturn this._keyed[key];\n\t\t}\n\t\t\n\t\tif (!this._queue.length) {\n\t\t\tif (this.create() !== false) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn this._queue.unshift();\n\t}\n});\n");
jsio.setCachedSrc("../../packages/lib/Sortable.js","\njsio(\"import .LogClass;\");\n\nexports = LogClass('lib.Sortable', function(logger) {\n\t\n\tthis.toStringPush = function(indexer) {\n\t\tif (!this._toString || !this._toString.push) {\n\t\t\tthis._toString = [this.toString];\n\t\t} else {\n\t\t\tthis._toString.push(this.toString);\n\t\t}\n\t\t\n\t\tthis.toString = indexer;\n\t}\n\t\n\tthis.toStringPop = function() {\n\t\tthis.toString = this._toString.pop();\n\t}\n});\n\nvar zeroPadding = [];\nfunction ensurePadding(n) {\n\tfor (var i = zeroPadding.length; i < n; ++i) {\n\t\tvar str = [];\n\t\tfor (var j = 0; j < i; ++j) { str.push('0'); }\n\t\tzeroPadding[i] = str.join('');\n\t}\n}\n\n/**\n * Here we handle arbitrary sorting indexes transparently converting numbers to strings\n * for efficient sorting with toString.  Unfortunately, this does not work for large floating\n * point values, but that functionality could theoretically be added if desired.\n */\nfunction sortIndex(i) { return this[i]; }\n\nexports.sort = function(arr, indexer) {\n\t\n\tvar len = arr.length,\n\t\tindex = new Array(len),\n\t\tresult = new Array(len),\n\t\ttoString = new Array(len),\n\t\tindexers = Array.prototype.slice.call(arguments, 1),\n\t\thaveMultiple = !!indexers[1];\n\t\n\tif (haveMultiple) {\n\t\tfor (var i = 0; i < len; ++i) {\n\t\t\tresult[i] = [];\n\t\t}\n\t}\n\t\n\tfor (var k = 0, indexer; indexer = indexers[k]; ++k) {\n\t\tfor (var i = 0; i < len; ++i) {\n\t\t\tindex[i] = indexer.call(arr[i], i);\n\t\t}\n\t\t\n\t\tif (typeof index[0] == 'number') {\n\t\t\t// we do two passes here:\n\t\t\t//  1: find the max and min numerical indices\n\t\t\t//  2: convert the indices to strings with appropriate zero-padding\n\t\t\tvar largest = index[0],\n\t\t\t\tsmallest = index[0];\n\n\t\t\tfor (var i = 1; i < len; ++i) {\n\t\t\t\tif (index[i] > largest) {\n\t\t\t\t\tlargest = index[i];\n\t\t\t\t} else if (index[i] < smallest) {\n\t\t\t\t\tsmallest = index[i];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// we have to be very careful here - large floating point numbers will break the\n\t\t\t// string padding code\n\t\t\tvar paddingPositive = String(Math.floor(largest)).length,\n\t\t\t\tpaddingNegative = String(Math.floor(smallest)).length;\n\n\t\t\tensurePadding(Math.max(paddingPositive, paddingNegative));\n\n\t\t\tvar strLen;\n\t\t\tfor (var i = 0; i < len; ++i) {\n\t\t\t\tvar val = index[i];\n\t\t\t\tif (val < 0) {\n\t\t\t\t\tval = -(smallest - val);\n\t\t\t\t\tstrLen = ('' + Math.floor(val)).length;\n\t\t\t\t\tindex[i] = '-' + zeroPadding[paddingNegative - strLen] + val;\n\t\t\t\t} else {\n\t\t\t\t\tstrLen = ('' + Math.floor(val)).length;\n\t\t\t\t\tindex[i] = zeroPadding[paddingPositive - strLen] + val;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (haveMultiple) {\n\t\t\tfor (var i = 0; i < len; ++i) {\n\t\t\t\tresult[i].push(index[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tresult = index;\n\t\t}\n\t}\n\t\n\tfor (var i = 0; i < len; ++i) {\n\t\tif (haveMultiple) {\n\t\t\tresult[i] = result[i].join('|');\n\t\t}\n\t\t\n\t\ttoString[i] = arr[i].hasOwnProperty('toString') && arr[i].toString || null;\n\t\tarr[i].toString = bind(result, sortIndex, i);\n\t}\n\t\n\tArray.prototype.sort.apply(arr);\n\t\n\tfor (var i = 0; i < len; ++i) {\n\t\tif (toString[i]) {\n\t\t\tarr[i].toString = toString[i];\n\t\t} else {\n\t\t\tdelete arr[i].toString;\n\t\t}\n\t}\n}\n");
jsio.setCachedSrc("../../packages/math/arrays.js","jsio('import .util');\n\nexports.weightedAverage = function (a, w, n) {\n\tn = n || a.length;\n\tvar s = 0;\n\tfor (var i = n - 1; i >= 0; --i) {\n\t\ts += a[i] * w;\n\t}\n\treturn s / n;\n}\n\nexports.subtract = function(a, b) {\n\tvar length = a.length,\n\t\tdiff = new Array(length);\n\tfor (var i = 0; i < length; ++i) {\n\t\tdiff[i] = b[i] - a[i];\n\t}\n\treturn diff;\n}\n\nexports.average = function (a, n) {\n\tn = n || a.length;\n\tvar s = 0;\n\tfor (var i = n - 1; i >= 0; --i) {\n\t\ts += a[i];\n\t}\n\treturn s / n;\n}\n\nexports.stddev = function (a, n) {\n\tvar avg = exports.average(a, n);\n\tn = n || a.length;\n\tvar s = 0;\n\tfor (var i = n - 1; i >= 0; --i) {\n\t\tvar diff = (a[i] - avg);\n\t\ts += diff * diff;\n\t}\n\treturn Math.sqrt(sum / (1 - n));\n}\n\nexports.shuffle = function(a, randGen) {\n\tvar len = a.length;\n\tfor (var i = 0; i < len; ++i) {\n\t\tvar j = util.random(i, len, randGen),\n\t\t\ttemp = a[j];\n\t\ta[j] = a[i];\n\t\ta[i] = temp;\n\t}\n\treturn a;\n}\n\nexports.rotate = function(a, count) {\n\tvar len = a.length,\n\t\tb = new Array(len),\n\t\tj = count % len;\n\t\n\tif (j < 0) {\n\t\tj = j % len;\n\t\tif (j) { j += len; }\n\t}\n\t\n\tfor (var i = 0; i < len; ++i) {\n\t\tb[i] = a[j];\n\t\tj = (j + 1) % len;\n\t}\n\t\n\treturn b;\n}\n");
jsio.setCachedSrc("../../packages/math/util.js","jsio('import lib.Enum as Enum');\n\nexports.interpolate = function(a, b, x) { return a * (1 - x) + b * x; }\n\nexports.random = function(a, b, rand) { return a + ((rand || Math.random)() * (b - a) | 0); }\n\nexports.randomInclusive = function(a, b, rand) { return exports.random(a, b+1, rand); }\nexports.rand = Math.random;\n//FIXME integer is a reserved word XXX\nexports.integer = exports.truncate = function(a) { return a | 0; }\n\nexports.clip = function(num, min, max) { return Math.max(Math.min(num, max), min); }\n\nvar round = exports.round = function(a, precision, method) {\n\tif (!method || method == round.ROUND_HALF_AWAY_FROM_ZERO) {\n\t\treturn a.toFixed(precision);\n\t}\n\t\n\tif(!precision) {\n\t\tif (method == round.ROUND_HALF_UP) { Math.round(a); }\n\t\n\t\t//FIXME integer is a reserved word XXX\t\n\t\tvar integer = a | 0,\n\t\t\tfrac = a - integer \n\t\t\thalf = frac == 0.5 || frac == -0.5;\n\t\tif (!half) { return Math.round(a); }\n\t\t\n\t\tvar sign = a < 0 ? -1 : 1;\n\t\tswitch(method) {\n\t\t\tcase round.ROUND_HALF_TO_EVEN:\n\t\t\t\treturn integer % 2 ? integer + sign : integer \n\t\t\tcase round.ROUND_HALF_TO_ODD:\n\t\t\t\treturn integer % 2 ? integer : integer + sign;\n\t\t\tcase round.ROUND_HALF_STOCHASTIC:\n\t\t\t\treturn Math.random() < 0.5 ? integer + sign : integer \n\t\t\tcase round.ROUND_HALF_ALTERNATE:\n\t\t\t\treturn (round.alt = !round.alt) ? integer + sign : integer \n\t\t}\n\t}\n\t\n\tvar integer = a | 0,\n\t\tfrac = a - integer \n\t\tp = Math.pow(10, precision);\n\treturn (integer + round(frac * p, 0, method) / p).toFixed(precision);\n}\n\nround.alt = true;\n\nEnum.call(round, 'ROUND_HALF_UP', 'ROUND_HALF_AWAY_FROM_ZERO', 'ROUND_HALF_TO_EVEN', 'ROUND_HALF_STOCHASTIC', 'ROUND_HALF_ALTERNATE');\n");
jsio.setCachedSrc("../../packages/math2D/angle.js","var PI = Math.PI,\n\tTWOPI = Math.PI * 2;\n\nexports.average = function(a, b, weight) {\n\tif (weight === undefined) { weight = 0.5; }\n\tvar r1 = exports.getRange(a, b);\n\tvar avg = r1 < PI \n\t\t? a + r1 * (1 - weight)\n\t\t: b + (2 * PI - r1) * weight;\n\n\treturn avg > PI ? avg - 2 * PI : avg < -PI ? avg + 2 * PI : avg;\n}\n\n// between -PI and PI\nexports.normalize = function(a) {\n\t\n\t// TODO: don't use loops\n\twhile(a < -PI) { a += 2 * PI; }\n\twhile(a > PI) { a -= 2 * PI; }\n\treturn a;\n}\n\nexports.add = function(a, b) {\n\tvar sum = a + b;\n\treturn sum > PI ? sum - TWOPI : sum < -PI ? sum + TWOPI : sum;\n}\n\n// smaller of two angles a - b, b - a\nexports.difference = function(a, b) {\n\tvar diff = exports.getRange(a, b);\n\treturn diff > PI ? diff - TWOPI : diff;\n}\n\n// angular range from a to b, returns float between [0, 2PI]\nexports.getRange = function(a, b) {\n\tvar r = b - a;\n\treturn r < 0 ? r + TWOPI : r;\n}\n");
jsio.setCachedSrc("../../packages/math2D/Circle.js","\njsio(\"import .Point;\");\n\nexports = Class(Point, function(supr) {\n\tthis.init = function(a, b, c) {\n\t\tswitch(arguments.length) {\n\t\t\tcase 0:\n\t\t\t\tthis.x = 0;\n\t\t\t\tthis.y = 0;\n\t\t\t\tthis.radius = 0;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\tcase 2:\n\t\t\t\tthis.x = a.x || 0;\n\t\t\t\tthis.y = a.y || 0;\n\t\t\t\tthis.radius = a.radius || 0;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tthis.x = a;\n\t\t\t\tthis.y = b;\n\t\t\t\tthis.radius = c;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tthis.scale = function(s) {\n\t\tsupr(this, 'scale', arguments);\n\t\tthis.radius *= s;\n\t\treturn this;\n\t}\n});");
jsio.setCachedSrc("../../packages/math2D/Point.js","var Point = exports = Class(function() {\n\tthis.init = function(a, b) {\n\t\tswitch(arguments.length) {\n\t\t\tcase 0:\n\t\t\t\tthis.x = 0;\n\t\t\t\tthis.y = 0;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tthis.x = a.x || 0;\n\t\t\t\tthis.y = a.y || 0;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tthis.x = a || 0;\n\t\t\t\tthis.y = b || 0;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tthis.rotate = function(r) {\n\t\tvar x = this.x,\n\t\t\ty = this.y,\n\t\t\tcosr = Math.cos(r),\n\t\t\tsinr = Math.sin(r);\n\t\t\n\t\tthis.x = x * cosr - y * sinr;\n\t\tthis.y = x * sinr + y * cosr;\n\t\t\n\t\treturn this;\n\t}\n\t\n\tthis.translate = \n\tthis.add = function(x, y) {\n\t\tif (typeof x == 'number') {\n\t\t\tthis.x += x;\n\t\t\tthis.y += y;\n\t\t} else {\n\t\t\tthis.x += x.x;\n\t\t\tthis.y += x.y;\n\t\t}\n\t\treturn this;\n\t}\n\t\n\tthis.subtract = function(x, y) {\n\t\tif (typeof x == 'number') {\n\t\t\tthis.x -= x;\n\t\t\tthis.y -= y;\n\t\t} else {\n\t\t\tthis.x -= x.x;\n\t\t\tthis.y -= x.y;\n\t\t}\n\t\treturn this;\n\t}\n\n\tthis.scale = function(s) {\n\t\tthis.x *= s;\n\t\tthis.y *= s;\n\t\treturn this;\n\t}\n\t\n\tthis.setMagnitude = function(m) {\n\t\tvar theta = Math.atan2(this.y, this.x);\n\t\tthis.x = m * Math.cos(theta);\n\t\tthis.y = m * Math.sin(theta);\n\t\treturn this;\n\t}\n\t\n\tthis.normalize = function() {\n\t\tvar m = this.getMagnitude();\n\t\tthis.x /= m;\n\t\tthis.y /= m;\n\t\treturn this;\n\t}\n\t\n\tthis.addMagnitude = function(m) { return this.setMagnitude(this.getMagnitude() + m); }\n\tthis.getMagnitude = function() { return Math.sqrt(this.x * this.x + this.y * this.y); }\n\tthis.getSquaredMagnitude = function() { return this.x * this.x + this.y * this.y; }\n\tthis.getDirection =\n\tthis.getAngle = function() { return Math.atan2(this.y, this.x); }\n\t\n});\n\nPoint.getPolarR = function(x, y) { \n\tthrow \"notImplemented\";\n}\n\nPoint.getPolarTheta = function(x, y) { \n\tvar val = Math.atan2(y,x) + (Math.PI * 2); \n\treturn val > Math.PI * 2 ? val % (Math.PI * 2) : val;\n}\n\nPoint.add = Point.translate = function(a, b, c, d) {\n\tswitch(arguments.length) {\n\t\tcase 2: return new Point(a).add(b);\n\t\tcase 3: return new Point(a).add(b, c);\n\t\tcase 4: return new Point(a, b).add(c, d);\n\t}\n}\n\nPoint.subtract = function(a, b, c, d) {\n\tswitch(arguments.length) {\n\t\tcase 2: return new Point(a).subtract(b);\n\t\tcase 3: return new Point(a).subtract(b, c);\n\t\tcase 4: return new Point(a, b).subtract(c, d);\n\t}\n}\n\nPoint.scale = function(a, b, c) {\n\tswitch(arguments.length) {\n\t\tcase 2: return new Point(a).scale(b);\n\t\tcase 3: return new Point(a, b).scale(c);\n\t}\n}\n\nPoint.setMagnitude = function(a, b, c) {\n\tswitch(arguments.length) {\n\t\tcase 2: return new Point(a).setMagnitude(c);\n\t\tcase 3: return new Point(a, b).setMagnitude(c);\n\t}\n}\n\nPoint.addMagnitude = function(a, b, c) {\n\tswitch(arguments.length) {\n\t\tcase 2: pt = new Point(a); break;\n\t\tcase 3: pt = new Point(a, b); b = c; break;\n\t}\n\t\n\treturn pt.addMagnitude(b);\n}\n\nPoint.getMagnitude = function(a, b) { return new Point(a, b).getMagnitude(); }\n\nPoint.rotate = function(a, b, c) {\n\tswitch(arguments.length) {\n\t\tcase 2: return new Point(a).rotate(b);\n\t\tcase 3: return new Point(a, b).rotate(c);\n\t}\n}\n");
jsio.setCachedSrc("../../packages/math2D/intersect.js",'\njsio("import .Point;");\njsio("import .Line;");\njsio("import .Rect;");\n\nvar intersect = exports;\n\nintersect.rectAndPt = function(rect, pt) { return intersect.ptAndRect(pt, rect); }\nintersect.ptAndRect = function(pt, rect) {\n\tvar x = pt.x,\n\t\ty = pt.y;\n\t\n\treturn x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;\n}\n\nintersect.circAndPt = function(circ, pt) { return intersect.ptAndCirc(pt, circ); }\nintersect.ptAndCirc = function(pt, circ) {\n\tvar dx = pt.x - circ.x,\n\t\tdy = pt.y - circ.y;\n\treturn dx * dx + dy * dy < circ.radius * circ.radius;\n}\n\nintersect.rectAndRect = function(rect1, rect2) {\n\treturn !(\n\t\t   (rect1.y + rect1.height < rect2.y)\n\t\t|| (rect2.y + rect2.height < rect1.y)\n\t\t|| (rect1.x + rect1.width < rect2.x)\n\t\t|| (rect2.x + rect2.width < rect1.x)\n\t);\n}\n\nvar SIDES = Rect.SIDES;\n\nintersect.rectAndCircle = function(rect, circle) { return intersect.rectAndCircle(circle, circ); }\nintersect.circleAndRect = function(circle, rect) {\n\tif (intersect.ptAndRect(circle, rect)) {\n\t\treturn true;\n\t}\n\t\n\treturn intersect.lineAndCircle(rect.getSide(1), circle)\n\t\t|| intersect.lineAndCircle(rect.getSide(2), circle)\n\t\t|| intersect.lineAndCircle(rect.getSide(3), circle)\n\t\t|| intersect.lineAndCircle(rect.getSide(4), circle);\n}\n\nintersect.circleAndLine = function(circle, line) { return intersect.lineAndCircle(line, circle); }\nintersect.lineAndCircle = function(line, circle) {\n\tvar vec = intersect.util.ptToLine(circle, line);\n\treturn vec.getMagnitude() < circle.radius;\n}\n\n// util -- does not return a true/false intersection\n\nintersect.util = {};\n\n// returns line from pt to nearest pt on line\nintersect.util.ptToLine = function(pt, line) {\n\tvar dx = (line.end.x - line.start.x),\n\t\tdy = (line.end.y - line.start.y),\n\t\tu = ((pt.x - line.start.x) * dx\t// TODO can we abstract this from 2D to 2D/3D?\n\t\t\t+ (pt.y - line.start.y) * dy) / \n\t\t\t  (dx * dx + dy * dy);\n\n\tvar i;\n\tif (u < 0) {\n\t\ti = new Point(line.start);\n\t} else if (u > 1) {\n\t\ti = new Point(line.end);\n\t} else {\n\t\ti = new Point(line.start.x + u * dx, line.start.y + u * dy);\n\t}\n\treturn new Line(i, pt);\n}\n\n// returns rectangle of intersection\nintersect.util.rectAndRect = function(rect1, rect2) {\n\tif (intersect.rectAndRect(rect1, rect2)) {\n\t\tvar x1 = Math.max(rect1.x, rect2.x),\n\t\t\ty1 = Math.max(rect1.y, rect2.y),\n\t\t\tx2 = Math.min(rect1.x + rect1.width, rect2.x + rect2.width),\n\t\t\ty2 = Math.min(rect1.y + rect1.height, rect2.y + rect2.height);\n\t\treturn new Rect(x1, y1, x2 - x1, y2 - y1);\n\t}\n\treturn null;\n}\n');
jsio.setCachedSrc("../../packages/math2D/Line.js",'\njsio("import .Point;");\n\nexports = Class(function() {\n\tthis.init = function(a, b, c, d) {\n\t\tswitch(arguments.length) {\n\t\t\tcase 0:\n\t\t\t\tthis.start = new Point();\n\t\t\t\tthis.end = new Point();\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tthis.start = new Point(a.start);\n\t\t\t\tthis.end = new Point(a.end);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tthis.start = new Point(a);\n\t\t\t\tthis.end = new Point(b);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tthis.start = new Point(a);\n\t\t\t\tthis.end = new Point(b, c);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\tdefault:\n\t\t\t\tthis.start = new Point(a, b);\n\t\t\t\tthis.end = new Point(c, d);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tthis.getMagnitude = \n\tthis.getLength = function() {\n\t\tvar dx = this.end.x - this.start.x,\n\t\t\tdy = this.end.y - this.start.y;\n\t\t\n\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t}\n});\n');
jsio.setCachedSrc("../../packages/math2D/Rect.js","\njsio(\"import lib.Enum;\");\njsio(\"import .Point;\");\njsio(\"import .Line;\");\n\nvar Rect = exports = Class(function() {\n\tthis.init = function(a, b, c, d) {\n\t\tswitch(arguments.length) {\n\t\t\tcase 0: // init\n\t\t\t\tthis.width = this.height = this.x = this.y = 0;\n\t\t\t\tbreak;\n\t\t\tcase 1: // copy\n\t\t\t\tthis.width = a.width;\n\t\t\t\tthis.height = a.height;\n\t\t\t\tthis.x = a.x;\n\t\t\t\tthis.y = a.y;\n\t\t\t\tbreak;\n\t\t\tcase 2: // (x, y), (width, height)\n\t\t\t\tthis.x = a.x;\n\t\t\t\tthis.y = a.y;\n\t\t\t\tthis.width = b.x;\n\t\t\t\tthis.height = b.y;\n\t\t\t\tbreak;\n\t\t\tcase 3: // (x, y), width, height\n\t\t\t\tthis.x = a.x;\n\t\t\t\tthis.y = a.y;\n\t\t\t\tthis.width = b;\n\t\t\t\tthis.height = c;\n\t\t\t\tbreak;\n\t\t\tcase 4: // x, y, width, height\n\t\t\t\tthis.x = a;\n\t\t\t\tthis.y = b;\n\t\t\t\tthis.width = c;\n\t\t\t\tthis.height = d;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tthis.normalize = function() {\n\t\tif (this.width < 0) {\n\t\t\tthis.x -= this.width;\n\t\t\tthis.width = -this.width;\n\t\t}\n\t\t\n\t\tif (this.height < 0) {\n\t\t\tthis.y -= this.height;\n\t\t\tthis.height = -this.height;\n\t\t}\n\t\treturn this;\n\t}\n\t\n\tthis.unionRect = function(rect) {\n\t\tthis.normalize();\n\t\tif (rect.normalize) { rect.normalize(); }\n\t\t\n\t\tvar x2 = this.x + this.width,\n\t\t\ty2 = this.y + this.height;\n\t\t\n\t\tvar rx2 = rect.x + rect.width,\n\t\t\try2 = rect.y + rect.height;\n\t\t\n\t\tthis.x = this.x < rect.x ? this.x : rect.x;\n\t\tthis.y = this.y < rect.y ? this.y : rect.y;\n\t\t\n\t\tthis.width = (x2 > rx2 ? x2 : rx2) - this.x;\n\t\tthis.height = (y2 > ry2 ? y2 : ry2) - this.y;\n\t}\n\t\n\tthis.getCorner = function(i) {\n\t\tswitch(i) {\n\t\t\tcase CORNERS.TOP_LEFT:\n\t\t\t\treturn new Point(this.x, this.y);\n\t\t\tcase CORNERS.TOP_RIGHT:\n\t\t\t\treturn new Point(this.x + this.width, this.y);\n\t\t\tcase CORNERS.BOTTOM_LEFT:\n\t\t\t\treturn new Point(this.x, this.y + this.height);\n\t\t\tcase CORNERS.BOTTOM_RIGHT:\n\t\t\t\treturn new Point(this.x + this.width, this.y + this.height);\n\t\t}\n\t}\n\t\n\tthis.getSide = function(i) {\n\t\tswitch(i) {\n\t\t\tcase SIDES.TOP:\n\t\t\t\treturn new Line(this.getCorner(CORNERS.TOP_LEFT), this.getCorner(CORNERS.TOP_RIGHT));\n\t\t\tcase SIDES.RIGHT:\n\t\t\t\treturn new Line(this.getCorner(CORNERS.TOP_RIGHT), this.getCorner(CORNERS.BOTTOM_RIGHT));\n\t\t\tcase SIDES.BOTTOM:\n\t\t\t\treturn new Line(this.getCorner(CORNERS.BOTTOM_RIGHT), this.getCorner(CORNERS.BOTTOM_LEFT));\n\t\t\tcase SIDES.LEFT:\n\t\t\t\treturn new Line(this.getCorner(CORNERS.BOTTOM_LEFT), this.getCorner(CORNERS.TOP_LEFT));\n\t\t}\n\t}\n\t\n\tthis.getCenter = function() {\n\t\treturn new Point(this.x + this.width / 2, this.y + this.height / 2);\n\t}\n});\n\nvar SIDES = Rect.SIDES = lib.Enum('TOP', 'BOTTOM', 'LEFT', 'RIGHT'),\n\tCORNERS = Rect.CORNERS = lib.Enum('TOP_LEFT', 'TOP_RIGHT', 'BOTTOM_RIGHT', 'BOTTOM_LEFT');\n");
jsio.setCachedSrc("../../packages/math2D/morphology.js","\n\nexports.open = function(img, mask) {\n\treturn exports.dilate(exports.erode(img, mask), mask);\n}\n\nexports.close = function(img, mask) {\n\treturn exports.erode(exports.dilate(img, mask), mask);\n}\n\nexports.getSquareMask = function(d) {\n\tif (d % 2 == 0) { d++; }\n\tvar mask = [];\n\tfor (var x = 0; x < d; ++x) {\n\t\tmask[x] = [];\n\t\tfor (var y = 0; y < d; ++y) {\n\t\t\tmask[x][y] = 1;\n\t\t}\n\t}\n\treturn mask;\n}\n\nexports.getCircleMask = function(d) {\n\tif (d % 2 == 0) { d++; }\n\tvar mask = [],\n\t\tr = d / 2 - 0.5,\n\t\tc = r;\n\tfor (var y = 0; y < d; ++y) {\n\t\tmask[y] = [];\n\t\tfor (var x = 0; x < d; ++x) {\n\t\t\tvar dx = x - c, dy = y - c;\n\t\t\tmask[y][x] = Math.sqrt(dx * dx + dy * dy) <= r ? 1 : 0;\n\t\t}\n\t}\n\treturn mask;\n}\n\nexports.multiply = function(img1, c) {\n\tvar w = img1.width, h = img1.height;\n\tfor (var y = 0; y < h; ++y) {\n\t\tfor (var x = 0; x < w; ++x) {\n\t\t\timg1[y][x] *= c;\n\t\t}\n\t}\n\treturn img1;\n}\n\nexports.subtract = function(img1, img2) {\n\tvar w = Math.min(img1.width, img2.width),\n\t\th = Math.min(img1.height, img2.height);\n\t\t\n\tfor (var y = 0; y < h; ++y) {\n\t\tfor (var x = 0; x < w; ++x) {\n\t\t\timg1[y][x] -= img2[y][x];\n\t\t}\n\t}\n\treturn img1;\n}\n\nexports.erode = function(img, mask) {\n\tlogger.info('erode');\n\t\n\tvar lmx = (mask.length - 1) / 2,\n\t\tlmy = (mask[0].length - 1) / 2,\n\t\tout = [],\n\t\tw = img.width,\n\t\th = img.height;\n\t\n\tout.width = w;\n\tout.height = h;\n\t\n\tfor (var y = 0; y < h; ++y) {\n\t\tout[y] = [];\n\t\tfor (var x = 0; x < w; ++x) {\n\t\t\tvar count = true;\n\t\t\tfor (var mx = -lmx; mx < lmx + 1; ++mx) {\n\t\t\t\tfor (var my = -lmy; my < lmy + 1; ++my) {\n\t\t\t\t\tvar sx = x + mx, sy = y + my;\n\t\t\t\t\tmask[my + lmy][mx + lmx]\n\t\t\t\t\t\t&& (count &= sx >= 0 && sx < w && sy >= 0 && sy < h && img[sy][sx]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tout[y][x] = count && 255;\n\t\t}\n\t}\n\treturn out;\n}\n\nexports.dilate = function (img, mask) {\n\tlogger.info('dilate');\n\t\n\tvar lmx = (mask.length - 1) / 2,\n\t\tlmy = (mask[0].length - 1) / 2,\n\t\tout = [],\n\t\tw = img.width,\n\t\th = img.height;\n\t\n\tout.width = w;\n\tout.height = h;\n\t\n\tfor (var y = 0; y < h; ++y) {\n\t\tout[y] = [];\n\t\tfor (var x = 0; x < w; ++x) {\n\t\t\tvar count = false;\n\t\t\tfor (var mx = -lmx; mx < lmx + 1; ++mx) {\n\t\t\t\tfor (var my = -lmy; my < lmy + 1; ++my) {\n\t\t\t\t\tvar sx = x + mx, sy = y + my;\n\t\t\t\t\tcount |= sx >= 0 && sx < w && sy >= 0 && sy < h\n\t\t\t\t\t\t&& mask[my + lmy][mx + lmx] && img[sy][sx];\n\t\t\t\t}\n\t\t\t}\n\t\t\tout[y][x] = count && 255;\n\t\t}\n\t}\n\treturn out;\n}\n");
jsio.setCachedSrc("../../packages/math2D/Vec2D.js","var Vec2D = exports = Class(function() {\n\tthis.init = function(opts) {\n\t\tif ('angle' in opts) {\n\t\t\tthis.x = opts.magnitude * Math.cos(opts.angle);\n\t\t\tthis.y = opts.magnitude * Math.sin(opts.angle);\n\t\t} else {\n\t\t\tthis.x = opts.x;\n\t\t\tthis.y = opts.y;\n\t\t}\n\t}\n\t\n\tthis.addForce = function(f) { this.x += f.x; this.y += f.y; }\n\tthis.getAngle = function() { return Math.atan2(this.y, this.x); }\n\tthis.getMagnitude = function() { return Math.sqrt(this.x * this.x + this.y * this.y); }\n\tthis.getUnitVector = function() {\n\t\tvar angle = this.getAngle();\n\t\treturn new Vec2D({\n\t\t\t\t\t\tmagnitude:1,\n\t\t\t\t\t\tangle: angle});}\n\t\t\t\t\t\t\n\tthis.dot = function(vec) {\n\t\treturn (this.x * vec.x) + (this.y * vec.y);\n\t}\n\n\tthis.add = function(vec) {\n\t\treturn new Vec2D({x:this.x + vec.x, y:this.y+vec.y});\n\t}\n\t\n\tthis.minus = function(vec) {\n\t\treturn new Vec2D({x:this.x-vec.x, y:this.y-vec.y});\n\t}\n\t\n\tthis.negate = function() {\n\t\treturn new Vec2D({x:-this.x, y:-this.y});\n\t}\n\t\n\tthis.multiply = function(scalar) {\n\t\treturn new Vec2D({angle:this.getAngle(), magnitude:this.getMagnitude()*scalar});\n\t}\n\n});\n\n");
jsio.setCachedSrc("../../packages/net/csp/client.js","jsio('import std.base64 as base64');\njsio('import std.utf8 as utf8');\njsio('import std.uri as uri'); \njsio('import net.errors as errors');\njsio('import .transports');\njsio('import lib.Enum as Enum');\n\nvar READYSTATE = exports.READYSTATE = Enum({\n\tINITIAL: 0,\n\tCONNECTING: 1,\n\tCONNECTED: 2,\n\tDISCONNECTING: 3,\n\tDISCONNECTED:  4\n});\n\n\nexports.CometSession = Class(function(supr) {\n\tvar id = 0;\n\tvar kDefaultBackoff = 50;\n\tvar kDefaultTimeoutInterval = 45000;\n\tvar kDefaultHandshakeTimeout = 10000;\n\tthis.init = function() {\n\t\tthis._id = ++id;\n\t\tthis._url = null;\n\t\tthis.readyState = READYSTATE.INITIAL;\n\t\tthis._sessionKey = null;\n\t\tthis._transport = null;\n\t\tthis._options = null;\n\t\t\n\t\tthis._utf8ReadBuffer = \"\";\n\t\tthis._writeBuffer = \"\";\n\t\t\n\t\tthis._packetsInFlight = null;\n\t\tthis._lastEventId = null;\n\t\tthis._lastSentId = null;\n\t\t\n\t\tthis._handshakeLater = null;\n\t\tthis._handshakeBackoff = kDefaultBackoff;\n\t\tthis._handshakeRetryTimer = null;\n\t\tthis._handshakeTimeoutTimer = null;\n\n\t\tthis._timeoutTimer = null;\n\n\t\t\n\t\tthis._writeBackoff = kDefaultBackoff;\n\t\tthis._cometBackoff = kDefaultBackoff;\n\t\t\n\t\tthis._nullInBuffer = false;\n\t\tthis._nullInFlight= false;\n\t\tthis._nullSent = false;\n\t\tthis._nullReceived = false;\n\t}\n\t\n\t\n\tthis.setEncoding = function(encoding) {\n\t\tif (encoding == this._options.encoding) { \n\t\t\treturn; \n\t\t}\n\t\tif (encoding != 'utf8' && encoding != 'plain') {\n\t\t\tthrow new errors.InvalidEncodingError();\n\t\t}\n\t\tif (encoding == 'plain' && this._buffer) {\n\t\t\tvar buffer = this._utf8ReadBuffer;\n\t\t\tthis._utf8ReadBuffer = \"\";\n\t\t\tthis._doOnRead(buffer);\n\t\t}\n\t\tthis._options.encoding = encoding;\n\t}\n\n\n\tthis.connect = function(url, options) {\n\t\tthis._url = url.replace(/\\/$/,'');\n\t\tthis._options = options || {};\n\t\t\n\t\tthis._options.encoding = this._options.encoding || 'utf8';\n\t\tthis.setEncoding(this._options.encoding); // enforce encoding constraints\n\t\t\n\t\tthis._options.connectTimeout = this._options.connectTimeout || kDefaultHandshakeTimeout;\n\t\t\n\t\tvar transportClass = transports.chooseTransport(url, this._options);\n\t\tthis._transport = new transportClass();\n\t\t\n\t\tthis._transport.handshakeFailure = bind(this, this._handshakeFailure);\n\t\tthis._transport.handshakeSuccess = bind(this, this._handshakeSuccess);\n\t\t\n\t\tthis._transport.cometFailure = bind(this, this._cometFailure);\n\t\tthis._transport.cometSuccess = bind(this, this._cometSuccess);\n\t\t\n\t\tthis._transport.sendFailure = bind(this, this._writeFailure);\n\t\tthis._transport.sendSuccess = bind(this, this._writeSuccess);\n\t\tthis.readyState = READYSTATE.CONNECTING;\n\t\tthis._transport.handshake(this._url, this._options);\n\t\t\n\t\tthis._handshakeTimeoutTimer = setTimeout(bind(this, this._handshakeTimeout), \n\t\t\tthis._options.connectTimeout);\n\t}\n\n\tthis.write = function(data, encoding) {\n\t\tif (this.readyState != READYSTATE.CONNECTED) {\n\t\t\tthrow new errors.ReadyStateError();\n\t\t}\n\t\tencoding = encoding || this._options.encoding || 'utf8';\n\t\tif (encoding == 'utf8') {\n\t\t\tdata = utf8.encode(data);\n\t\t}\n\t\tthis._writeBuffer += data;\n\t\tthis._doWrite();\n\t}\n\t\n\t// Close due to protocol error\n\tthis._protocolError = function(msg) {\n\t\tlogger.debug('_protocolError', msg);\n\t\t// Immediately fire the onclose\n\t\t// send a null packet to the server\n\t\t// don't wait for a null packet back.\n\t\tthis.readyState = READYSTATE.DISCONNECTED;\n\t\tthis._doWrite(true);\n\t\tthis._doOnDisconnect(new errors.ServerProtocolError(msg));\n\t}\n\t\n\tthis._receivedNullPacket = function() {\n\t\tlogger.debug('_receivedNullPacket');\n\t\t// send a null packet back to the server\n\t\tthis._receivedNull = true;\n\t\t\n\t\t// send our own null packet back. (maybe)\n\t\tif (!(this._nullInFlight || this._nullInBuffer || this._nullSent)) {\n\t\t\tthis.readyState = READYSTATE.DISCONNECTING;\n\t\t\tthis._doWrite(true);\n\t\t}\n\t\telse {\n\t\t\tthis.readyState = READYSTATE.DISCONNECTED;\n\t\t}\n\t\t\n\t\t// fire an onclose\n\t\tthis._doOnDisconnect(new errors.ConnectionClosedCleanly());\n\n\t}\n\t\n\tthis._sentNullPacket = function() {\n\t\tlogger.debug('_sentNullPacket');\n\t\tthis._nullSent = true;\n\t\tif (this._nullSent && this._nullReceived) {\n\t\t\tthis.readyState = READYSTATE.DISCONNECTED;\n\t\t}\n\t}\n\t\n\t\n\t// User Calls close\n\tthis.close = function(err) {\n\t\tlogger.debug('close called', err, 'readyState', this.readyState);\n\n\t\t// \n\t\tswitch(this.readyState) {\n\t\t\tcase READYSTATE.CONNECTING:\n\t\t\t\tclearTimeout(this._handshakeRetryTimer);\n\t\t\t\tclearTimeout(this._handshakeTimeoutTimer);\n\t\t\t\tthis.readyState = READYSTATE.DISCONNECTED;\n\t\t\t\tthis._doOnDisconnect(err);\n\t\t\t\tbreak;\n\t\t\tcase READYSTATE.CONNECTED:\n\t\t\t\tthis.readyState = READYSTATE.DISCONNECTING;\n\t\t\t\tthis._doWrite(true);\n\t\t\t\tclearTimeout(this._timeoutTimer);\n\t\t\t\tbreak;\n\t\t\tcase READYSTATE.DISCONNECTED:\n\t\t\t\tthrow new errors.ReadyStateError(\"Session is already disconnected\");\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\tthis._sessionKey = null;\n\t\tthis._opened = false; // what is this used for???\n\t\tthis.readyState = READYSTATE.DISCONNECTED;\n\t\t\n\t\tthis._doOnDisconnect(err);\n\t}\n\t\n\tthis._handshakeTimeout = function() {\n\t\tlogger.debug('handshake timeout');\n\t\tthis._handshakeTimeoutTimer = null;\n\t\tclearTimeout(this._handshakeRetryTimer);\n\t\tif (this.readyState == READYSTATE.CONNECTING) {\n\t\t\tthis.readyState = READYSTATE.DISCONNECTED;\n\t\t}\n\t\t\n\t\tthis._doOnDisconnect(new errors.ServerUnreachable());\n\t}\n\t\n\tthis._handshakeSuccess = function(data) {\n\t\tlogger.debug('handshake success', data);\n\t\tif (this.readyState != READYSTATE.CONNECTING) { \n\t\t\tlogger.debug('received handshake success in invalid readyState:', this.readyState);\n\t\t\treturn; \n\t\t}\n\t\tclearTimeout(this._handshakeTimeoutTimer);\n\t\tthis._handshakeTimeoutTimer = null;\n\t\tthis._sessionKey = data.response.session;\n\t\tthis._opened = true;\n\t\tthis.readyState = READYSTATE.CONNECTED;\n\t\tthis._doOnConnect();\n\t\tthis._doConnectComet();\n\t}\n\t\n\tthis._handshakeFailure = function(data) {\n\t\tlogger.debug('handshake failure', data);\n\t\tif (this.readyState != READYSTATE.CONNECTING) { return; }\n\t\tif (data.status == 404) {\n\t\t\tclearTimeout(this._handshakeTimeoutTimer);\n\t\t\treturn this._doOnDisconnect(new errors.ServerUnreachable());\n\t\t}\n\t\t\n\t\tlogger.debug('trying again in ', this._handshakeBackoff);\n\t\tthis._handshakeRetryTimer = setTimeout(bind(this, function() {\n\t\t\tthis._handshakeRetryTimer = null;\n\t\t\tthis._transport.handshake(this._url, this._options);\n\t\t}), this._handshakeBackoff);\n\t\t\n\t\tthis._handshakeBackoff *= 2;\n\t}\n\t\n\tthis._writeSuccess = function() {\n\t\tif (this.readyState != READYSTATE.CONNECTED && this.readyState != READYSTATE.DISCONNECTING) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._nullInFlight) {\n\t\t\treturn this._sentNullPacket();\n\t\t}\n\t\tthis._resetTimeoutTimer();\n\t\tthis.writeBackoff = kDefaultBackoff;\n\t\tthis._packetsInFlight = null;\n\t\tif (this._writeBuffer || this._nullInBuffer) {\n\t\t\tthis._doWrite(this._nullInBuffer);\n\t\t}\n\t}\n\t\n\tthis._writeFailure = function(data) {\n\t\t// Some transports can return error messages on failure. We can handle session not found.\n\t\tif (data && data.status == 404 && data.response == 'Session not found') {\n\t\t\treturn this.close(new errors.ExpiredSession(data));\n\t\t}\n\t\t\n\t\tif (this.readyState != READYSTATE.CONNECTED && this.READYSTATE != READYSTATE.DISCONNECTING) { return; }\n\t\tthis._writeTimer = setTimeout(bind(this, function() {\n\t\t\tthis._writeTimer = null;\n\t\t\tthis.__doWrite(this._nullInBuffer);\n\t\t}), this._writeBackoff);\n\t\tthis._writeBackoff *= 2;\n\t}\t\n\n\tthis._doWrite = function(sendNull) {\n\t\tif (this._packetsInFlight) {\n\t\t\tif (sendNull) {\n\t\t\t\tthis._nullInBuffer = true;\n\t\t\t\treturn; \n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tthis.__doWrite(sendNull);\n\t}\n\t\n\tthis.__doWrite = function(sendNull) {\n\t\tlogger.debug('_writeBuffer:', this._writeBuffer);\n\t\tif (!this._packetsInFlight && this._writeBuffer) {\n\t\t\tthis._packetsInFlight = [this._transport.encodePacket(++this._lastSentId, this._writeBuffer, this._options)];\n\t\t\tthis._writeBuffer = \"\";\n\t\t}\n\t\tif (sendNull && !this._writeBuffer) {\n\t\t\tif (!this._packetsInFlight) {\n\t\t\t\tthis._packetsInFlight = [];\n\t\t\t}\n\t\t\tthis._packetsInFlight.push([++this._lastSentId, 0, null]);\n\t\t\tthis._nullInFlight = true;\n\t\t}\n\t\tif (!this._packetsInFlight) {\n\t\t\tlogger.debug(\"no packets to send\");\n\t\t\treturn;\n\t\t}\n\t\tlogger.debug('sending packets:', JSON.stringify(this._packetsInFlight));\n\t\tthis._transport.send(this._url, this._sessionKey, this._lastEventId || 0, JSON.stringify(this._packetsInFlight), this._options);\n\t}\n\t\n\tthis._doConnectComet = function() {\n\t\tlogger.debug('_doConnectComet');\n//\t\treturn;\n\t\tthis._transport.comet(this._url, this._sessionKey, this._lastEventId || 0, this._options);\n\t}\n\n\tthis._cometFailure = function(data) {\n\t\tif (this.readyState != READYSTATE.CONNECTED) { return; }\n\t\tif (data.status == 404 && data.response == 'Session not found') {\n\t\t\treturn this.close(new errors.ExpiredSession(data));\n\t\t}\n\t\t\n\t\tthis._cometTimer = setTimeout(bind(this, '_doConnectComet'), this._cometBackoff);\n\t\tthis._cometBackoff *= 2;\n\t}\n\t\n\tthis._cometSuccess = function(data) {\n\t\tif (this.readyState != READYSTATE.CONNECTED && this.readyState != READYSTATE.DISCONNECTING) { return; }\n\t\tlogger.debug('comet Success:', data);\n\t\tthis._cometBackoff = kDefaultBackoff;\n\t\tthis._resetTimeoutTimer();\n\t\t\n\t\tvar response = data.response;\n\t\tfor (var i = 0, packet; (packet = response[i]) || i < response.length; i++) {\n\t\t\tlogger.debug('process packet:', packet);\n\t\t\tif (packet === null) {\n\t\t\t\treturn this.close(new errors.ServerProtocolError(data));\n\t\t\t}\n\t\t\tlogger.debug('process packet', packet);\n\t\t\tvar ackId = packet[0];\n\t\t\tvar encoding = packet[1];\n\t\t\tvar data = packet[2];\n\t\t\tif (typeof(this._lastEventId) == 'number' && ackId <= this._lastEventId) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (typeof(this._lastEventId) == 'number' && ackId != this._lastEventId+1) {\n\t\t\t\treturn this._protocolError(\"Ack id too high\");\n\t\t\t}\n\t\t\tthis._lastEventId = ackId;\n\t\t\tif (data == null) {\n\t\t\t\treturn this._receivedNullPacket();\n\t\t\t}\n\t\t\tif (encoding == 1) { // base64 encoding\n\t\t\t\ttry {\n\t\t\t\t\tlogger.debug('before base64 decode:', data);\n\t\t\t\t\tdata = base64.decode(data);\n\t\t\t\t\tlogger.debug('after base64 decode:', data);\n\t\t\t\t} catch(e) {\n\t\t\t\t\treturn this._protocolError(\"Unable to decode base64 payload\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this._options.encoding == 'utf8') {\n\t\t\t\t// TODO: need an incremental utf8 decoder for this stuff.\n\t\t\t\tthis._utf8ReadBuffer += data;\n\t\t\t\tlogger.debug('before utf8 decode, _utf8ReadBuffer:', this._utf8ReadBuffer);\n\t\t\t\tvar result = utf8.decode(this._utf8ReadBuffer);\n\t\t\t\tdata = result[0];\n\t\t\t\tthis._utf8ReadBuffer = this._utf8ReadBuffer.slice(result[1]);\n\t\t\t\tlogger.debug('after utf8 decode, _utf8ReadBuffer:', this._utf8ReadBuffer, 'data:', data );\n\t\t\t}\n\t\t\tlogger.debug('dispatching data:', data);\n\n\t\t\t// TODO: possibly catch this error in production? but not in dev\n\t\t\tthis._doOnRead(data);\n\t\t}\n\t\t\n\t\tif (this.readyState != READYSTATE.CONNECTED && this.readyState != READYSTATE.DISCONNECTING) { return; }\n\t\t\n\t\t// reconnect comet last, after we process all of the packet ids\n\t\tthis._doConnectComet();\n\t\t\n\t}\n\n\tthis._doOnRead = function(data) {\n\t\tif (typeof(this.onread) == 'function') {\n\t\t\tlogger.debug('call onread function', data);\n\t\t\tthis.onread(data);\n\t\t}\n\t\telse {\n\t\t\tlogger.debug('skipping onread callback (function missing)');\n\t\t}\n\t}\n\t\n\tthis._doOnDisconnect = function(err) {\n\t\tif (typeof(this.ondisconnect) == 'function') {\n\t\t\tlogger.debug('call ondisconnect function', err);\n\t\t\tthis.ondisconnect(err);\n\t\t}\n\t\telse {\n\t\t\tlogger.debug('skipping ondisconnect callback (function missing)');\n\t\t}\n\t}\n\t\n\tthis._doOnConnect = function() {\n\t\tif (typeof(this.onconnect) == 'function') {\n\t\t\tlogger.debug('call onconnect function');\n\t\t\ttry {\n\t\t\t\tthis.onconnect();\n\t\t\t} catch(e) {\n\t\t\t\tlogger.debug('onconnect caused errror', e);\n\t\t\t\t// throw error later\n\t\t\t\tsetTimeout(function() { throw e }, 0);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tlogger.debug('skipping onconnect callback (function missing)');\n\t\t}\n\t}\n\n\tthis._resetTimeoutTimer = function() {\n\t\tclearTimeout(this._timeoutTimer);\n\t\tthis._timeoutTimer = setTimeout(bind(this, function() {\n\t\t\tlogger.debug('connection timeout expired');\n\t\t\tthis.close(new errors.ConnectionTimeout())\n\t\t}), this._getTimeoutInterval())\n\t}\n\t\n\tthis._getTimeoutInterval = function() {\n\t\treturn kDefaultTimeoutInterval;\n\t}\n\n});\n");
jsio.setCachedSrc("../../packages/std/base64.js","/*\n\"URL-safe\" Base64 Codec, by Jacob Rus\n\nThis library happily strips off as many trailing '=' as are included in the\ninput to 'decode', and doesn't worry whether its length is an even multiple\nof 4. It does not include trailing '=' in its own output. It uses the\n'URL safe' base64 alphabet, where the last two characters are '-' and '_'.\n\n--------------------\n\nCopyright (c) 2009 Jacob Rus\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n*/\n\nvar alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n\ttrailingPad = '=',\n\tpadChar = alphabet.charAt(alphabet.length - 1);\n\nvar decodeMap = {};\nfor (var i = 0, len = alphabet.length; i < len; i++) {\n\tdecodeMap[alphabet.charAt(i)] = i;\n}\n\n// use this regexp in the decode function to sniff out invalid characters.\nvar alphabet_inverse = new RegExp('[^' + alphabet.replace('-', '\\\\-') + ']');\n\nexports.Base64CodecError = Class(Error, function(supr) {\n\tthis.name = 'Base64CodecError';\n\t\n\tthis.init = function(message) {\n\t\tsupr(this, 'init', arguments);\n\t\tthis.message = message;\n\t}\n});\n\nvar assertOrBadInput = function (exp, message) {\n\tif (!exp) { throw new exports.Base64CodecError(message) };\n};\n\nexports.encode = function (bytes) {\n\tassertOrBadInput(!(/[^\\x00-\\xFF]/.test(bytes)), // disallow two-byte chars\n\t\t'Input contains out-of-range characters.');\n\tvar padding = '\\x00\\x00\\x00'.slice((bytes.length % 3) || 3);\n\tbytes += padding; // pad with null bytes\n\tvar out_array = [];\n\tfor (var i=0, n=bytes.length; i < n; i+=3) {\n\t\tvar newchars = (\n\t\t\t(bytes.charCodeAt(i)   << 020) +\n\t\t\t(bytes.charCodeAt(i+1) << 010) +\n\t\t\t(bytes.charCodeAt(i+2)));\n\t\tout_array.push(\n\t\t\talphabet.charAt((newchars >> 18) & 077),\n\t\t\talphabet.charAt((newchars >> 12) & 077),\n\t\t\talphabet.charAt((newchars >> 6)  & 077), \n\t\t\talphabet.charAt((newchars)\t   & 077));\t  \n\t};\n\t\n\tout_array.length -= padding.length;\n\treturn out_array.join('');\n};\n\nexports.decode = function (b64text) {\n\tlogger.debug('decode', b64text);\n\tb64text = b64text.replace(/\\s/g, ''); // kill whitespace\n\t\n\t// strip trailing pad characters from input; // XXX maybe some better way?\n\tvar i = b64text.length;\n\twhile (b64text.charAt(--i) === trailingPad) {};\n\tb64text = b64text.slice(0, i + 1);\n\t\n\tassertOrBadInput(!alphabet_inverse.test(b64text), 'Input contains out-of-range characters.');\n\t\n\tvar padLength = 4 - ((b64text.length % 4) || 4),\n\t\tpadding = Array(padLength + 1).join(padChar);\n\t\n\tb64text += padding; // pad with last letter of alphabet\n\t\n\tvar out_array = [],\n\t\tlength = i + padLength + 1; // length of b64text\n\t\n\tfor (var i = 0; i < length; i += 4) {\n\t\tnewchars = (\n\t\t\t(decodeMap[b64text.charAt(i)]   << 18) +\n\t\t\t(decodeMap[b64text.charAt(i+1)] << 12) +\n\t\t\t(decodeMap[b64text.charAt(i+2)] << 6)  +\n\t\t\t(decodeMap[b64text.charAt(i+3)]));\n\t\tout_array.push(\n\t\t\t(newchars >> 020) & 0xFF,\n\t\t\t(newchars >> 010) & 0xFF, \n\t\t\t(newchars)\t\t& 0xFF);\n\t};\n\t\n\tlength = (out_array.length -= padLength);\n\t\n\t// Safari fromCharCode can't be passed more than 65536 arguments at once\n\tvar result,\n\t\tMAX_CHUNK = 65536;\n\t\n\tif (length > MAX_CHUNK) {\n\t\tresult = [];\n\t\tvar i = 0, j = 0;\n\t\twhile (i < length) {\n\t\t\tresult[j++] = String.fromCharCode.apply(String, out_array.slice(i, i + MAX_CHUNK));\n\t\t\ti += MAX_CHUNK;\n\t\t}\n\t\tresult = result.join('');\n\t} else {\n\t\tresult = String.fromCharCode.apply(String, out_array);\n\t}\n\tlogger.debug('decoded', result);\n\treturn result;\n};\n");
jsio.setCachedSrc("../../packages/std/utf8.js","/*\nFast incremental JavaScript UTF-8 encoder/decoder, by Jacob Rus.\n\nAPI for decode from Orbited: as far as I know, the first incremental\nJavaScript UTF-8 decoder.\n\nInspired by the observation by Johan Sundstr\u00f6m published at:\nhttp://ecmanaut.blogspot.com/2006/07/encoding-decoding-utf8-in-javascript.html\n\nNote that this code throws an error for invalid UTF-8. Because it is so much\nfaster than previous implementations, the recommended way to do lenient\nparsing is to first try this decoder, and then fall back on a slower lenient\ndecoder if necessary for the particular use case.\n\n--------------------\n\nCopyright (c) 2009 Jacob Rus\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n*/\n//var utf8 = this.utf8 = exports;\n\nexports.UnicodeCodecError = function (message) { \n\tthis.message = message; \n};\n\nvar UnicodeCodecError = exports.UnicodeCodecError;\n\nUnicodeCodecError.prototype.toString = function () {\n\treturn 'UnicodeCodecError' + (this.message ? ': ' + this.message : '');\n};\n\nexports.encode = function (unicode_string) {\n\t// Unicode encoder: Given an arbitrary unicode string, returns a string\n\t// of characters with code points in range 0x00 - 0xFF corresponding to\n\t// the bytes of the utf-8 representation of those characters.\n\ttry {\n\t\treturn unescape(encodeURIComponent(unicode_string));\n\t}\n\tcatch (err) {\n\t\tthrow new UnicodeCodecError('invalid input string');\n\t};\n};\nexports.decode = function (bytes) {\n\t// Unicode decoder: Given a string of characters with code points in\n\t// range 0x00 - 0xFF, which, when interpreted as bytes, are valid UTF-8,\n\t// returns the corresponding Unicode string, along with the number of\n\t// bytes in the input string which were successfully parsed.\n\t//\n\t// Unlike most JavaScript utf-8 encode/decode implementations, properly\n\t// deals with partial multi-byte characters at the end of the byte string.\n\tif (/[^\\x00-\\xFF]/.test(bytes)) {\n\t\tthrow new UnicodeCodecError('invalid utf-8 bytes');\n\t};\n\tvar len, len_parsed;\n\tlen = len_parsed = bytes.length;\n\tvar last = len - 1;\n\t// test for non-ascii final byte. if last byte is ascii (00-7F) we're done.\n\tif (bytes.charCodeAt(last) >= 0x80) {\n\t\t// loop through last 3 bytes looking for first initial byte of unicode\n\t\t// multi-byte character. If the initial byte is 4th from the end, we'll\n\t\t// parse the whole string.\n\t\tfor (var i = 1; i <= 3; i++) {\n\t\t\t// initial bytes are in range C0-FF\n\t\t\tif (bytes.charCodeAt(len - i) >= 0xC0) {\n\t\t\t\tlen_parsed = len - i;\n\t\t\t\tbreak;\n\t\t\t};\n\t\t};\n\t\ttry {\n\t\t\t// if the last few bytes are a complete multi-byte character, parse\n\t\t\t// everything (by setting len_parsed)\n\t\t\tdecodeURIComponent(escape(bytes.slice(len_parsed)));\n\t\t\tlen_parsed = len;\n\t\t}\n\t\tcatch (err) { /* pass */ };\n\t};\n\ttry {\n\t\treturn [\n\t\t\tdecodeURIComponent(escape(bytes.slice(0, len_parsed))),\n\t\t\tlen_parsed\n\t\t];\n\t}\n\tcatch (err) {\n\t\tthrow new UnicodeCodecError('invalid utf-8 bytes');\n\t};\n};\n");
jsio.setCachedSrc("../../packages/std/uri.js","var attrs = [ \n\t\"source\",\n\t\"protocol\",\n\t\"authority\",\n\t\"userInfo\",\n\t\"user\",\n\t\"password\",\n\t\"host\",\n\t\"port\",\n\t\"relative\",\n\t\"path\",\n\t\"directory\",\n\t\"file\",\n\t\"query\",\n\t\"anchor\"\n];\n\nvar URI = exports = Class(function(supr) {\n\tthis.init = function(url, isStrict) {\n\t\tif (url instanceof URI) {\n\t\t\tfor (var i = 0, attr; attr = attrs[i]; ++i) {\n\t\t\t\tthis['_' + attr] = url['_' + attr];\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tthis._isStrict = isStrict;\n\t\t\n\t\tvar uriData = exports.parse(url, isStrict);\n\t\tfor (var attr in uriData) {\n\t\t\tthis['_' + attr] = uriData[attr];\n\t\t};\n\t}\n  \n\tfor (var i = 0, attr; attr = attrs[i]; ++i) {\n\t\t(function(attr) {\n\t\t\tvar fNameSuffix = attr.charAt(0).toUpperCase() + attr.slice(1);\n\t\t\tthis['get' + fNameSuffix] = function() {\n\t\t\t\treturn this['_' + attr];\n\t\t\t};\n\t\t\tthis['set' + fNameSuffix] = function(val) {\n\t\t\t\tthis['_' + attr] = val;\n\t\t\t\treturn this;\n\t\t\t};\n\t\t}).call(this, attr);\n\t};\n\t\n\tthis.query = function(key) { return exports.parseQuery(this._query)[key]; }\n\tthis.hash = function(key) { return exports.parseQuery(this._anchor)[key]; }\n\t\n\tthis.addHash = function(kvp) {\n\t\tvar hash = exports.parseQuery(this._anchor);\n\t\tfor (var i in kvp) { hash[i] = kvp[i]; }\n\t\tthis._anchor = exports.buildQuery(hash);\n\t\treturn this;\n\t}\n\t\n\tthis.addQuery = function(kvp) {\n\t\tvar query = exports.parseQuery(this._query);\n\t\tfor (var i in kvp) { query[i] = kvp[i]; }\n\t\tthis._query = exports.buildQuery(query);\n\t\treturn this;\n\t}\n\t\n\tthis.removeQuery = function(keys) {\n\t\tvar query = exports.parseQuery(this._query);\n\t\tif (isArray(keys)) {\n\t\t\tfor (var i = 0, n = keys.length; i < n; ++i) {\n\t\t\t\tdelete query[keys[i]];\n\t\t\t}\n\t\t} else {\n\t\t\tdelete query[keys];\n\t\t}\n\t\tthis._query = exports.buildQuery(query);\n\t\treturn this;\n\t}\n\n\tthis.toString = this.render = function(onlyBase) {\n\t\t// XXX TODO: This is vaguely reasonable, but not complete. fix it...\n\t\tvar a = this._protocol ? this._protocol + \"://\" : \"\"\n\t\tvar b = this._host ? this._host + ((this._port || 80) == 80 ? \"\" : \":\" + this._port) : \"\";\n\t\t\n\t\tif (onlyBase) {\n\t\t\treturn a + b;\n\t\t}\n\t\t\n\t\tvar c = this._path;\n\t\tvar d = this._query ? '?' + this._query : '';\n\t\tvar e = this._anchor ? '#' + this._anchor : '';\n\t\treturn a + b + c + d + e;\n\t};\n});\n\nexports.relativeTo = function(url, base) {\n\turl = String(url);\n\t\n\tif (/^http(s?):\\/\\//.test(url)) { return url; }\n\tif (url.charAt(0) == '/') {\n\t\tvar baseuri = new exports(base);\n\t\turl = baseuri.toString(true) + url;\n\t} else {\n\t\turl = base + url;\n\t}\n\t\n\treturn exports.resolveRelative(url);\n}\n\nexports.resolveRelative = function(url) {\n\tvar prevUrl;\n\t\n\t// remove ../ with preceeding folder\n\twhile((prevUrl = url) != (url = url.replace(/(^|\\/)([^\\/]+)\\/\\.\\.\\//g, '/'))) {};\n\t\n\t// remove ./ if it isn't preceeded by a .\n\treturn url.replace(/[^.]\\.\\//g, '');\n}\n\nexports.buildQuery = function(kvp) {\n\tvar pairs = [];\n\tfor (var key in kvp) {\n\t\tpairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(kvp[key]));\n\t}\n\treturn pairs.join('&');\n}\n\nexports.parseQuery = function(str) {\n\tvar pairs = str.split('&'),\n\t\tn = pairs.length,\n\t\tdata = {};\n\tfor (var i = 0; i < n; ++i) {\n\t\tvar pair = pairs[i].split('='),\n\t\t\tkey = decodeURIComponent(pair[0]);\n\t\tif (key) { data[key] = decodeURIComponent(pair[1]); }\n\t}\n\treturn data;\n}\n\n// Regexs are based on parseUri 1.2.2\n// Original: (c) Steven Levithan <stevenlevithan.com>\n// Original: MIT License\n\nvar strictRegex = /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?))?((((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/;\nvar looseRegex = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\nvar queryStringRegex = /(?:^|&)([^&=]*)=?([^&]*)/g;\n\nexports.parse = function(str, isStrict) {\n\tvar regex = isStrict ? strictRegex : looseRegex;\n\tvar result = {};\n\tvar match = regex.exec(str);\n\tfor (var i = 0, attr; attr = attrs[i]; ++i) {\n\t\tresult[attr] = match[i] || \"\";\n\t}\n\t\n\tvar qs = result['queryKey'] = {};\n\tresult['query'].replace(queryStringRegex, function(check, key, val) {\n\t\tif (check) {\n\t\t\tqs[key] = val;\n\t\t}\n\t});\n\t\n\treturn result;\n}\n\nexports.isSameDomain = function(urlA, urlB) {\n\tvar a = exports.parse(urlA);\n\tvar b = exports.parse(urlB);\n\treturn ((a.port == b.port ) && (a.host == b.host) && (a.protocol == b.protocol));\n};\n");
jsio.setCachedSrc("../../packages/net/errors.js",'var makeErrorClass = function(name, _code) {\n\tvar toString = function() {\n\t\treturn name + (this.message ? \': \' + this.message : \'\');\n\t}\n\n\tvar ctor = function(data) {\n\t\tif (typeof data == \'string\') {\n\t\t\tthis.message = data;\n\t\t} else {\n\t\t\tthis.data = data;\n\t\t}\n\t}\n\t\n\tctor.prototype = {\n\t\ttype: name,\n\t\ttoString: toString\n\t};\n\t\n\treturn ctor;\n}\n\nexports.ReadyStateError = makeErrorClass("ReadyStateError");\nexports.InvalidEncodingError = makeErrorClass("InvalidEncodingError");\nexports.ExpiredSession = makeErrorClass("ExpiredSession");\n\nexports.ServerUnreachable = makeErrorClass("ServerUnreachable", 100);\nexports.ConnectionTimeout = makeErrorClass("ConnectionTimeout", 101);\n\nexports.ServerProtocolError = makeErrorClass("ServerProtocolError", 200);\n\nexports.ServerClosedConnection = makeErrorClass("ServerClosedConnection", 301);\nexports.ConnectionClosedCleanly = makeErrorClass("ConnectionClosedCleanly", 300);');
jsio.setCachedSrc("../../packages/net/csp/transports.js","jsio('import std.uri as uri'); \njsio('import std.base64 as base64');\njsio('from util.browserdetect import BrowserDetect');\n\n;(function() {\n\tvar doc;\n\texports.getDoc = function() {\n\t\tif (doc) { return doc; }\n\t\ttry {\n\t\t\tdoc = window.ActiveXObject && new ActiveXObject('htmlfile');\n\t\t\tif (doc) {\n\t\t\t\tdoc.open().write('<html></html>');\n\t\t\t\tdoc.close();\n\t\t\t\twindow.attachEvent('onunload', function() {\n\t\t\t\t\ttry { doc.body.innerHTML = ''; } catch(e) {}\n\t\t\t\t\tdoc = null;\n\t\t\t\t});\n\t\t\t}\n\t\t} catch(e) {}\n\t\t\n\t\tif (!doc) { doc = document; }\n\t\treturn doc;\n\t};\n\n\texports.XHR = function() {\n\t\tvar win = window,\n\t\t\tdoc = exports.getDoc();\n\t\t//if (doc.parentWindow) { win = doc.parentWindow; }\n\t\t\n\t\treturn new (exports.XHR = win.XMLHttpRequest ? win.XMLHttpRequest\n\t\t\t: function() { return win.ActiveXObject && new win.ActiveXObject('Msxml2.XMLHTTP') || null; });\n\t}\n\t\n\texports.createXHR = function() { return new exports.XHR(); }\n\n})();\n\nfunction isLocalFile(url) { return /^file:\\/\\//.test(url); }\nfunction isWindowDomain(url) { return uri.isSameDomain(url, window.location.href); }\n\nvar xhrSupportsBinary = undefined;\nfunction checkXHRBinarySupport(xhr) {\n\txhrSupportsBinary = !!xhr.sendAsBinary;\n}\n\nfunction canUseXHR(url) {\n\t// always use jsonp for local files\n\tif (isLocalFile(url)) { return false; }\n\t\n\t// try to create an XHR using the same function the XHR transport uses\n\tvar xhr = new exports.XHR();\n\tif (!xhr) { return false; }\n\t\n\tcheckXHRBinarySupport(xhr);\n\t\n\t// if the URL requested is the same domain as the window,\n\t// then we can use same-domain XHRs\n\tif (isWindowDomain(url)) { return true; }\n\t\n\t// if the URL requested is a different domain than the window,\n\t// then we need to check for cross-domain support\n\tif (window.XMLHttpRequest\n\t\t\t&& (xhr.__proto__ == XMLHttpRequest.prototype // WebKit Bug 25205\n\t\t\t\t|| xhr instanceof window.XMLHttpRequest)\n\t\t\t&& xhr.withCredentials !== undefined\n\t\t|| window.XDomainRequest \n\t\t\t&& xhr instanceof window.XDomainRequest) {\n\t\treturn true;\n\t}\n};\n\nvar transports = exports.transports = {};\n\nexports.chooseTransport = function(url, options) {\n\tswitch(options.preferredTransport) {\n\t\tcase 'jsonp':\n\t\t\treturn transports.jsonp;\n\t\tcase 'xhr':\n\t\tdefault:\n\t\t\tif (canUseXHR(url)) { return transports.xhr; };\n\t\t\treturn transports.jsonp;\n\t}\n};\n\n// TODO: would be nice to use these somewhere...\n\nvar PARAMS = {\n\t'xhrstream':   {\"is\": \"1\", \"bs\": \"\\n\"},\n\t'xhrpoll':     {\"du\": \"0\"},\n\t'xhrlongpoll': {},\n\t'sselongpoll': {\"bp\": \"data: \", \"bs\": \"\\r\\n\", \"se\": \"1\"},\n\t'ssestream':   {\"bp\": \"data: \", \"bs\": \"\\r\\n\", \"se\": \"1\", \"is\": \"1\"}\n};\n\nexports.Transport = Class(function(supr) {\n\tthis.handshake = function(url, options) {\n\t\tthrow new Error(\"handshake Not Implemented\"); \n\t};\n\tthis.comet = function(url, sessionKey, lastEventId, options) { \n\t\tthrow new Error(\"comet Not Implemented\"); \n\t};\n\tthis.send = function(url, sessionKey, data, options) { \n\t\tthrow new Error(\"send Not Implemented\");\n\t};\n\tthis.encodePacket = function(packetId, data, options) { \n\t\tthrow new Error(\"encodePacket Not Implemented\"); \n\t};\n\tthis.abort = function() { \n\t\tthrow new Error(\"abort Not Implemented\"); \n\t};\n});\n\nvar baseTransport = Class(exports.Transport, function(supr) {\n\tthis.init = function() {\n\t\tthis._aborted = false;\n\t\tthis._handshakeArgs = {ct:'application/javascript'};\n\t\tthis._handshakeData = '{}'\n\t};\n\t\n\tthis.handshake = function(url, options) {\n\t\tlogger.debug('handshake:', url, options);\n\t\tthis._makeRequest('send', url + '/handshake', \n\t\t\t\t\t\t  this._handshakeArgs,\n\t\t\t\t\t\t  this._handshakeData,\n\t\t\t\t\t\t  this.handshakeSuccess, \n\t\t\t\t\t\t  this.handshakeFailure);\n\t};\n\t\n\tthis.comet = function(url, sessionKey, lastEventId, options) {\n\t\tlogger.debug('comet:', url, sessionKey, lastEventId, options);\n\t\tvar args = {\n\t\t\ts: sessionKey,\n\t\t\ta: lastEventId\n\t\t};\n\t\tthis._makeRequest('comet', url + '/comet', \n\t\t\t\t\t\t  args,\n\t\t\t\t\t\t  null,\n\t\t\t\t\t\t  this.cometSuccess, \n\t\t\t\t\t\t  this.cometFailure);\n\t};\n\t\n\tthis.send = function(url, sessionKey, lastEventId, data, options) {\n\t\t//logger.debug('send:', url, sessionKey, data, options);\n\t\tvar args = {\n\t\t\ts: sessionKey,\n\t\t\ta: lastEventId\n\t\t};\n\t\tthis._makeRequest('send', url + '/send', \n\t\t\t\t\t\t  args,\n\t\t\t\t\t\t  data,\n\t\t\t\t\t\t  this.sendSuccess, \n\t\t\t\t\t\t  this.sendFailure);\n\t};\n});\n\ntransports.xhr = Class(baseTransport, function(supr) {\n\t\n\tthis.init = function() {\n\t\tsupr(this, 'init');\n\t\n\t\tthis._xhr = {\n\t\t\t'send': new exports.XHR(),\n\t\t\t'comet': new exports.XHR()\n\t\t};\n\t};\n\n\tthis.abort = function() {\n\t\tthis._aborted = true;\n\t\tfor(var i in this._xhr) {\n\t\t\tif(this._xhr.hasOwnProperty(i)) {\n\t\t\t\tthis._abortXHR(i);\n\t\t\t}\n\t\t}\n\t};\n\t\n\tthis._abortXHR = function(type) {\n\t\tlogger.debug('aborting XHR');\n\n\t\tvar xhr = this._xhr[type];\n\t\ttry {\n\t\t\tif('onload' in xhr) {\n\t\t\t\txhr.onload = xhr.onerror = xhr.ontimeout = null;\n\t\t\t} else if('onreadystatechange' in xhr) {\n\t\t\t\txhr.onreadystatechange = null;\n\t\t\t}\n\t\t\tif(xhr.abort) { xhr.abort(); }\n\t\t} catch(e) {\n\t\t\tlogger.debug('error aborting xhr', e);\n\t\t}\n\t\t\n\t\t// do not reuse aborted XHRs\n\t\tthis._xhr[type] = new exports.XHR();\n\t};\n\t\n\tthis.encodePacket = function(packetId, data, options) {\n\t\t// we don't need to base64 encode things unless there's a null character in there\n\t\treturn !xhrSupportsBinary ? [ packetId, 1, base64.encode(data) ] : [ packetId, 0, data ];\n\t};\n\n\tfunction onReadyStateChange(xhr, rType, cb, eb) {\n\t\ttry {\n\t\t\tvar data = {status: xhr.status};\n\t\t} catch(e) { eb({response: 'Could not access status'}); }\n\t\t\n\t\ttry {\n\t\t\tif(xhr.readyState != 4) { return; }\n\t\t\t\n\t\t\tdata.response = eval(xhr.responseText);\n\t\t\tif(data.status != 200) { \n\t\t\t\tlogger.debug('XHR failed with status ', xhr.status);\n\t\t\t\teb(data);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tlogger.debug('XHR data received');\n\t\t} catch(e) {\n\t\t\tlogger.debug('Error in XHR::onReadyStateChange', e);\n\t\t\teb(data);\n\t\t\tthis._abortXHR(rType);\n\t\t\tlogger.debug('done handling XHR error');\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tcb(data);\n\t};\n\n\t/**\n\t * even though we encode the POST body as in application/x-www-form-urlencoded\n\t */\n\tthis._makeRequest = function(rType, url, args, data, cb, eb) {\n\t\tif (this._aborted) { return; }\n\t\tvar xhr = this._xhr[rType];\n\t\txhr.open('POST', url + '?' + uri.buildQuery(args)); // must open XHR first\n\t\txhr.setRequestHeader('Content-Type', 'text/plain'); // avoid preflighting\n\t\tif('onload' in xhr) {\n\t\t\txhr.onload = bind(this, onReadyStateChange, xhr, rType, cb, eb);\n\t\t\txhr.onerror = xhr.ontimeout = eb;\n\t\t} else if('onreadystatechange' in xhr) {\n\t\t\txhr.onreadystatechange = bind(this, onReadyStateChange, xhr, rType, cb, eb);\n\t\t}\n\t\t// NOTE WELL: Firefox (and probably everyone else) likes to encode our nice\n\t\t//\t\t\t\t\t\tbinary strings as utf8. Don't let them! Say no to double utf8\n\t\t//\t\t\t\t\t\tencoding. Once is good, twice isn't better.\n\t\t// if (xhrSupportsBinary) {\n\t\t// \t\txhr.setRequestHeader('x-CSP-SendAsBinary', 'true');\n\t\t// }\n\t\tsetTimeout(function() {\n\t\t\txhr[xhrSupportsBinary ? 'sendAsBinary' : 'send'](data || null)\n\t\t}, 0);\n\t};\n});\n\nvar EMPTY_FUNCTION = function() {},\n\tSLICE = Array.prototype.slice;\n\ntransports.jsonp = Class(baseTransport, function(supr) {\n\tvar doc;\n\t\n\tvar createIframe = function() {\n\t\tvar doc = exports.getDoc();\n\t\tif (!doc.body) { return false; }\n\t\t\n\t\tvar i = doc.createElement(\"iframe\");\n\t\twith(i.style) { display = 'block'; width = height = border = margin = padding = '0'; overflow = visibility = 'hidden'; position = 'absolute'; top = left = '-999px'; }\n\t\ti.cbId = 0;\n\t\tdoc.body.appendChild(i);\n\t\ti.src = 'javascript:var d=document;d.open();d.write(\"<html><body></body></html>\");d.close();';\n\t\treturn i;\n\t};\n\n\tvar cleanupIframe = function(ifr) {\n\t\tvar win = ifr.contentWindow, doc = win.document;\n\t\tlogger.debug('removing script tags');\n\t\t\n\t\tvar scripts = doc.getElementsByTagName('script');\n\t\tfor (var i = scripts.length - 1; i >= 0; --i) {\n\t\t\tdoc.body.removeChild(scripts[i]);\n\t\t}\n\t\t\n\t\tlogger.debug('deleting iframe callbacks');\n\t\twin['cb' + ifr.cbId] = win['eb' + ifr.cbId] = EMPTY_FUNCTION;\n\t};\n\n\tvar removeIframe = function(ifr) {\n\t\tsetTimeout(function() {\n\t\t\tif(ifr && ifr.parentNode) { ifr.parentNode.removeChild(ifr); }\n\t\t}, 60000);\n\t};\n\n\tthis.init = function() {\n\t\tsupr(this, 'init');\n\n\t\tthis._onReady = [];\n\t\tthis._isReady = false;\n\n\t\tthis._createIframes();\n\t};\n\n\tthis._createIframes = function() {\n\t\tthis._ifr = {\n\t\t\tsend: createIframe(),\n\t\t\tcomet: createIframe()\n\t\t};\n\t\t\n\t\tif(this._ifr.send === false) { return setTimeout(bind(this, '_createIframes'), 100); }\n\t\t\n\t\tthis._isReady = true;\n\n\t\tvar readyArgs = this._onReady;\n\t\tthis._onReady = [];\n\t\tfor(var i = 0, args; args = readyArgs[i]; ++i) {\n\t\t\tthis._makeRequest.apply(this, args);\n\t\t}\n\t};\n\n\tthis.encodePacket = function(packetId, data, options) {\n\t\treturn [ packetId, 1, base64.encode(data) ];\n\t};\n\n\tthis.abort = function() {\n\t\tthis._aborted = true;\n\t\tfor(var i in this._ifr) {\n\t\t\tif(this._ifr.hasOwnProperty(i)) {\n\t\t\t\tvar ifr = this._ifr[i];\n\t\t\t\tcleanupIframe(ifr);\n\t\t\t\tremoveIframe(ifr);\n\t\t\t}\n\t\t}\n\t};\n\t\n\tthis._makeRequest = function(rType, url, args, data, cb, eb) {\n\t\tif(!this._isReady) { return this._onReady.push(arguments); }\n\t\t\n\t\tvar ifr = this._ifr[rType],\n\t\t\tid = ++ifr.cbId,\n\t\t\treq = {\n\t\t\t\ttype: rType,\n\t\t\t\tid: id,\n\t\t\t\tcb: cb,\n\t\t\t\teb: eb,\n\t\t\t\tcbName: 'cb' + id,\n\t\t\t\tebName: 'eb' + id,\n\t\t\t\tcompleted: false\n\t\t\t};\n\t\t\n\t\targs.d = data;\n\t\targs.n = Math.random();\t\n\t\tswitch(rType) {\n\t\t\tcase 'send': args.rs = ';'; args.rp = req.cbName; break;\n\t\t\tcase 'comet': args.bs = ';'; args.bp = req.cbName; break;\n\t\t}\n\t\t\n\t\treq.url = url + '?' + uri.buildQuery(args)\n\t\t\n\t\tsetTimeout(bind(this, '_request', req), 0);\n\t}\n\t\n\tthis._request = function(req) {\n\t\tvar ifr = this._ifr[req.type],\n\t\t\twin = ifr.contentWindow,\n\t\t\tdoc = win.document,\n\t\t\tbody = doc.body;\n\n\t\twin[req.ebName] = bind(this, checkForError, req);\n\t\twin[req.cbName] = bind(this, onSuccess, req);\n\t\t\n\t\tif(BrowserDetect.isWebKit) {\n\t\t\t// this will probably cause loading bars in Safari -- might want to rethink?\n\t\t\tdoc.open();\n\t\t\tdoc.write('<scr'+'ipt src=\"'+req.url+'\"></scr'+'ipt><scr'+'ipt>'+ebName+'(false)</scr'+'ipt>');\n\t\t\tdoc.close();\n\t\t} else {\n\t\t\tvar s = doc.createElement('script');\n\t\t\ts.src = req.url;\n\t\t\t\n\t\t\t// IE\n\t\t\tif(s.onreadystatechange === null) { s.onreadystatechange = bind(this, onReadyStateChange, req, s); }\n\t\t\tbody.appendChild(s);\n\t\t\t\n\t\t\tif(!BrowserDetect.isIE) {\n\t\t\t\tvar s = doc.createElement('script');\n\t\t\t\ts.innerHTML = req.ebName+'(false)';\n\t\t\t\tbody.appendChild(s);\n\t\t\t}\n\t\t}\n\t\t\n\t\tkillLoadingBar();\n\t};\n\t\n\tfunction onSuccess(req, response) {\n\t\tlogger.debug('successful: ', req.url, response);\n\t\treq.completed = true;\n\t\t\n\t\tlogger.debug('calling the cb');\n\t\treq.cb.call(GLOBAL, {status: 200, response: response});\n\t\tlogger.debug('cb called');\n\t}\n\t\n\t// IE6/7 onReadyStateChange\n\tfunction onReadyStateChange(req, scriptTag) {\n\t\tif (scriptTag && scriptTag.readyState != 'loaded') { return; }\n\t\tscriptTag.onreadystatechange = function() {};\n\t\tcheckForError.call(this, req);\n\t}\n\n\tfunction checkForError(req, response) {\n\t\tcleanupIframe(this._ifr[req.type]);\n\t\t\n\t\tif (!req.completed) {\n\t\t\tvar data = {\n\t\t\t\tstatus: response ? 200 : 404,\n\t\t\t\tresponse: response || 'Unable to load resouce'\n\t\t\t};\n\t\t\t\n\t\t\tlogger.debug('error making request:', req.url, data);\n\t\t\tlogger.debug('calling eb');\n\t\t\treq.eb.call(GLOBAL, data);\n\t\t}\n\t}\n\t\n\tvar killLoadingBar = BrowserDetect.isFirefox || BrowserDetect.isOpera ? function() {\n\t\tvar b = document.body;\n\t\tif (!b) { return; }\n\t\t\n\t\tif (!killLoadingBar.iframe) { killLoadingBar.iframe = document.createElement('iframe'); }\n\t\tb.insertBefore(killLoadingBar.iframe, b.firstChild);\n\t\tb.removeChild(killLoadingBar.iframe);\n\t} : function() {};\n});\n\t\n");
jsio.setCachedSrc("../../packages/util/browserdetect.js",'exports.BrowserDetect = new function() {\n\tvar versionSearchString;\n\tvar dataBrowser = [\n\t\t{\n\t\t\tstring: navigator.userAgent,\n\t\t\tsubString: "Chrome"\n\t\t},\n\t\t{\n\t\t\tstring: navigator.userAgent,\n\t\t\tsubString: "OmniWeb",\n\t\t\tversionSearch: "OmniWeb/"\n\t\t},\n\t\t{\n\t\t\tstring: navigator.vendor,\n\t\t\tsubString: "Apple",\n\t\t\tidentity: "Safari",\n\t\t\tversionSearch: "Version"\n\t\t},\n\t\t{\n\t\t\tprop: window.opera,\n\t\t\tidentity: "Opera"\n\t\t},\n\t\t{\n\t\t\tstring: navigator.vendor,\n\t\t\tsubString: "iCab"\n\t\t},\n\t\t{\n\t\t\tstring: navigator.vendor,\n\t\t\tsubString: "KDE",\n\t\t\tidentity: "Konqueror"\n\t\t},\n\t\t{\n\t\t\tstring: navigator.userAgent,\n\t\t\tsubString: "Firefox"\n\t\t},\n\t\t{\n\t\t\tstring: navigator.vendor,\n\t\t\tsubString: "Camino"\n\t\t},\n\t\t{\t\t// for newer Netscapes (6+)\n\t\t\tstring: navigator.userAgent,\n\t\t\tsubString: "Netscape"\n\t\t},\n\t\t{\n\t\t\tstring: navigator.userAgent,\n\t\t\tsubString: "MSIE",\n\t\t\tidentity: "IE",\n\t\t\tversionSearch: "MSIE"\n\t\t},\n\t\t{\n\t\t\tstring: navigator.userAgent,\n\t\t\tsubString: "Gecko",\n\t\t\tidentity: "Mozilla",\n\t\t\tversionSearch: "rv"\n\t\t},\n\t\t{ \t\t// for older Netscapes (4-)\n\t\t\tstring: navigator.userAgent,\n\t\t\tsubString: "Mozilla",\n\t\t\tidentity: "Netscape",\n\t\t\tversionSearch: "Mozilla"\n\t\t}\n\t];\n\t\n\tvar dataOS = [\n\t\t{\n\t\t\tstring: navigator.platform,\n\t\t\tsubString: "Win",\n\t\t\tidentity: "Windows"\n\t\t},\n\t\t{\n\t\t\tstring: navigator.platform,\n\t\t\tsubString: "Mac"\n\t\t},\n\t\t{\n\t\t\tstring: navigator.userAgent,\n\t\t\tsubString: "iPhone",\n\t\t\tidentity: "iPhone/iPod"\n\t\t},\n\t\t{\n\t\t\tstring: navigator.platform,\n\t\t\tsubString: "Linux"\n\t\t}\n\t];\n\t\n\tfunction searchString(data) {\n\t\tfor (var i=0,item;item=data[i];i++)\t{\n\t\t\tvar dataString = item.string;\n\t\t\tvar dataProp = item.prop;\n\t\t\titem.identity = item.identity || item.subString;\n\t\t\tversionSearchString = item.versionSearch || item.identity;\n\t\t\tif (dataString) {\n\t\t\t\tif (dataString.indexOf(item.subString) != -1)\n\t\t\t\t\treturn item.identity;\n\t\t\t} else if (dataProp)\n\t\t\t\treturn item.identity;\n\t\t}\n\t}\n\t\n\tfunction searchVersion(dataString) {\n\t\tvar index = dataString.indexOf(versionSearchString);\n\t\tif (index == -1) return;\n\t\treturn parseFloat(dataString.substring(index+versionSearchString.length+1));\n\t}\n\t\n\tthis.browser = searchString(dataBrowser) || "unknown";\n\tthis.version = searchVersion(navigator.userAgent)\n\t\t|| searchVersion(navigator.appVersion)\n\t\t|| "unknown";\n\tthis.OS = searchString(dataOS) || "unknown";\n\tthis.isWebKit = RegExp(" AppleWebKit/").test(navigator.userAgent);\n\tthis[\'is\'+this.browser] = this.version;\n};');
jsio.setCachedSrc("../../packages/net/env/browser/csp.js","jsio('import net.interfaces');\njsio('from net.csp.client import CometSession');\njsio('import std.utf8 as utf8');\n\nexports.Connector = Class(net.interfaces.Connector, function() {\n\tthis.connect = function() {\n\t\tthis._state = net.interfaces.STATE.CONNECTING;\n\t\t\n\t\tvar conn = new CometSession();\n\t\tconn.onconnect = bind(this, 'cometSessionOnConnect', conn);\n\t\tconn.ondisconnect = bind(this, 'onDisconnect');\n\t\t\n\t\tlogger.debug('opening the connection');\n\t\tif (!this._opts.encoding) { this._opts.encoding = 'plain'; }\n\t\tconn.connect(this._opts.url, this._opts);//{encoding: 'plain'});\n\t}\n\t\n\tthis.cometSessionOnConnect = function(conn) {\n\t\tlogger.debug('conn has opened');\n\t\tthis.onConnect(new Transport(conn));\n\t}\n});\n\nvar Transport = Class(net.interfaces.Transport, function() {\n\tthis.init = function(conn) {\n\t\tthis._conn = conn;\n\t}\n\t\n\tthis.makeConnection = function(protocol) {\n\t\tthis._conn.onread = bind(protocol, 'dataReceived');\n\t}\n\t\n\tthis.write = function(data) {\n\t\tthis._conn.write(data);\n\t}\n\t\n\tthis.loseConnection = function(protocol) {\n\t\tthis._conn.close();\n\t}\n});\n");
jsio.setCachedSrc("../../packages/net/interfaces.js","// Sort of like a twisted protocol\njsio('import net');\njsio('import lib.Enum as Enum');\n\nvar ctx = jsio.__env.global;\n\nexports.Protocol = Class(function() {\n\tthis.connectionMade = function(isReconnect) {}\n\tthis.dataReceived = function(data) {}\n\tthis.connectionLost = function(reason) {}\n\t\n\tthis._connectionMade = function() {\n\t\tthis._isConnected = true;\n\t\tthis.connectionMade.apply(this, arguments);\n\t}\n\n\tthis._connectionLost = function() {\n\t\tthis._isConnected = true;\n\t\tthis.connectionLost.apply(this, arguments);\n\t}\n\n\tthis._isConnected = false;\n\tthis.isConnected = function() {\n\t\treturn !!this._isConnected;\n\t}\n\t\n\t\n});\n\nexports.Client = Class(function() {\n\tthis.init = function(protocol) {\n\t\tthis._protocol = protocol;\n\t}\n\t\n\tthis.connect = function(transportName, opts) {\n\t\tthis._remote = new this._protocol();\n\t\tthis._remote._client = this;\n\t\tnet.connect(this._remote, transportName, opts);\n\t}\n});\n\n// Sort of like a twisted factory\nexports.Server = Class(function() {\n\tthis.init = function(protocolClass) {\n\t\tthis._protocolClass = protocolClass;\n\t}\n\n\tthis.buildProtocol = function() {\n\t\treturn new this._protocolClass();\n\t}\n\t\n\tthis.listen = function(how, port) {\n\t\treturn net.listen(this, how, port);\n\t}\n});\n\nexports.Transport = Class(function() {\n\tthis._encoding = 'plain'\n\tthis.write = function(data, encoding) {\n\t\tthrow new Error(\"Not implemented\");\n\t}\n\tthis.getPeer = function() {\n\t\tthrow new Error(\"Not implemented\");\n\t}\n\tthis.setEncoding = function(encoding) {\n\t\tthis._encoding = encoding;\n\t}\n\tthis.getEncoding = function() {\n\t\treturn this._encoding;\n\t}\n});\n\nexports.Listener = Class(function() {\n\tthis.init = function(server, opts) {\n\t\tthis._server = server;\n\t\tthis._opts = opts || {};\n\t}\n\t\n\tthis.onConnect = function(transport) {\n//\t\ttry {\n\t\t\tvar p = this._server.buildProtocol();\n\t\t\tp.transport = transport;\n\t\t\tp.server = this._server;\n\t\t\ttransport.protocol = p;\n\t\t\ttransport.makeConnection(p);\n\t\t\tp._connectionMade();\n//\t\t} catch(e) {\n//\t\t\tlogger.error(e);\n//\t\t}\n\t}\n\t\n\tthis.listen = function() { throw new Error('Abstract class'); }\n\tthis.stop = function() {}\n});\n\nexports.STATE = Enum('INITIAL', 'DISCONNECTED', 'CONNECTING', 'CONNECTED');\nexports.Connector = Class(function() {\n\tthis.init = function(protocol, opts) {\n\t\tthis._protocol = protocol;\n\t\tthis._opts = opts;\n\t\tthis._state = exports.STATE.INITIAL;\n\t}\n\t\n\tthis.getState = function() { return this._state; }\n\t\n\tthis.onConnect = function(transport) {\n\t\tthis._state = exports.STATE.CONNECTED;\n\n\t\ttransport.makeConnection(this._protocol);\n\t\tthis._protocol.transport = transport;\n//\t\ttry {\n\t\t\tthis._protocol._connectionMade();\n//\t\t} catch(e) {\n//\t\t\tthrow logger.error(e);\n//\t\t}\n\t}\n\t\n\tthis.onDisconnect = function(err) {\n\t\tvar wasConnected = this._state == exports.STATE.CONNECTED;\n\t\tthis._state = exports.STATE.DISCONNECTED;\n\t\t\n\t\ttry {\n\t\t\tthis._protocol._connectionLost(err, wasConnected);\n\t\t} catch(e) {\n\t\t\tthrow logger.error(e);\n\t\t}\n\t}\n\t\n\tthis.getProtocol = function() { return this._protocol; }\n});\n");
jsio.setCachedSrc("../../packages/net.js","jsio('import net.env');\njsio('import std.JSON as JSON');\n\nJSON.createGlobal(); // create the global JSON object if it doesn't already exist\n\nexports.listen = function(server, transportName, opts) {\n\tif (!transportName) {\n\t\tthrow logger.error('No transport provided for net.listen');\n\t}\n\t\n\tvar ctor = typeof transportName == 'string' ? net.env.getListener(transportName) : transportName,\n\t\tlistener = new ctor(server, opts);\n\t\n\tlistener.listen();\n\treturn listener;\n}\n\nexports.connect = function(protocolInstance, transportName, opts) {\n\tvar ctor = typeof transportName == 'string' ? net.env.getConnector(transportName) : transportName,\n\t\tconnector = new ctor(protocolInstance, opts);\n\tconnector.connect();\n\treturn connector;\n}\n\nexports.quickServer = function(protocolClass) {\n\tjsio('import net.interfaces');\n\treturn new net.interfaces.Server(protocolClass);\n}\n");
jsio.setCachedSrc("../../packages/net/env.js","function getObj(objectName, transportName, envName) {\n\t\n\ttry {\n\t\tvar DYNAMIC_IMPORT_ENV = 'from .env.' + (envName || jsio.__env.name) + '.' + transportName + ' import ' + objectName + ' as result';\n\t\tjsio(DYNAMIC_IMPORT_ENV);\n\t} catch(e) {\n\t\tthrow logger.error('Invalid transport (', transportName, ') or environment (', envName, ')');\n\t}\n\treturn result;\n}\n\nexports.getListener = bind(this, getObj, 'Listener');\nexports.getConnector = bind(this, getObj, 'Connector');\n");
jsio.setCachedSrc("../../packages/std/JSON.js","// Based on json2.js (version 2009-09-29) http://www.JSON.org/json2.js\n// exports createGlobal, stringify, parse, stringifyDate\n\n/**\n * if a global JSON object doesn't exist, create one\n */\nexports.createGlobal = function() {\n\tif(typeof JSON == 'undefined') { JSON = {}; }\n\tif(typeof JSON.stringify !== 'function') {\n\t\tJSON.stringify = exports.stringify;\n\t}\n\tif(typeof JSON.parse !== 'function') {\n\t\tJSON.parse = exports.parse;\n\t}\n};\n\n;(function() {\n\tvar cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n\t\tescapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n\t\tgap,\n\t\tindent,\n\t\tmeta = {\t// table of character substitutions\n\t\t\t'\\b': '\\\\b',\n\t\t\t'\\t': '\\\\t',\n\t\t\t'\\n': '\\\\n',\n\t\t\t'\\f': '\\\\f',\n\t\t\t'\\r': '\\\\r',\n\t\t\t'\"' : '\\\\\"',\n\t\t\t'\\\\': '\\\\\\\\'\n\t\t},\n\t\trep;\n\t\n\tfunction quote(string) {\n\t\t// quote the string if it doesn't contain control characters, quote characters, and backslash characters\n\t\t// otherwise, replace those characters with safe escape sequences\n\t\tescapable.lastIndex = 0;\n\t\treturn escapable.test(string)\n\t\t\t? '\"' + string.replace(escapable, function (a) {\n\t\t\t\t\tvar c = meta[a];\n\t\t\t\t\treturn typeof c === 'string' ? c : '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n\t\t\t\t}) + '\"'\n\t\t\t: '\"' + string + '\"';\n\t}\n\t\n\t// Produce a string from holder[key].\n\tfunction str(key, holder) {\n\t\tvar mind = gap, value = holder[key];\n\t\t\n\t\t// If the value has a toJSON method, call it to obtain a replacement value.\n\t\tif (value && typeof value === 'object' && typeof value.toJSON === 'function') {\n\t\t\tvalue = value.toJSON(key);\n\t\t}\n\t\t\n\t\t// If we were called with a replacer function, then call the replacer to\n\t\t// obtain a replacement value.\n\t\tif (typeof rep === 'function') { value = rep.call(holder, key, value); }\n\t\t\n\t\tswitch (typeof value) {\n\t\t\tcase 'string':\n\t\t\t\treturn quote(value);\n\t\t\tcase 'number':\n\t\t\t\t// JSON numbers must be finite\n\t\t\t\treturn isFinite(value) ? String(value) : 'null';\n\t\t\tcase 'boolean':\n\t\t\t\treturn String(value);\n\t\t\tcase 'object': // object, array, date, null\n\t\t\t\tif (value === null) { return 'null'; } // typeof null == 'object'\n\t\t\t\tif (value.constructor === Date) { return exports.stringifyDate(value); }\n\t\t\t\n\t\t\t\tgap += indent;\n\t\t\t\tvar partial = [];\n\t\t\t\t\n\t\t\t\t// Is the value an array?\n\t\t\t\tif (value.constructor === Array) {\n\t\t\t\t\tvar length = value.length;\n\t\t\t\t\tfor (var i = 0; i < length; i += 1) {\n\t\t\t\t\t\tpartial[i] = str(i, value) || 'null';\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Join all of the elements together, separated with commas, and wrap them in brackets.\n\t\t\t\t\tvar v = partial.length === 0 ? '[]' :\n\t\t\t\t\t\tgap ? '[\\n' + gap +\n\t\t\t\t\t\t\t\tpartial.join(',\\n' + gap) + '\\n' +\n\t\t\t\t\t\t\t\t\tmind + ']' :\n\t\t\t\t\t\t\t  '[' + partial.join(',') + ']';\n\t\t\t\t\tgap = mind;\n\t\t\t\t\treturn v;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (rep && typeof rep === 'object') { // rep is an array\n\t\t\t\t\tvar length = rep.length;\n\t\t\t\t\tfor (var i = 0; i < length; i += 1) {\n\t\t\t\t\t\tvar k = rep[i];\n\t\t\t\t\t\tif (typeof k === 'string') {\n\t\t\t\t\t\t\tvar v = str(k, value);\n\t\t\t\t\t\t\tif (v) {\n\t\t\t\t\t\t\t\tpartial.push(quote(k) + (gap ? ': ' : ':') + v);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else { // iterate through all of the keys in the object.\n\t\t\t\t\tfor (var k in value) {\n\t\t\t\t\t\tif (Object.hasOwnProperty.call(value, k)) {\n\t\t\t\t\t\t\tvar v = str(k, value);\n\t\t\t\t\t\t\tif (v) {\n\t\t\t\t\t\t\t\tpartial.push(quote(k) + (gap ? ': ' : ':') + v);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Join all of the member texts together, separated with commas,\n\t\t\t\t// and wrap them in braces.\n\t\t\t\tvar v = partial.length === 0 ? '{}' :\n\t\t\t\t\tgap ? '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' +\n\t\t\t\t\t\t\tmind + '}' : '{' + partial.join(',') + '}';\n\t\t\t\tgap = mind;\n\t\t\t\treturn v;\n\t\t}\n\t}\n\n\n\t/**\n\t * The stringify method takes a value and an optional replacer, and an optional\n\t * space parameter, and returns a JSON text. The replacer can be a function\n\t * that can replace values, or an array of strings that will select the keys.\n \t * A default replacer method can be provided. Use of the space parameter can\n\t * produce text that is more easily readable.\n\t */\n\texports.stringify = function (value, replacer, space) {\n\t\tgap = '';\n\t\tindent = '';\n\t\t\n\t\t// If the space parameter is a number, make an indent string containing that many spaces.\n\t\tif (typeof space === 'number') {\n\t\t\tfor (var i = 0; i < space; i += 1) {\n\t\t\t\tindent += ' ';\n\t\t\t}\n\t\t} else if (typeof space === 'string') {\n\t\t\tindent = space;\n\t\t}\n\t\t\n\t\t// If there is a replacer, it must be a function or an array.\n\t\trep = replacer;\n\t\tif (replacer && typeof replacer !== 'function' &&\n\t\t\t\t(typeof replacer !== 'object' ||\n\t\t\t\t typeof replacer.length !== 'number')) {\n\t\t\tthrow new Error('JSON stringify: invalid replacer');\n\t\t}\n\t\t\n\t\t// Make a fake root object containing our value under the key of ''.\n\t\t// Return the result of stringifying the value.\n\t\treturn str('', {'': value});\n\t};\n\t\n\texports.stringifyDate = function(d) {\n\t\tvar year = d.getUTCFullYear(),\n\t\t\tmonth = d.getUTCMonth() + 1,\n\t\t\tday = d.getUTCDate(),\n\t\t\thours = d.getUTCHours(),\n\t\t\tminutes = d.getUTCMinutes(),\n\t\t\tseconds = d.getUTCSeconds(),\n\t\t\tms = d.getUTCMilliseconds();\n\t\t\n\t\tif (month < 10) { month = '0' + month; }\n\t\tif (day < 10) { day = '0' + day; }\n\t\tif (hours < 10) { hours = '0' + hours; }\n\t\tif (minutes < 10) { minutes = '0' + minutes; }\n\t\tif (seconds < 10) { seconds = '0' + seconds; }\n\t\tif (ms < 10) { ms = '00' + ms; }\n\t\telse if (ms < 100) { ms = '0' + ms; }\n\n\t\treturn '\"' + year\n\t\t\t+ '-' + month\n\t\t\t+ '-' + day\n\t\t\t+ 'T' + hours\n\t\t\t+ ':' + minutes\n\t\t\t+ ':' + seconds\n\t\t\t+ '.' + ms\n\t\t\t+ 'Z\"';\n\t}\n\t\n\t/**\n\t * The parse method takes a text and an optional reviver function, and returns\n\t * a JavaScript value if the text is a valid JSON text.\n\t */\n\texports.parse = function (text, reviver) {\n\t\t// Parsing happens in four stages. In the first stage, we replace certain\n\t\t// Unicode characters with escape sequences. JavaScript handles many characters\n\t\t// incorrectly, either silently deleting them, or treating them as line endings.\n\t\tcx.lastIndex = 0;\n\t\tif (cx.test(text)) {\n\t\t\ttext = text.replace(cx, function (a) {\n\t\t\t\treturn '\\\\u' +\n\t\t\t\t\t('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n\t\t\t});\n\t\t}\n\t\t\n\t\t// In the second stage, we run the text against regular expressions that look\n\t\t// for non-JSON patterns. We are especially concerned with '()' and 'new'\n\t\t// because they can cause invocation, and '=' because it can cause mutation.\n\t\t// But just to be safe, we want to reject all unexpected forms.\n\n\t\t// We split the second stage into 4 regexp operations in order to work around\n\t\t// crippling inefficiencies in IE's and Safari's regexp engines. First we\n\t\t// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we\n\t\t// replace all simple value tokens with ']' characters. Third, we delete all\n\t\t// open brackets that follow a colon or comma or that begin the text. Finally,\n\t\t// we look to see that the remaining characters are only whitespace or ']' or\n\t\t// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.\n\n\t\tif (/^[\\],:{}\\s]*$/\n\t\t\t\t.test(text.replace(/\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')\n\t\t\t\t.replace(/\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g, ']')\n\t\t\t\t.replace(/(?:^|:|,)(?:\\s*\\[)+/g, '')))\n\t\t{\n\t\t\tvar j = eval('(' + text + ')');\n\t\t\tif(!reviver) {\n\t\t\t\treturn j;\n\t\t\t} else {\n\t\t\t\t// In the optional fourth stage, we recursively walk the new structure, passing\n\t\t\t\t// each name/value pair to a reviver function for possible transformation.\n\t\t\t\tvar walk = function(holder, key) {\n\t\t\t\t\t// The walk method is used to recursively walk the resulting structure so\n\t\t\t\t\t// that modifications can be made.\n\t\t\t\t\tvar k, v, value = holder[key];\n\t\t\t\t\tif (value && typeof value === 'object') {\n\t\t\t\t\t\tfor (k in value) {\n\t\t\t\t\t\t\tif (Object.hasOwnProperty.call(value, k)) {\n\t\t\t\t\t\t\t\tv = walk(value, k);\n\t\t\t\t\t\t\t\tif (v !== undefined) {\n\t\t\t\t\t\t\t\t\tvalue[k] = v;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tdelete value[k];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn reviver.call(holder, key, value);\n\t\t\t\t}\n\t\t\t\treturn walk({'': j}, '');\n\t\t\t}\n\t\t}\n\n\t\t// If the text is not JSON parseable, then a SyntaxError is thrown.\n\t\tthrow new SyntaxError('JSON.parse');\n\t};\n}());");
jsio.setCachedSrc("../../packages/net/env/browser/iframe.js","\njsio(\"import net.interfaces;\");\njsio(\"from util.browser import $;\");\n\nfunction findFrame() {\n\tvar target = window;\n\tif (top == target) { return ''; }\n\n\tvar path = [],\n\t\tsearch = function(win) {\n\t\t\tfor (var i = 0, len = win.length; i < len; ++i) {\n\t\t\t\tif (win[i] == target || search(win[i])) {\n\t\t\t\t\tpath.unshift(i);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tsearch(top);\n\treturn path.join('-');\n}\n\nfunction findTarget(target) {\n\ttry {\n\t\tvar path = target.split('-'),\n\t\t\ttarget = top;\n\t\tfor (var i = 0, j; j = path[i]; ++i) { target = target[j]; }\n\t\treturn target && target.postMessage ? target : null;\n\t} catch(e) {\n\t\tlogger.error(e, 'Could not find iframe target:', target, '(possibly a security error)');\n\t\treturn null;\n\t}\n}\n\nexports.Listener = Class(net.interfaces.Listener, function(supr) {\n\tvar ID = 0;\n\t\n\tvar tabStyle = {\n\t\tbackground: '#442',\n\t\tborder: '1px solid #885',\n\t\tmargin: '0px 0px -1px 3px',\n\t\tMozBorderRadius: '3px 0px 0px 3px',\n\t\tWebkitBorderRadius: '3px 0px 0px 3px',\n\t\tboxSizing: 'border-box',\n\t\tborderRightWidth: '0px',\n\t\tpadding: '2px 0px 2px 5px',\n\t\tcursor: 'pointer'\n\t};\n\t\n\tthis.init = function(server, opts) {\n\t\tsupr(this, 'init', arguments);\n\t\tthis._clients = {};\n\t\tthis._opts = opts;\n\t\tthis._numTabs = 0;\n\t\tthis._frames = [];\n\t}\n\t\n\tthis.buildTabUI = function() {\n\t\t\n\t\t$.style(document.documentElement, {\n\t\t\toverflow: 'hidden',\n\t\t\tmargin: '0px',\n\t\t\tpadding: '0px',\n\t\t\twidth: '100%',\n\t\t\theight: '100%'\n\t\t});\n\t\t\n\t\t$.style(document.body, {\n\t\t\tmargin: '0px',\n\t\t\tpadding: '0px',\n\t\t\twidth: '100%',\n\t\t\theight: '100%'\n\t\t});\n\t\t\n\t\t$.onEvent(window, 'resize', this, 'onResize');\n\t\t\n\t\tthis._leftCol = $({\n\t\t\tstyle: {\n\t\t\t\tposition: 'absolute',\n\t\t\t\ttop: '0px',\n\t\t\t\tleft: '0px',\n\t\t\t\twidth: '150px',\n\t\t\t\theight: '100%',\n\t\t\t\toverflow: 'hidden',\n\t\t\t\tpaddingTop: '5px',\n\t\t\t\tbackground: '#444',\n\t\t\t\tfontWeight: 'bold',\n\t\t\t\tcolor: '#EEA'\n\t\t\t},\n\t\t\tparent: document.body\n\t\t});\n\t\t\n\t\tthis._rightCol = $({\n\t\t\tstyle: {\n\t\t\t\tposition: 'absolute',\n\t\t\t\ttop: '0px',\n\t\t\t\tright: '0px',\n\t\t\t\theight: '100%',\n\t\t\t\tbackground: '#EEE',\n\t\t\t\tboxSizing: 'border-box',\n\t\t\t\tborder: '1px solid #CCC',\n\t\t\t\tborderWidth: '0px 1px',\n\t\t\t\toverflowX: 'hidden',\n\t\t\t\toverflowY: 'auto'\n\t\t\t},\t\n\t\t\tparent: document.body\n\t\t});\n\t\t\n\t\tthis._serverContent = $({\n\t\t\tstyle: {\n\t\t\t\tposition: 'absolute',\n\t\t\t\ttop: '0px',\n\t\t\t\tright: '0px',\n\t\t\t\twidth: '100%',\n\t\t\t\theight: '100%',\n\t\t\t\tboxSizing: 'border-box',\n\t\t\t\tpadding: '10px'\n\t\t\t},\n\t\t\tparent: this._rightCol\n\t\t});\n\t\t\n\t\tvar el = this.createTab('server');\n\t\t$.onEvent(el, 'click', this, 'showFrame', this._serverContent);\n\t\t\n\t\tif (this._opts && this._opts.clientURL) {\n\t\t\tvar el = this.createTab('+ client', 1);\n\t\t\t$.onEvent(el, 'click', this, 'onNewTabClick');\n\t\t\tthis._lastTab = el;\n\t\t}\n\t\t\n\t\tthis.onResize();\n\t\t\n\t\treturn this._serverContent;\n\t}\n\t\n\tthis.findFrame = function() { return findFrame(); }\n\t\n\tthis.getDOM = function() { return this._serverContent; }\n\t\n\tthis.onResize = function() {\n\t\tthis._rightCol.style.width = $(window).width - 150 + 'px';\n\t}\n\t\n\tthis.createTab = function(text, indent) {\n\t\tvar el = $({\n\t\t\tstyle: tabStyle\n\t\t});\n\t\t\n\t\t$.style(el, { marginLeft: (indent || 0) * 10 + 'px' });\n\t\t\n\t\tel.text = $({\n\t\t\ttext: text,\n\t\t\tparent: el\n\t\t});\n\t\t\n\t\tvar status = $({\n\t\t\tstyle: { 'float': 'right' },\n\t\t\tbefore: el.text\n\t\t});\n\t\t\n\t\tel.status = function(text) { $.setText(status, text); }\n\t\t\n\t\tif (this._lastTab) {\n\t\t\tthis._leftCol.insertBefore(el, this._lastTab);\n\t\t} else {\n\t\t\tthis._leftCol.appendChild(el);\n\t\t}\n\t\t\n\t\t$.onEvent(el, 'mouseover', bind($, $.style, el, {background: '#664'}));\n\t\t$.onEvent(el, 'mouseout', bind($, $.style, el, {background: '#442'}));\n\t\t$.onEvent(el, 'mousedown', bind($, $.style, el, {background: '#111'}));\n\t\t$.onEvent(el, 'mouseup', bind($, $.style, el, {background: '#442'}));\n\t\treturn el;\n\t}\n\t\n\tthis.createCloseableTab = function(text, indent, url) {\n\t\tif (url) {\n\t\t\tvar el = this.newTab(url, text, indent)\n\t\t} else {\n\t\t\tvar el = this.createTab(text, indent);\n\t\t}\n\t\t\n\t\tel.close = $({\n\t\t\ttext: 'X',\n\t\t\tstyle: {\n\t\t\t\t'float': 'right',\n\t\t\t\t'border': '1px solid #AAF',\n\t\t\t\t'background': '#000',\n\t\t\t\t'padding': '1px'\n\t\t\t},\n\t\t\tbefore:el.firstChild\n\t\t});\n\t\t\n\t\treturn el;\n\t}\n\t\n\tthis.onNewTabClick = function() { this.newTab(); }\n\t\n\tthis.newTab = function(url, text, indent) {\n\t\t++this._numTabs;\n\t\tvar text = text || this._numTabs;\n\t\tvar el = this.createTab(text, indent);\n\t\tel.status('loading...');\n\t\t\n\t\tvar frame = $({\n\t\t\ttag: 'iframe',\n\t\t\tattrs: {\n\t\t\t\tborder: 0,\n\t\t\t\tname: 'tab' + this._numTabs\n\t\t\t},\n\t\t\tstyle: {\n\t\t\t\tposition: 'absolute',\n\t\t\t\tleft: '200%',\n\t\t\t\twidth: '100%',\n\t\t\t\theight: '100%',\n\t\t\t\tborderWidth: '0px'\n\t\t\t}\n\t\t});\n\t\t\n\t\tframe.src = url || this._opts.clientURL;\n\t\tthis._rightCol.appendChild(frame);\n\t\t\n\t\tframe.onload = bind(this, 'onFrameLoad', frame, el);\n\t\tthis._frames.push(frame);\n\t\t\n\t\tel._frame = frame;\n\t\t$.onEvent(el, 'click', this, 'showFrame', frame);\n\t\t\n\t\tel.reload = $({\n\t\t\ttext: 'R',\n\t\t\tstyle: {\n\t\t\t\t'float': 'right',\n\t\t\t\t'border': '1px solid #AAF',\n\t\t\t\t'background': '#000',\n\t\t\t\t'padding': '1px'\n\t\t\t},\n\t\t\tbefore: el.firstChild\n\t\t});\n\t\t\n\t\t$.onEvent(el.reload, 'click', function() {\n\t\t\tel.status('loading...');\n\t\t\tframe.contentWindow.location.reload(true);\n\t\t});\n\t\t\n\t\tthis.onResize();\n\t\treturn el;\n\t}\n\t\n\tthis.onFrameLoad = function(frame, el, text) {\n\t\tthis.showFrame(frame);\n\t\tel.status('');\n\t}\n\t\n\tthis.showFrame = function(frame) {\n\t\tif (this._currentFrame) { $.style(this._currentFrame, {left: '200%'}); }\n\t\tthis._currentFrame = frame;\n\t\t$.style(frame, {left: '0%'});\n\t}\n\t\n\tthis.listen = function() {\n\t\t$.onEvent(window, 'message', bind(this, '_onMessage'));\n\t}\n\t\n\tthis._onMessage = function(evt) {\n\t\tvar name = evt.source.name,\n\t\t\ttarget = this._clients[name],\n\t\t\tdata = evt.data;\n\t\t\n\t\tif (!/^iS>/.test(data)) { return; }\n\t\t\n\t\tdata = eval('(' + data.substring(3) + ')');\n\t\tswitch (data.type) {\n\t\t\tcase 'open':\n\t\t\t\tthis._clients[name] = new exports.Transport(evt.source, 'iC<');\n\t\t\t\tevt.source.postMessage('iC<{type:\"open\"}','*');\n\t\t\t\tthis.onConnect(this._clients[name]);\n\t\t\t\tbreak;\n\t\t\tcase 'data':\n\t\t\t\ttarget.onData(data.payload);\n\t\t\t\tbreak;\n\t\t\tcase 'close':\n\t\t\t\ttarget.onClose();\n\t\t\t\tevt.source.postMessage('iC<{type:\"close\"}','*');\n\t\t\t\tdelete this._clients[name];\n\t\t\t\tbreak;\n\t\t}\n\t}\n});\n\nexports.Connector = Class(net.interfaces.Connector, function() {\n\tthis.connect = function() {\n\t\tvar target;\n\t\tif (this._opts.target) {\n\t\t\ttarget = findTarget(this._opts.target);\n\t\t} else {\n\t\t\ttarget = top;\n\t\t}\n\t\t\n\t\tvar self = findFrame();\n\t\t$.onEvent(window, 'message', bind(this, '_onMessage'));\n\t\ttarget.postMessage('iS>{\"type\":\"open\"}', '*');\n\t}\n\t\n\tthis._onMessage = function(evt) {\n\t\tvar data = evt.data;\n\t\tif (!/^iC</.test(data)) { return; }\n\t\t\n\t\tdata = eval('(' + data.substring(3) + ')');\n\t\tswitch(data.type) {\n\t\t\tcase 'open':\n\t\t\t\tthis._transport = new exports.Transport(evt.source, 'iS>');\n\t\t\t\tthis.onConnect(this._transport);\n\t\t\t\tbreak;\n\t\t\tcase 'close':\n\t\t\t\tthis._transport.onClose();\n\t\t\t\tbreak;\n\t\t\tcase 'data':\n\t\t\t\tthis._transport.onData(data.payload);\n\t\t\t\tbreak;\n\t\t}\n\t}\n});\n\nexports.Transport = Class(net.interfaces.Transport, function() {\n\tthis.init = function(win, prefix) {\n\t\tthis._win = win;\n\t\tthis._prefix = prefix;\n\t}\n\t\n\tthis.makeConnection = function(protocol) {\n\t\tthis._protocol = protocol;\n\t}\n\t\n\tthis.write = function(data, encoding) {\n\t\tif (this.encoding == 'utf8') {\n\t\t\tthis._win.postMessage(this._prefix + JSON.stringify({type: 'data', payload: utf8.encode(data)}), '*');\n\t\t} else {\n\t\t\tthis._win.postMessage(this._prefix + JSON.stringify({type: 'data', payload: data}), '*');\n\t\t}\n\t}\n\t\n\tthis.loseConnection = function(protocol) {\n\t\tthis._win.postMessage(JSON.stringify({type: 'close', code: 301}), '*');\n\t}\n\t\n\tthis.onData = function() {\n\t\tthis._protocol.dataReceived.apply(this._protocol, arguments);\n\t}\n\t\n\tthis.onClose = function() { this._protocol._connectionLost.apply(this._protocol, arguments); }\n});\n");
jsio.setCachedSrc("../../packages/util/browser.js","if (jsio.__env.name == 'browser') {\n\tjsio('external .sizzle import Sizzle');\n\tjsio('import math2D.Rect');\n\t\n\tfunction isWindow(el) {\n\t\treturn el && !$.isElement(el) && $.isElement(el.document);\n\t}\n\t\n\tvar singleId = /^#([\\w-]+)$/;\n\t\n\tvar $ = exports.$ = function(selector, win) {\n\t\tswitch(typeof selector) {\n\t\t\tcase 'object':\n\t\t\t\tif ($.isElement(selector)) {\n\t\t\t\t\treturn $.remove(selector);\n\t\t\t\t} else if ($.isElement(selector.document && selector.document.body)) {\n\t\t\t\t\treturn $.size(selector);\n\t\t\t\t}\n\t\t\t\treturn $.create(selector);\n\t\t\tcase 'string':\n\t\t\t\tif (singleId.test(selector)) { return $.id(selector.substring(1), win); }\n\t\t\t\treturn Sizzle.apply(GLOBAL, arguments);\n\t\t}\n\t}\n\t\n\tvar DOM2 = typeof HTMLElement === \"object\";\n\t$.isElement = DOM2\n\t\t? function(el) { return el && el instanceof HTMLElement; }\n\t\t: function(el) { return el && typeof el.nodeType == 'number' && typeof el.nodeName == 'string' };\n\t\n\t$.id = function(id, win) { return typeof id == 'string' ? (win || window).document.getElementById(id) : id; }\n\n\t$.apply = function(el, params) {\n\t\tif (params.attrs) {\n\t\t\tfor(attr in params.attrs) {\n\t\t\t\tel.setAttribute(attr, params.attrs[attr]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (params.id) { el.id = params.id; }\n\t\tif (params.style) { $.style(el, params.style); }\n\t\tif (params.src) { el.src = params.src; }\n\t\tif (params['class'] || params['className']) {\n\t\t\tel.className = params['class'] || params['className'];\n\t\t}\n\t\t\n\t\tvar parent = params.parent || params.parentNode;\n\t\tif (parent && params.first) {\n\t\t\t$.insertBefore(parent, el, parent.firstChild);\n\t\t} else if (params.before) {\n\t\t\t$.insertBefore(params.before.parentNode || parent, el, params.before);\n\t\t} else if (params.after) {\n\t\t\t$.insertAfter(params.after.parentNode || parent, el, params.after);\n\t\t} else if (parent) {\n\t\t\tparent.appendChild(el);\n\t\t}\n\t\t\n\t\tif ('html' in params) { el.innerHTML = params.html; }\n\t\tif ('text' in params) { $.setText(el, params.text); }\n\t\t\n\t\tif (params.children) {\n\t\t\tvar c = params.children;\n\t\t\tfor (var i = 0, n = c.length; i < n; ++i) {\n\t\t\t\tel.appendChild($.isElement(c[i]) ? c[i] : $(c[i]));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn el;\n\t}\n\t\n\t$.insertBefore = function(parentNode, el, beforeNode) {\n\t\tif (!parentNode || !el) { return; }\n\t\tif (beforeNode && beforeNode.parentNode == parentNode) {\n\t\t\tparentNode.insertBefore(el, beforeNode);\n\t\t} else {\n\t\t\tparentNode.appendChild(el);\n\t\t}\n\t}\n\t\n\t$.insertAfter = function(parentNode, el, afterNode) {\n\t\tif (!parentNode || !el) { return; }\n\t\tif (!afterNode || afterNode.parentNode != parentNode) {\n\t\t\t$.insertBefore(parentNode, el, parentNode.firstChild);\n\t\t} else if (!afterNode.nextSibling) {\n\t\t\tparentNode.appendChild(el);\n\t\t} else {\n\t\t\tparentNode.insertBefore(el, afterNode.nextSibling);\n\t\t}\n\t}\n\n\t$.create = function(params) {\n\t\tvar doc = ((params && params.win) || window).document;\n\t\tif (!params || typeof params == 'string') {\n\t\t\treturn doc.createElement(params || 'div');\n\t\t};\n\n\t\treturn $.apply(params.el || doc.createElement(params.tag || params.tagName || 'div'), params);\n\t}\n\n\t$.show = function(el, how) { $.id(el).style.display = how || 'block'; }\n\t$.hide = function(el) { $.id(el).style.display = 'none'; }\n\n\t// accepts an array or a space-delimited string of classNames\n\t$.addClass = function(el, classNames) {\n\t\tif (!el) { return; }\n\t\tvar el = $.id(el);\n\t\tif(typeof classNames == \"string\") {\n\t\t\tclassNames = classNames.split(' ');\n\t\t}\n\t\n\t\tvar current = ' ' + el.className + ' ';\n\t\tfor(var i = 0, len = classNames.length, c; (c = classNames[i]) || i < len; ++i) {\n\t\t\tif(current.indexOf(' '+c+' ') == -1) {\n\t\t\t\tcurrent += c + ' ';\n\t\t\t}\n\t\t}\n\t\n\t\tel.className = current;\n\t\treturn $;\n\t}\n\t\n\t$.getTag = function(from, tag) { return from.getElementsByTagName(tag); }\n\n\t$.removeClass = function(el, classNames) {\n\t\tif (!el) { return; }\n\t\tvar el = $.id(el);\n\t\tel.className = (' ' + el.className + ' ')\n\t\t\t.replace(' ', '  ')\n\t\t\t.replace(new RegExp('( ' + classNames.replace('\\s+', ' | ').replace('-','\\-') + ' )', 'g'), '')\n\t\t\t.replace(/\\s+/, ' ')\n\t\t\t.replace(/^\\s+|\\s+%/, '');\n\t}\n\n\tfunction ieGetAlpha(el) {\n\t\ttry {\n\t\t\treturn el.filters.item(\"alpha\");\n\t\t} catch(e) {}\n\t\n\t\ttry {\n\t\t\treturn el.filters.item(\"progid:DXImageTransform.Microsoft.Alpha\");\n\t\t} catch(e) {}\n\t\n\t\treturn null;\n\t}\n\n\t$.style = function(el, style) {\n\t\tif(el instanceof Array) {\n\t\t\tfor(var i = 0, o; o = el[i]; ++i) { $.style(o, style); }\n\t\t\treturn;\n\t\t}\n\t\n\t\tel = $.id(el);\n\t\tvar s = el.style;\n\t\tfor(prop in style) {\n\t\t\tswitch(prop) {\n\t\t\t\tcase 'styleFloat':\n\t\t\t\tcase 'cssFloat':\n\t\t\t\tcase 'float':\n\t\t\t\t\ts.styleFloat = s.cssFloat = style[prop];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'opacity':\n\t\t\t\t\ts.opacity = style[prop];\n\t\t\t\t\tif(el.filters) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tvar alpha = ieGetAlpha();\n\t\t\t\t\t\t\tvar opacity = style[prop] == 1 ? 99.99 : style[prop] * 100;\n\t\t\t\t\t\t\tif(!alpha) {\n\t\t\t\t\t\t\t\t// TODO: this might destroy any existing filters?\n\t\t\t\t\t\t\t\ts.filter = \"alpha(opacity=\" + opacity + \")\";\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\talpha.Opacity = opacity;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch(e) {}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'borderRadius':\n\t\t\t\t\ts.borderRadius = s.MozBorderRadius = style[prop];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'boxSizing':\n\t\t\t\t\ts.MsBoxSizing = s.MozBoxSizing = s.WebkitBoxSizing = style[prop];\n\t\t\t\tdefault:\n\t\t\t\t\ts[prop] = style[prop];\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t};\n\n\t$.onEvent = function(el, name, f) {\n\t\tif (typeof f != 'function') {\n\t\t\tf = bind.apply(GLOBAL, Array.prototype.slice.call(arguments, 2));\n\t\t}\n\t\n\t\tvar handler = f;\n\t\n\t\tel = $.id(el);\n\t\tif(el.addEventListener) { \n\t\t\tel.addEventListener(name, handler, false);\n\t\t} else {\n\t\t\thandler = function(e) {\n\t\t\t\tvar evt = e || window.event;\n\t\t\t\t// TODO: normalize the event object\n\t\t\t\tf(evt);\n\t\t\t};\n\t\t\n\t\t\tel.attachEvent('on' + name, handler);\n\t\t}\n\t\n\t\treturn bind($, 'removeEvent', el, name, handler);\n\t};\n\n\t$.removeEvent = function(el, name, f) {\n\t\tel = $.id(el);\n\t\tif (el.addEventListener) {\n\t\t\tel.removeEventListener(name, f, false);\n\t\t} else {\n\t\t\tel.detachEvent('on' + name, f);\n\t\t}\n\t}\n\n\t$.stopEvent = function(e) {\n\t\tif (e) {\n\t\t\te.cancelBubble = true;\n\t\t\tif(e.stopPropagation) e.stopPropagation();\n\t\t\tif(e.preventDefault) e.preventDefault();\n\t\t}\n\t}\n\n\t$.setText = function(el, text) {\n\t\tel = $.id(el);\n\t\ttext = String(text);\n\t\tif ('textContent' in el) {\n\t\t\tel.textContent = text;\n\t\t} else if ('innerText' in el) {\n\t\t\tel.innerText = text.replace(/\\n/g, ' ');\n\t\t} else {\n\t\t\tel.innerHTML = '';\n\t\t\tel.appendChild(document.createTextNode(text));\n\t\t}\n\t}\n\n\t$.remove = function(el) {\n\t\tel = $.id(el);\n\t\tif(el && el.parentNode) {\n\t\t\tel.parentNode.removeChild(el);\n\t\t}\n\t}\n\n\t$.cursorPos = function(ev, el) {\n\t\tvar offset = $.pos(el);\n\t\toffset.top = ev.clientY - offset.top + (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop);\n\t\toffset.left = ev.clientX - offset.left + (window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft);\n\t\treturn offset;\n\t}\n\n\t$.pos = function(el) {\n\t\tvar parent = el;\n\t\tvar offset = {top: 0, left: 0};\n\t\twhile(parent && parent != document.body) {\n\t\t\toffset.left += parent.offsetLeft;\n\t\t\toffset.top += parent.offsetTop;\n\t\t\twhile(parent.offsetParent != parent.parentNode) {\n\t\t\t\toffset.top -= parent.scrollTop; offset.left -= parent.scrollLeft;\n\t\t\t\tparent = parent.parentNode;\n\t\t\t}\n\t\t\tparent = parent.offsetParent;\n\t\t}\n\t\treturn offset;\n\t}\n\t\n\t$.size = function(el) {\n\t\tif ($.isElement(el)) {\n\t\t\treturn {width: el.offsetWidth, height: el.offsetHeight};\n\t\t} else if (el.document) {\n\t\t\tvar doc = el.document.documentElement || el.document.body;\n\t\t\treturn new math2D.Rect(\n\t\t\t\tdoc.offsetTop,\n\t\t\t\tdoc.offsetLeft,\n\t\t\t\tel.innerWidth || (doc.clientWidth || doc.clientWidth),\n\t\t\t\tel.innerHeight || (doc.clientHeight || doc.clientHeight)\n\t\t\t);\n\t\t}\n\t}\n\t\n\t$.insertCSSFile = function(filename) {\n\t\tdocument.getElementsByTagName('head')[0].appendChild($({\n\t\t\ttag: 'link',\n\t\t\tattrs: {\n\t\t\t\trel: 'stylesheet',\n\t\t\t\ttype: 'text/css',\n\t\t\t\thref: filename\n\t\t\t}\n\t\t}));\n\t}\n}\n");
jsio.setCachedSrc("../../packages/util/sizzle.js",'/*!\n * Sizzle CSS Selector Engine - v1.0\n *  Copyright 2009, The Dojo Foundation\n *  Released under the MIT, BSD, and GPL Licenses.\n *  More information: http://sizzlejs.com/\n */\n\nSizzle = (function(){\n\nvar chunker = /((?:\\((?:\\([^()]+\\)|[^()]+)+\\)|\\[(?:\\[[^[\\]]*\\]|[\'"][^\'"]*[\'"]|[^[\\]\'"]+)+\\]|\\\\.|[^ >+~,(\\[\\\\]+)+|[>+~])(\\s*,\\s*)?/g,\n\tdone = 0,\n\ttoString = Object.prototype.toString,\n\thasDuplicate = false;\n\nvar Sizzle = function(selector, context, results, seed) {\n\tresults = results || [];\n\tvar origContext = context = context || document;\n\n\tif ( context.nodeType !== 1 && context.nodeType !== 9 ) {\n\t\treturn [];\n\t}\n\t\n\tif ( !selector || typeof selector !== "string" ) {\n\t\treturn results;\n\t}\n\n\tvar parts = [], m, set, checkSet, check, mode, extra, prune = true, contextXML = isXML(context);\n\t\n\t// Reset the position of the chunker regexp (start from head)\n\tchunker.lastIndex = 0;\n\t\n\twhile ( (m = chunker.exec(selector)) !== null ) {\n\t\tparts.push( m[1] );\n\t\t\n\t\tif ( m[2] ) {\n\t\t\textra = RegExp.rightContext;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ( parts.length > 1 && origPOS.exec( selector ) ) {\n\t\tif ( parts.length === 2 && Expr.relative[ parts[0] ] ) {\n\t\t\tset = posProcess( parts[0] + parts[1], context );\n\t\t} else {\n\t\t\tset = Expr.relative[ parts[0] ] ?\n\t\t\t\t[ context ] :\n\t\t\t\tSizzle( parts.shift(), context );\n\n\t\t\twhile ( parts.length ) {\n\t\t\t\tselector = parts.shift();\n\n\t\t\t\tif ( Expr.relative[ selector ] )\n\t\t\t\t\tselector += parts.shift();\n\n\t\t\t\tset = posProcess( selector, set );\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Take a shortcut and set the context if the root selector is an ID\n\t\t// (but not if it\'ll be faster if the inner selector is an ID)\n\t\tif ( !seed && parts.length > 1 && context.nodeType === 9 && !contextXML &&\n\t\t\t\tExpr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1]) ) {\n\t\t\tvar ret = Sizzle.find( parts.shift(), context, contextXML );\n\t\t\tcontext = ret.expr ? Sizzle.filter( ret.expr, ret.set )[0] : ret.set[0];\n\t\t}\n\n\t\tif ( context ) {\n\t\t\tvar ret = seed ?\n\t\t\t\t{ expr: parts.pop(), set: makeArray(seed) } :\n\t\t\t\tSizzle.find( parts.pop(), parts.length === 1 && (parts[0] === "~" || parts[0] === "+") && context.parentNode ? context.parentNode : context, contextXML );\n\t\t\tset = ret.expr ? Sizzle.filter( ret.expr, ret.set ) : ret.set;\n\n\t\t\tif ( parts.length > 0 ) {\n\t\t\t\tcheckSet = makeArray(set);\n\t\t\t} else {\n\t\t\t\tprune = false;\n\t\t\t}\n\n\t\t\twhile ( parts.length ) {\n\t\t\t\tvar cur = parts.pop(), pop = cur;\n\n\t\t\t\tif ( !Expr.relative[ cur ] ) {\n\t\t\t\t\tcur = "";\n\t\t\t\t} else {\n\t\t\t\t\tpop = parts.pop();\n\t\t\t\t}\n\n\t\t\t\tif ( pop == null ) {\n\t\t\t\t\tpop = context;\n\t\t\t\t}\n\n\t\t\t\tExpr.relative[ cur ]( checkSet, pop, contextXML );\n\t\t\t}\n\t\t} else {\n\t\t\tcheckSet = parts = [];\n\t\t}\n\t}\n\n\tif ( !checkSet ) {\n\t\tcheckSet = set;\n\t}\n\n\tif ( !checkSet ) {\n\t\tthrow "Syntax error, unrecognized expression: " + (cur || selector);\n\t}\n\n\tif ( toString.call(checkSet) === "[object Array]" ) {\n\t\tif ( !prune ) {\n\t\t\tresults.push.apply( results, checkSet );\n\t\t} else if ( context && context.nodeType === 1 ) {\n\t\t\tfor ( var i = 0; checkSet[i] != null; i++ ) {\n\t\t\t\tif ( checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && contains(context, checkSet[i])) ) {\n\t\t\t\t\tresults.push( set[i] );\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor ( var i = 0; checkSet[i] != null; i++ ) {\n\t\t\t\tif ( checkSet[i] && checkSet[i].nodeType === 1 ) {\n\t\t\t\t\tresults.push( set[i] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tmakeArray( checkSet, results );\n\t}\n\n\tif ( extra ) {\n\t\tSizzle( extra, origContext, results, seed );\n\t\tSizzle.uniqueSort( results );\n\t}\n\n\treturn results;\n};\n\nSizzle.uniqueSort = function(results){\n\tif ( sortOrder ) {\n\t\thasDuplicate = false;\n\t\tresults.sort(sortOrder);\n\n\t\tif ( hasDuplicate ) {\n\t\t\tfor ( var i = 1; i < results.length; i++ ) {\n\t\t\t\tif ( results[i] === results[i-1] ) {\n\t\t\t\t\tresults.splice(i--, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nSizzle.matches = function(expr, set){\n\treturn Sizzle(expr, null, null, set);\n};\n\nSizzle.find = function(expr, context, isXML){\n\tvar set, match;\n\n\tif ( !expr ) {\n\t\treturn [];\n\t}\n\n\tfor ( var i = 0, l = Expr.order.length; i < l; i++ ) {\n\t\tvar type = Expr.order[i], match;\n\t\t\n\t\tif ( (match = Expr.match[ type ].exec( expr )) ) {\n\t\t\tvar left = RegExp.leftContext;\n\n\t\t\tif ( left.substr( left.length - 1 ) !== "\\\\" ) {\n\t\t\t\tmatch[1] = (match[1] || "").replace(/\\\\/g, "");\n\t\t\t\tset = Expr.find[ type ]( match, context, isXML );\n\t\t\t\tif ( set != null ) {\n\t\t\t\t\texpr = expr.replace( Expr.match[ type ], "" );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( !set ) {\n\t\tset = context.getElementsByTagName("*");\n\t}\n\n\treturn {set: set, expr: expr};\n};\n\nSizzle.filter = function(expr, set, inplace, not){\n\tvar old = expr, result = [], curLoop = set, match, anyFound,\n\t\tisXMLFilter = set && set[0] && isXML(set[0]);\n\n\twhile ( expr && set.length ) {\n\t\tfor ( var type in Expr.filter ) {\n\t\t\tif ( (match = Expr.match[ type ].exec( expr )) != null ) {\n\t\t\t\tvar filter = Expr.filter[ type ], found, item;\n\t\t\t\tanyFound = false;\n\n\t\t\t\tif ( curLoop == result ) {\n\t\t\t\t\tresult = [];\n\t\t\t\t}\n\n\t\t\t\tif ( Expr.preFilter[ type ] ) {\n\t\t\t\t\tmatch = Expr.preFilter[ type ]( match, curLoop, inplace, result, not, isXMLFilter );\n\n\t\t\t\t\tif ( !match ) {\n\t\t\t\t\t\tanyFound = found = true;\n\t\t\t\t\t} else if ( match === true ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( match ) {\n\t\t\t\t\tfor ( var i = 0; (item = curLoop[i]) != null; i++ ) {\n\t\t\t\t\t\tif ( item ) {\n\t\t\t\t\t\t\tfound = filter( item, match, i, curLoop );\n\t\t\t\t\t\t\tvar pass = not ^ !!found;\n\n\t\t\t\t\t\t\tif ( inplace && found != null ) {\n\t\t\t\t\t\t\t\tif ( pass ) {\n\t\t\t\t\t\t\t\t\tanyFound = true;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcurLoop[i] = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( pass ) {\n\t\t\t\t\t\t\t\tresult.push( item );\n\t\t\t\t\t\t\t\tanyFound = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( found !== undefined ) {\n\t\t\t\t\tif ( !inplace ) {\n\t\t\t\t\t\tcurLoop = result;\n\t\t\t\t\t}\n\n\t\t\t\t\texpr = expr.replace( Expr.match[ type ], "" );\n\n\t\t\t\t\tif ( !anyFound ) {\n\t\t\t\t\t\treturn [];\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Improper expression\n\t\tif ( expr == old ) {\n\t\t\tif ( anyFound == null ) {\n\t\t\t\tthrow "Syntax error, unrecognized expression: " + expr;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\told = expr;\n\t}\n\n\treturn curLoop;\n};\n\nvar Expr = Sizzle.selectors = {\n\torder: [ "ID", "NAME", "TAG" ],\n\tmatch: {\n\t\tID: /#((?:[\\w\\u00c0-\\uFFFF_-]|\\\\.)+)/,\n\t\tCLASS: /\\.((?:[\\w\\u00c0-\\uFFFF_-]|\\\\.)+)/,\n\t\tNAME: /\\[name=[\'"]*((?:[\\w\\u00c0-\\uFFFF_-]|\\\\.)+)[\'"]*\\]/,\n\t\tATTR: /\\[\\s*((?:[\\w\\u00c0-\\uFFFF_-]|\\\\.)+)\\s*(?:(\\S?=)\\s*([\'"]*)(.*?)\\3|)\\s*\\]/,\n\t\tTAG: /^((?:[\\w\\u00c0-\\uFFFF\\*_-]|\\\\.)+)/,\n\t\tCHILD: /:(only|nth|last|first)-child(?:\\((even|odd|[\\dn+-]*)\\))?/,\n\t\tPOS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\\((\\d*)\\))?(?=[^-]|$)/,\n\t\tPSEUDO: /:((?:[\\w\\u00c0-\\uFFFF_-]|\\\\.)+)(?:\\(([\'"]*)((?:\\([^\\)]+\\)|[^\\2\\(\\)]*)+)\\2\\))?/\n\t},\n\tattrMap: {\n\t\t"class": "className",\n\t\t"for": "htmlFor"\n\t},\n\tattrHandle: {\n\t\thref: function(elem){\n\t\t\treturn elem.getAttribute("href");\n\t\t}\n\t},\n\trelative: {\n\t\t"+": function(checkSet, part, isXML){\n\t\t\tvar isPartStr = typeof part === "string",\n\t\t\t\tisTag = isPartStr && !/\\W/.test(part),\n\t\t\t\tisPartStrNotTag = isPartStr && !isTag;\n\n\t\t\tif ( isTag && !isXML ) {\n\t\t\t\tpart = part.toUpperCase();\n\t\t\t}\n\n\t\t\tfor ( var i = 0, l = checkSet.length, elem; i < l; i++ ) {\n\t\t\t\tif ( (elem = checkSet[i]) ) {\n\t\t\t\t\twhile ( (elem = elem.previousSibling) && elem.nodeType !== 1 ) {}\n\n\t\t\t\t\tcheckSet[i] = isPartStrNotTag || elem && elem.nodeName === part ?\n\t\t\t\t\t\telem || false :\n\t\t\t\t\t\telem === part;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( isPartStrNotTag ) {\n\t\t\t\tSizzle.filter( part, checkSet, true );\n\t\t\t}\n\t\t},\n\t\t">": function(checkSet, part, isXML){\n\t\t\tvar isPartStr = typeof part === "string";\n\n\t\t\tif ( isPartStr && !/\\W/.test(part) ) {\n\t\t\t\tpart = isXML ? part : part.toUpperCase();\n\n\t\t\t\tfor ( var i = 0, l = checkSet.length; i < l; i++ ) {\n\t\t\t\t\tvar elem = checkSet[i];\n\t\t\t\t\tif ( elem ) {\n\t\t\t\t\t\tvar parent = elem.parentNode;\n\t\t\t\t\t\tcheckSet[i] = parent.nodeName === part ? parent : false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( var i = 0, l = checkSet.length; i < l; i++ ) {\n\t\t\t\t\tvar elem = checkSet[i];\n\t\t\t\t\tif ( elem ) {\n\t\t\t\t\t\tcheckSet[i] = isPartStr ?\n\t\t\t\t\t\t\telem.parentNode :\n\t\t\t\t\t\t\telem.parentNode === part;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( isPartStr ) {\n\t\t\t\t\tSizzle.filter( part, checkSet, true );\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t"": function(checkSet, part, isXML){\n\t\t\tvar doneName = done++, checkFn = dirCheck;\n\n\t\t\tif ( !/\\W/.test(part) ) {\n\t\t\t\tvar nodeCheck = part = isXML ? part : part.toUpperCase();\n\t\t\t\tcheckFn = dirNodeCheck;\n\t\t\t}\n\n\t\t\tcheckFn("parentNode", part, doneName, checkSet, nodeCheck, isXML);\n\t\t},\n\t\t"~": function(checkSet, part, isXML){\n\t\t\tvar doneName = done++, checkFn = dirCheck;\n\n\t\t\tif ( typeof part === "string" && !/\\W/.test(part) ) {\n\t\t\t\tvar nodeCheck = part = isXML ? part : part.toUpperCase();\n\t\t\t\tcheckFn = dirNodeCheck;\n\t\t\t}\n\n\t\t\tcheckFn("previousSibling", part, doneName, checkSet, nodeCheck, isXML);\n\t\t}\n\t},\n\tfind: {\n\t\tID: function(match, context, isXML){\n\t\t\tif ( typeof context.getElementById !== "undefined" && !isXML ) {\n\t\t\t\tvar m = context.getElementById(match[1]);\n\t\t\t\treturn m ? [m] : [];\n\t\t\t}\n\t\t},\n\t\tNAME: function(match, context, isXML){\n\t\t\tif ( typeof context.getElementsByName !== "undefined" ) {\n\t\t\t\tvar ret = [], results = context.getElementsByName(match[1]);\n\n\t\t\t\tfor ( var i = 0, l = results.length; i < l; i++ ) {\n\t\t\t\t\tif ( results[i].getAttribute("name") === match[1] ) {\n\t\t\t\t\t\tret.push( results[i] );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn ret.length === 0 ? null : ret;\n\t\t\t}\n\t\t},\n\t\tTAG: function(match, context){\n\t\t\treturn context.getElementsByTagName(match[1]);\n\t\t}\n\t},\n\tpreFilter: {\n\t\tCLASS: function(match, curLoop, inplace, result, not, isXML){\n\t\t\tmatch = " " + match[1].replace(/\\\\/g, "") + " ";\n\n\t\t\tif ( isXML ) {\n\t\t\t\treturn match;\n\t\t\t}\n\n\t\t\tfor ( var i = 0, elem; (elem = curLoop[i]) != null; i++ ) {\n\t\t\t\tif ( elem ) {\n\t\t\t\t\tif ( not ^ (elem.className && (" " + elem.className + " ").indexOf(match) >= 0) ) {\n\t\t\t\t\t\tif ( !inplace )\n\t\t\t\t\t\t\tresult.push( elem );\n\t\t\t\t\t} else if ( inplace ) {\n\t\t\t\t\t\tcurLoop[i] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t},\n\t\tID: function(match){\n\t\t\treturn match[1].replace(/\\\\/g, "");\n\t\t},\n\t\tTAG: function(match, curLoop){\n\t\t\tfor ( var i = 0; curLoop[i] === false; i++ ){}\n\t\t\treturn curLoop[i] && isXML(curLoop[i]) ? match[1] : match[1].toUpperCase();\n\t\t},\n\t\tCHILD: function(match){\n\t\t\tif ( match[1] == "nth" ) {\n\t\t\t\t// parse equations like \'even\', \'odd\', \'5\', \'2n\', \'3n+2\', \'4n-1\', \'-n+6\'\n\t\t\t\tvar test = /(-?)(\\d*)n((?:\\+|-)?\\d*)/.exec(\n\t\t\t\t\tmatch[2] == "even" && "2n" || match[2] == "odd" && "2n+1" ||\n\t\t\t\t\t!/\\D/.test( match[2] ) && "0n+" + match[2] || match[2]);\n\n\t\t\t\t// calculate the numbers (first)n+(last) including if they are negative\n\t\t\t\tmatch[2] = (test[1] + (test[2] || 1)) - 0;\n\t\t\t\tmatch[3] = test[3] - 0;\n\t\t\t}\n\n\t\t\t// TODO: Move to normal caching system\n\t\t\tmatch[0] = done++;\n\n\t\t\treturn match;\n\t\t},\n\t\tATTR: function(match, curLoop, inplace, result, not, isXML){\n\t\t\tvar name = match[1].replace(/\\\\/g, "");\n\t\t\t\n\t\t\tif ( !isXML && Expr.attrMap[name] ) {\n\t\t\t\tmatch[1] = Expr.attrMap[name];\n\t\t\t}\n\n\t\t\tif ( match[2] === "~=" ) {\n\t\t\t\tmatch[4] = " " + match[4] + " ";\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\t\tPSEUDO: function(match, curLoop, inplace, result, not){\n\t\t\tif ( match[1] === "not" ) {\n\t\t\t\t// If we\'re dealing with a complex expression, or a simple one\n\t\t\t\tif ( chunker.exec(match[3]).length > 1 || /^\\w/.test(match[3]) ) {\n\t\t\t\t\tmatch[3] = Sizzle(match[3], null, null, curLoop);\n\t\t\t\t} else {\n\t\t\t\t\tvar ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);\n\t\t\t\t\tif ( !inplace ) {\n\t\t\t\t\t\tresult.push.apply( result, ret );\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else if ( Expr.match.POS.test( match[0] ) || Expr.match.CHILD.test( match[0] ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\treturn match;\n\t\t},\n\t\tPOS: function(match){\n\t\t\tmatch.unshift( true );\n\t\t\treturn match;\n\t\t}\n\t},\n\tfilters: {\n\t\tenabled: function(elem){\n\t\t\treturn elem.disabled === false && elem.type !== "hidden";\n\t\t},\n\t\tdisabled: function(elem){\n\t\t\treturn elem.disabled === true;\n\t\t},\n\t\tchecked: function(elem){\n\t\t\treturn elem.checked === true;\n\t\t},\n\t\tselected: function(elem){\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\telem.parentNode.selectedIndex;\n\t\t\treturn elem.selected === true;\n\t\t},\n\t\tparent: function(elem){\n\t\t\treturn !!elem.firstChild;\n\t\t},\n\t\tempty: function(elem){\n\t\t\treturn !elem.firstChild;\n\t\t},\n\t\thas: function(elem, i, match){\n\t\t\treturn !!Sizzle( match[3], elem ).length;\n\t\t},\n\t\theader: function(elem){\n\t\t\treturn /h\\d/i.test( elem.nodeName );\n\t\t},\n\t\ttext: function(elem){\n\t\t\treturn "text" === elem.type;\n\t\t},\n\t\tradio: function(elem){\n\t\t\treturn "radio" === elem.type;\n\t\t},\n\t\tcheckbox: function(elem){\n\t\t\treturn "checkbox" === elem.type;\n\t\t},\n\t\tfile: function(elem){\n\t\t\treturn "file" === elem.type;\n\t\t},\n\t\tpassword: function(elem){\n\t\t\treturn "password" === elem.type;\n\t\t},\n\t\tsubmit: function(elem){\n\t\t\treturn "submit" === elem.type;\n\t\t},\n\t\timage: function(elem){\n\t\t\treturn "image" === elem.type;\n\t\t},\n\t\treset: function(elem){\n\t\t\treturn "reset" === elem.type;\n\t\t},\n\t\tbutton: function(elem){\n\t\t\treturn "button" === elem.type || elem.nodeName.toUpperCase() === "BUTTON";\n\t\t},\n\t\tinput: function(elem){\n\t\t\treturn /input|select|textarea|button/i.test(elem.nodeName);\n\t\t}\n\t},\n\tsetFilters: {\n\t\tfirst: function(elem, i){\n\t\t\treturn i === 0;\n\t\t},\n\t\tlast: function(elem, i, match, array){\n\t\t\treturn i === array.length - 1;\n\t\t},\n\t\teven: function(elem, i){\n\t\t\treturn i % 2 === 0;\n\t\t},\n\t\todd: function(elem, i){\n\t\t\treturn i % 2 === 1;\n\t\t},\n\t\tlt: function(elem, i, match){\n\t\t\treturn i < match[3] - 0;\n\t\t},\n\t\tgt: function(elem, i, match){\n\t\t\treturn i > match[3] - 0;\n\t\t},\n\t\tnth: function(elem, i, match){\n\t\t\treturn match[3] - 0 == i;\n\t\t},\n\t\teq: function(elem, i, match){\n\t\t\treturn match[3] - 0 == i;\n\t\t}\n\t},\n\tfilter: {\n\t\tPSEUDO: function(elem, match, i, array){\n\t\t\tvar name = match[1], filter = Expr.filters[ name ];\n\n\t\t\tif ( filter ) {\n\t\t\t\treturn filter( elem, i, match, array );\n\t\t\t} else if ( name === "contains" ) {\n\t\t\t\treturn (elem.textContent || elem.innerText || "").indexOf(match[3]) >= 0;\n\t\t\t} else if ( name === "not" ) {\n\t\t\t\tvar not = match[3];\n\n\t\t\t\tfor ( var i = 0, l = not.length; i < l; i++ ) {\n\t\t\t\t\tif ( not[i] === elem ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t},\n\t\tCHILD: function(elem, match){\n\t\t\tvar type = match[1], node = elem;\n\t\t\tswitch (type) {\n\t\t\t\tcase \'only\':\n\t\t\t\tcase \'first\':\n\t\t\t\t\twhile ( (node = node.previousSibling) )  {\n\t\t\t\t\t\tif ( node.nodeType === 1 ) return false;\n\t\t\t\t\t}\n\t\t\t\t\tif ( type == \'first\') return true;\n\t\t\t\t\tnode = elem;\n\t\t\t\tcase \'last\':\n\t\t\t\t\twhile ( (node = node.nextSibling) )  {\n\t\t\t\t\t\tif ( node.nodeType === 1 ) return false;\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\tcase \'nth\':\n\t\t\t\t\tvar first = match[2], last = match[3];\n\n\t\t\t\t\tif ( first == 1 && last == 0 ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvar doneName = match[0],\n\t\t\t\t\t\tparent = elem.parentNode;\n\t\n\t\t\t\t\tif ( parent && (parent.sizcache !== doneName || !elem.nodeIndex) ) {\n\t\t\t\t\t\tvar count = 0;\n\t\t\t\t\t\tfor ( node = parent.firstChild; node; node = node.nextSibling ) {\n\t\t\t\t\t\t\tif ( node.nodeType === 1 ) {\n\t\t\t\t\t\t\t\tnode.nodeIndex = ++count;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} \n\t\t\t\t\t\tparent.sizcache = doneName;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvar diff = elem.nodeIndex - last;\n\t\t\t\t\tif ( first == 0 ) {\n\t\t\t\t\t\treturn diff == 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn ( diff % first == 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tID: function(elem, match){\n\t\t\treturn elem.nodeType === 1 && elem.getAttribute("id") === match;\n\t\t},\n\t\tTAG: function(elem, match){\n\t\t\treturn (match === "*" && elem.nodeType === 1) || elem.nodeName === match;\n\t\t},\n\t\tCLASS: function(elem, match){\n\t\t\treturn (" " + (elem.className || elem.getAttribute("class")) + " ")\n\t\t\t\t.indexOf( match ) > -1;\n\t\t},\n\t\tATTR: function(elem, match){\n\t\t\tvar name = match[1],\n\t\t\t\tresult = Expr.attrHandle[ name ] ?\n\t\t\t\t\tExpr.attrHandle[ name ]( elem ) :\n\t\t\t\t\telem[ name ] != null ?\n\t\t\t\t\t\telem[ name ] :\n\t\t\t\t\t\telem.getAttribute( name ),\n\t\t\t\tvalue = result + "",\n\t\t\t\ttype = match[2],\n\t\t\t\tcheck = match[4];\n\n\t\t\treturn result == null ?\n\t\t\t\ttype === "!=" :\n\t\t\t\ttype === "=" ?\n\t\t\t\tvalue === check :\n\t\t\t\ttype === "*=" ?\n\t\t\t\tvalue.indexOf(check) >= 0 :\n\t\t\t\ttype === "~=" ?\n\t\t\t\t(" " + value + " ").indexOf(check) >= 0 :\n\t\t\t\t!check ?\n\t\t\t\tvalue && result !== false :\n\t\t\t\ttype === "!=" ?\n\t\t\t\tvalue != check :\n\t\t\t\ttype === "^=" ?\n\t\t\t\tvalue.indexOf(check) === 0 :\n\t\t\t\ttype === "$=" ?\n\t\t\t\tvalue.substr(value.length - check.length) === check :\n\t\t\t\ttype === "|=" ?\n\t\t\t\tvalue === check || value.substr(0, check.length + 1) === check + "-" :\n\t\t\t\tfalse;\n\t\t},\n\t\tPOS: function(elem, match, i, array){\n\t\t\tvar name = match[2], filter = Expr.setFilters[ name ];\n\n\t\t\tif ( filter ) {\n\t\t\t\treturn filter( elem, i, match, array );\n\t\t\t}\n\t\t}\n\t}\n};\n\nvar origPOS = Expr.match.POS;\n\nfor ( var type in Expr.match ) {\n\tExpr.match[ type ] = new RegExp( Expr.match[ type ].source + /(?![^\\[]*\\])(?![^\\(]*\\))/.source );\n}\n\nvar makeArray = function(array, results) {\n\tarray = Array.prototype.slice.call( array, 0 );\n\n\tif ( results ) {\n\t\tresults.push.apply( results, array );\n\t\treturn results;\n\t}\n\t\n\treturn array;\n};\n\n// Perform a simple check to determine if the browser is capable of\n// converting a NodeList to an array using builtin methods.\ntry {\n\tArray.prototype.slice.call( document.documentElement.childNodes, 0 );\n\n// Provide a fallback method if it does not work\n} catch(e){\n\tmakeArray = function(array, results) {\n\t\tvar ret = results || [];\n\n\t\tif ( toString.call(array) === "[object Array]" ) {\n\t\t\tArray.prototype.push.apply( ret, array );\n\t\t} else {\n\t\t\tif ( typeof array.length === "number" ) {\n\t\t\t\tfor ( var i = 0, l = array.length; i < l; i++ ) {\n\t\t\t\t\tret.push( array[i] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( var i = 0; array[i]; i++ ) {\n\t\t\t\t\tret.push( array[i] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t};\n}\n\nvar sortOrder;\n\nif ( document.documentElement.compareDocumentPosition ) {\n\tsortOrder = function( a, b ) {\n\t\tvar ret = a.compareDocumentPosition(b) & 4 ? -1 : a === b ? 0 : 1;\n\t\tif ( ret === 0 ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn ret;\n\t};\n} else if ( "sourceIndex" in document.documentElement ) {\n\tsortOrder = function( a, b ) {\n\t\tvar ret = a.sourceIndex - b.sourceIndex;\n\t\tif ( ret === 0 ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn ret;\n\t};\n} else if ( document.createRange ) {\n\tsortOrder = function( a, b ) {\n\t\tvar aRange = a.ownerDocument.createRange(), bRange = b.ownerDocument.createRange();\n\t\taRange.selectNode(a);\n\t\taRange.collapse(true);\n\t\tbRange.selectNode(b);\n\t\tbRange.collapse(true);\n\t\tvar ret = aRange.compareBoundaryPoints(Range.START_TO_END, bRange);\n\t\tif ( ret === 0 ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn ret;\n\t};\n}\n\n// Check to see if the browser returns elements by name when\n// querying by getElementById (and provide a workaround)\n(function(){\n\t// We\'re going to inject a fake input element with a specified name\n\tvar form = document.createElement("div"),\n\t\tid = "script" + (new Date).getTime();\n\tform.innerHTML = "<a name=\'" + id + "\'/>";\n\n\t// Inject it into the root element, check its status, and remove it quickly\n\tvar root = document.documentElement;\n\troot.insertBefore( form, root.firstChild );\n\n\t// The workaround has to do additional checks after a getElementById\n\t// Which slows things down for other browsers (hence the branching)\n\tif ( !!document.getElementById( id ) ) {\n\t\tExpr.find.ID = function(match, context, isXML){\n\t\t\tif ( typeof context.getElementById !== "undefined" && !isXML ) {\n\t\t\t\tvar m = context.getElementById(match[1]);\n\t\t\t\treturn m ? m.id === match[1] || typeof m.getAttributeNode !== "undefined" && m.getAttributeNode("id").nodeValue === match[1] ? [m] : undefined : [];\n\t\t\t}\n\t\t};\n\n\t\tExpr.filter.ID = function(elem, match){\n\t\t\tvar node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");\n\t\t\treturn elem.nodeType === 1 && node && node.nodeValue === match;\n\t\t};\n\t}\n\n\troot.removeChild( form );\n\troot = form = null; // release memory in IE\n})();\n\n(function(){\n\t// Check to see if the browser returns only elements\n\t// when doing getElementsByTagName("*")\n\n\t// Create a fake element\n\tvar div = document.createElement("div");\n\tdiv.appendChild( document.createComment("") );\n\n\t// Make sure no comments are found\n\tif ( div.getElementsByTagName("*").length > 0 ) {\n\t\tExpr.find.TAG = function(match, context){\n\t\t\tvar results = context.getElementsByTagName(match[1]);\n\n\t\t\t// Filter out possible comments\n\t\t\tif ( match[1] === "*" ) {\n\t\t\t\tvar tmp = [];\n\n\t\t\t\tfor ( var i = 0; results[i]; i++ ) {\n\t\t\t\t\tif ( results[i].nodeType === 1 ) {\n\t\t\t\t\t\ttmp.push( results[i] );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tresults = tmp;\n\t\t\t}\n\n\t\t\treturn results;\n\t\t};\n\t}\n\n\t// Check to see if an attribute returns normalized href attributes\n\tdiv.innerHTML = "<a href=\'#\'></a>";\n\tif ( div.firstChild && typeof div.firstChild.getAttribute !== "undefined" &&\n\t\t\tdiv.firstChild.getAttribute("href") !== "#" ) {\n\t\tExpr.attrHandle.href = function(elem){\n\t\t\treturn elem.getAttribute("href", 2);\n\t\t};\n\t}\n\n\tdiv = null; // release memory in IE\n})();\n\nif ( document.querySelectorAll ) (function(){\n\tvar oldSizzle = Sizzle, div = document.createElement("div");\n\tdiv.innerHTML = "<p class=\'TEST\'></p>";\n\n\t// Safari can\'t handle uppercase or unicode characters when\n\t// in quirks mode.\n\tif ( div.querySelectorAll && div.querySelectorAll(".TEST").length === 0 ) {\n\t\treturn;\n\t}\n\t\n\tSizzle = function(query, context, extra, seed){\n\t\tcontext = context || document;\n\n\t\t// Only use querySelectorAll on non-XML documents\n\t\t// (ID selectors don\'t work in non-HTML documents)\n\t\tif ( !seed && context.nodeType === 9 && !isXML(context) ) {\n\t\t\ttry {\n\t\t\t\treturn makeArray( context.querySelectorAll(query), extra );\n\t\t\t} catch(e){}\n\t\t}\n\t\t\n\t\treturn oldSizzle(query, context, extra, seed);\n\t};\n\n\tfor ( var prop in oldSizzle ) {\n\t\tSizzle[ prop ] = oldSizzle[ prop ];\n\t}\n\n\tdiv = null; // release memory in IE\n})();\n\nif ( document.getElementsByClassName && document.documentElement.getElementsByClassName ) (function(){\n\tvar div = document.createElement("div");\n\tdiv.innerHTML = "<div class=\'test e\'></div><div class=\'test\'></div>";\n\n\t// Opera can\'t find a second classname (in 9.6)\n\tif ( div.getElementsByClassName("e").length === 0 )\n\t\treturn;\n\n\t// Safari caches class attributes, doesn\'t catch changes (in 3.2)\n\tdiv.lastChild.className = "e";\n\n\tif ( div.getElementsByClassName("e").length === 1 )\n\t\treturn;\n\n\tExpr.order.splice(1, 0, "CLASS");\n\tExpr.find.CLASS = function(match, context, isXML) {\n\t\tif ( typeof context.getElementsByClassName !== "undefined" && !isXML ) {\n\t\t\treturn context.getElementsByClassName(match[1]);\n\t\t}\n\t};\n\n\tdiv = null; // release memory in IE\n})();\n\nfunction dirNodeCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {\n\tvar sibDir = dir == "previousSibling" && !isXML;\n\tfor ( var i = 0, l = checkSet.length; i < l; i++ ) {\n\t\tvar elem = checkSet[i];\n\t\tif ( elem ) {\n\t\t\tif ( sibDir && elem.nodeType === 1 ){\n\t\t\t\telem.sizcache = doneName;\n\t\t\t\telem.sizset = i;\n\t\t\t}\n\t\t\telem = elem[dir];\n\t\t\tvar match = false;\n\n\t\t\twhile ( elem ) {\n\t\t\t\tif ( elem.sizcache === doneName ) {\n\t\t\t\t\tmatch = checkSet[elem.sizset];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif ( elem.nodeType === 1 && !isXML ){\n\t\t\t\t\telem.sizcache = doneName;\n\t\t\t\t\telem.sizset = i;\n\t\t\t\t}\n\n\t\t\t\tif ( elem.nodeName === cur ) {\n\t\t\t\t\tmatch = elem;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\telem = elem[dir];\n\t\t\t}\n\n\t\t\tcheckSet[i] = match;\n\t\t}\n\t}\n}\n\nfunction dirCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {\n\tvar sibDir = dir == "previousSibling" && !isXML;\n\tfor ( var i = 0, l = checkSet.length; i < l; i++ ) {\n\t\tvar elem = checkSet[i];\n\t\tif ( elem ) {\n\t\t\tif ( sibDir && elem.nodeType === 1 ) {\n\t\t\t\telem.sizcache = doneName;\n\t\t\t\telem.sizset = i;\n\t\t\t}\n\t\t\telem = elem[dir];\n\t\t\tvar match = false;\n\n\t\t\twhile ( elem ) {\n\t\t\t\tif ( elem.sizcache === doneName ) {\n\t\t\t\t\tmatch = checkSet[elem.sizset];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\tif ( !isXML ) {\n\t\t\t\t\t\telem.sizcache = doneName;\n\t\t\t\t\t\telem.sizset = i;\n\t\t\t\t\t}\n\t\t\t\t\tif ( typeof cur !== "string" ) {\n\t\t\t\t\t\tif ( elem === cur ) {\n\t\t\t\t\t\t\tmatch = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( Sizzle.filter( cur, [elem] ).length > 0 ) {\n\t\t\t\t\t\tmatch = elem;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\telem = elem[dir];\n\t\t\t}\n\n\t\t\tcheckSet[i] = match;\n\t\t}\n\t}\n}\n\nvar contains = document.compareDocumentPosition ?  function(a, b){\n\treturn a.compareDocumentPosition(b) & 16;\n} : function(a, b){\n\treturn a !== b && (a.contains ? a.contains(b) : true);\n};\n\nvar isXML = function(elem){\n\treturn elem.nodeType === 9 && elem.documentElement.nodeName !== "HTML" ||\n\t\t!!elem.ownerDocument && elem.ownerDocument.documentElement.nodeName !== "HTML";\n};\n\nvar posProcess = function(selector, context){\n\tvar tmpSet = [], later = "", match,\n\t\troot = context.nodeType ? [context] : context;\n\n\t// Position selectors must be done after the filter\n\t// And so must :not(positional) so we move all PSEUDOs to the end\n\twhile ( (match = Expr.match.PSEUDO.exec( selector )) ) {\n\t\tlater += match[0];\n\t\tselector = selector.replace( Expr.match.PSEUDO, "" );\n\t}\n\n\tselector = Expr.relative[selector] ? selector + "*" : selector;\n\n\tfor ( var i = 0, l = root.length; i < l; i++ ) {\n\t\tSizzle( selector, root[i], tmpSet );\n\t}\n\n\treturn Sizzle.filter( later, tmpSet );\n};\n\nreturn Sizzle;\n\n})();\n');
jsio.setCachedSrc("../../packages/net/env/browser/postmessage.js","jsio('import net.interfaces');\njsio('from util.browser import $');\n\nexports.Listener = Class(net.interfaces.Listener, function(supr) {\n\tvar ID = 0;\n\t\n\tthis.init = function() {\n\t\tsupr(this, 'init', arguments);\n\t\tthis._clients = {};\n\t\tif (!this._opts.clientUrl) {\n\t\t\tthis._opts.clientUrl = jsio.__dir + '/networkConsole.html';\n\t\t}\n\t}\n\n\tthis.listen = function() {\n\t\t$.onEvent(window, 'message', bind(this, '_onMessage'));\n\t}\n\n\tthis.getButton = function(url, text) {\n\t\tvar button = $({\n\t\t\ttagName: 'button',\n\t\t\ttext: text || 'launch client',\n\t\t\tclassName: 'clientButton'\n\t\t});\n\t\t$.onEvent(button, 'click', bind(this, 'openWindow', url || this._opts.clientUrl));\n\t\treturn button; \n\t}\n\t\n\tvar uniqueId = 1;\n\tthis.openWindow = function(url) {\n\t\tvar options = { menubar: 'no', location: 'no', toolbar: 'no',\n\t\t\twidth: 550, height: 350, // left: 200, top: 200,\n\t\t\tscrollbars: 'yes', status: 'yes', resizable: 'yes' };\n\t\t\n\t\tvar arr = [];\n\t\tfor (var i in options) { arr.push(i + '=' + options[i]) }\n\t\tvar win = window.open(url, 'W' + uniqueId++, arr.join(','));\n\t\twin.focus();\n\t}\n\t\n\tthis._onMessage = function(evt) {\n\t\tvar name = evt.source.name;\n\t\tvar target = this._clients[name];\n\t\tvar data = eval('(' + evt.data + ')');\n\t\tswitch (data.type) {\n\t\t\tcase 'open':\n\t\t\t\tthis._clients[name] = new exports.Transport(evt.source);\n\t\t\t\tevt.source.postMessage('{type:\"open\"}','*');\n\t\t\t\tthis.onConnect(this._clients[name]);\n\t\t\t\tbreak;\n\t\t\tcase 'data':\n\t\t\t\ttarget.onData(data.payload);\n\t\t\t\tbreak;\n\t\t\tcase 'close':\n\t\t\t\ttarget.onClose();\n\t\t\t\tevt.source.postMessage('{type:\"close\"}','*');\n\t\t\t\tdelete this._clients[name];\n\t\t\t\tbreak;\n\t\t}\n\t}\n});\n\nexports.Connector = Class(net.interfaces.Connector, function() {\n\tthis.connect = function() {\n\t\t$.onEvent(window, 'message', bind(this, '_onMessage'));\n\t\twindow.opener.postMessage(JSON.stringify({type:\"open\"}), '*');\n\t}\n\t\n\tthis._onMessage = function(evt) {\n\t\tvar data = eval('(' + evt.data + ')');\n\t\tswitch(data.type) {\n\t\t\tcase 'open':\n\t\t\t\tthis._transport = new exports.Transport(evt.source);\n\t\t\t\tthis.onConnect(this._transport);\n\t\t\t\tbreak;\n\t\t\tcase 'close':\n\t\t\t\tthis._transport.onClose();\n\t\t\t\tbreak;\n\t\t\tcase 'data':\n\t\t\t\tthis._transport.onData(data.payload);\n\t\t\t\tbreak;\n\t\t}\n\t}\n});\n\nexports.Transport = Class(net.interfaces.Transport, function() {\n\tthis.init = function(win) {\n\t\tthis._win = win;\n\t}\n\t\n\tthis.makeConnection = function(protocol) {\n\t\tthis._protocol = protocol;\n\t}\n\t\n\tthis.write = function(data, encoding) {\n\t\tif (this.encoding == 'utf8') {\n\t\t\tthis._win.postMessage(JSON.stringify({type: 'data', payload: utf8.encode(data)}), '*');\n\t\t} else {\n\t\t\tthis._win.postMessage(JSON.stringify({type: 'data', payload: data}), '*');\n\t\t} \n\t}\n\t\n\tthis.loseConnection = function(protocol) {\n\t\tthis._win.postMessage(JSON.stringify({type: 'close', code: 301}), '*');\n\t}\n\t\n\tthis.onData = function() { this._protocol.dataReceived.apply(this._protocol, arguments); }\n\tthis.onClose = function() { this._protocol._connectionLost.apply(this._protocol, arguments); }\n});\n");
jsio.setCachedSrc("../../packages/net/env/browser/websocket.js","jsio('import net.interfaces');\njsio('import std.utf8 as utf8');\njsio('import net.errors as Errors');\n\nexports.Connector = Class(net.interfaces.Connector, function() {\n\tthis.connect = function() {\n\t\tthis._state = net.interfaces.STATE.CONNECTING;\n\t\t\n\t\tvar url = this._opts.url,\n\t\t \tctor = this._opts.wsConstructor || window.WebSocket;\n\t\n\t\tlogger.info('this._opts', this._opts);\n\t\t\n\t\tvar ws = new ctor(url);\n\t\tws.onopen = bind(this, 'webSocketOnOpen', ws);\n\t\tws.onclose = bind(this, 'webSocketOnClose', ws);\n\t}\n\t\n\tthis.webSocketOnOpen = function(ws) {\n\t\tthis.onConnect(new Transport(ws));\n\t}\n\t\n\tthis.webSocketOnClose = function(ws, e) {\n\t\tvar err,\n\t\t\tdata = {rawError: e, webSocket: ws};\n\t\tif (e.wasClean) {\n\t\t\terr = new Errors.ServerClosedConnection('WebSocket Connection Closed', data);\n\t\t} else {\n\t\t\tif (this._state == net.interfaces.STATE.CONNECTED) {\n\t\t\t\terr = new Errors.ConnectionTimeout('WebSocket Connection Timed Out', data);\n\t\t\t} else {\n\t\t\t\terr = new Errors.ServerUnreachable('WebSocket Connection Failed', data);\n\t\t\t}\n\t\t}\n\t\t\n\t\tlogger.debug('conn closed', err);\n\t\tthis.onDisconnect(err);\n\t}\n});\n\nvar Transport = Class(net.interfaces.Transport, function() {\n\t\n\tthis.init = function(ws) {\n\t\tthis._ws = ws;\n\t}\n\t\n\tthis.makeConnection = function(protocol) {\n\t\tthis._ws.onmessage = function(data) {\n\t\t\tvar payload = utf8.encode(data.data);\n\t\t\tprotocol.dataReceived(payload);\n\t\t}\n\t}\n\t\n\tthis.write = function(data, encoding) {\n\t\tif (this._encoding == 'plain') {\n\t\t\tresult = utf8.decode(data);\n\t\t\tdata = result[0];\n\t\t}\n\t\tthis._ws.send(data);\n\t}\n\t\n\tthis.loseConnection = function(protocol) {\n\t\tthis._ws.close();\n\t}\n});\n");
jsio.setCachedSrc("../../packages/net/env/node/csp/proxy.js","/*\nMultiplexing socket proxy implemented against Node JS and my\nNode CSP server, by Jacob Rus.\n\n--------------------\n\nCopyright (c) 2009 Jacob Rus\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n*/\njsio('from .util import *');\njsio('from .server import csp')\n\n// msp = \"Multiplexing Socket Proxy\"\nvar msp = this.msp = exports;\n\n;(function () {\n\nvar frameTypes = ['open', 'close', 'data'];\nvar FRAME_OPENED = 0, FRAME_CLOSED = 1, FRAME_DATA = 2;\nvar errorCodes = {\n\tInvalidHandshake: 102,\n\tUserConnectionReset: 103,\n\tRemoteConnectionTimeout: 104,\n\tUnauthorized: 106,\n\tRemoteConnectionFailed: 108,\n\tRemoteConnectionClosed: 109,\n\tProtocolError: 110,\n};\nmsp.ProxyConnection = Class(function() {\n\tthis.init = function (inConnection) {\n\t\tthis.inConnection = inConnection;\n\t\tthis.inBuffer = '';\n\t\tthis.outConnections = {};\n\t\tthis.inConnection\n\t\t\t.addListener('receive', bind(this, this.receiveData))\n\t\t\t.addListener('eof', bind(this, this.shutdown))\n\t\t\t.addListener('disconnect', bind(this, this.shutdown))\n\t\t\t.setEncoding('bytes');\t\n\t};\n\tthis.receiveData = function (data) {\n\t\tvar frameBegin;\n\t\tthis.inBuffer += data;\n\t\ttry {\n\t\t\twhile ((frameBegin = this.inBuffer.indexOf('[')) != -1) {\n\t\t\t\tvar frameEnd = parseInt(this.inBuffer.slice(0, frameBegin)) + frameBegin;\n\t\t\t\tassert (!isNaN(frameEnd), 'Invalid frame size prefix');\n\t\t\t\tif (this.inBuffer.length < frameEnd) {\n\t\t\t\t\tbreak; // whole frame hasn't arrived yet\n\t\t\t\t}\n\t\t\t\tvar frame = JSON.parse(this.inBuffer.slice(frameBegin, frameEnd));\n\t\t\t\tthis.inBuffer = this.inBuffer.slice(frameEnd) // remove frame from buffer\n\t\t\t\t// frame consists of connection id, frame type, arbitrary other arguments\n\t\t\t\tassert(frame instanceof Array && frame.length >= 2, 'Invalid frame');\n\t\t\t\tvar connectionId = frame.shift();\n\t\t\t\tvar frameType = frameTypes[frame.shift()];\n\t\t\t\tassert(frameType, 'Unrecognized frame type');\n\t\t\t\tvar args = frame; args.unshift(connectionId); // put back connection ID\n\t\t\t\tdispatchFrame[frameType].apply(this, args);\n\t\t\t};\n\t\t} catch (e) {\n\t\t\tdebug('PROTOCOL ERROR: ', (e.message || 'unknown error'));\n\t\t\tthis.shutdown(true);\n\t\t};\n\t};\n\tthis.shutdown = function (had_error) {\n\t\t// close all outgoing TCP connections\t\t\t \n\t\tfor (var connectionId in this.outConnections) {\n\t\t\tif (had_error) {\n\t\t\t\tthis.closeOutgoing(connectionId, 'ProtocolError');\n\t\t\t} else {\n\t\t\t\tthis.closeOutgoing(connectionId, 'UserConnectionReset');\n\t\t\t}\n\t\t\tvar outConn = this.outConnections[connectionId];\n\t\t\toutConn.listeners('connect') = [];\n\t\t\toutConn.listeners('receive') = [];\n\t\t\toutConn.listeners('eof') = [];\n\t\t\toutConn.listeners('disconnect') = [];\n\t\t};\n\t};\n\tthis.send = function (frame) {\n\t\tpayload = JSON.stringify(frame);\n\t\tthis.inConnection.send(payload.length + ',' + payload, 'bytes');\n\t};\n\tthis.closeOutgoing = function (connectionId, errorType) {\n\t\tif (connectionId in this.outConnections) {\n\t\t\tvar code = errorCodes[errorType];\n\t\t\tthis.send([connectionId, FRAME_CLOSED, code]);\n\t\t\tthis.outConnections[connectionId].close();\n\t\t\tdelete this.outConnections[connectionId];\n\t\t};\n\t};\n\tthis.dispatchFrame = {\n\t\topen: function (connectionId, host, port) {\n\t\t\tassert(!(connectionId in this.outConnections), 'OPEN frame for existing connection');\n\t\t\tassert(host && port, 'Invalid host or port');\n\t\t\tvar outConn = this.outConnections[connectionId] = node.tcp.createConnection(port, host);\n\t\t\toutConn.setEncoding('bytes');\n\t\t\toutConn\n\t\t\t\t.addListener('connect', function () {\n\t\t\t\t\tthis.send([connectionId, FRAME_OPENED]);\n\t\t\t\t})\n\t\t\t\t.addListener('receive', function (data) {\n\t\t\t\t\tthis.send([connectionId, FRAME_DATA, data]);\n\t\t\t\t})\n\t\t\t\t.addListener('eof', function () {\n\t\t\t\t\tthis.closeOutgoing(connectionId, 'RemoteConnectionClosed');\n\t\t\t\t})\n\t\t\t\t.addListener('disconnect', function (had_error) {\n\t\t\t\t\tthis.closeOutgoing(connectionId, 'RemoteConnectionClosed');\n\t\t\t\t});\n\t\t},\n\t\tclose: function (connectionId) {\n\t\t\tthis.closeOutgoing(connectionId, 'UserConnectionReset');\n\t\t},\n\t\tdata: function (connectionId, data) {\n\t\t\tdata = unescape(data);\n\t\t\tthis.outConnections[connectionId].send(data, 'bytes');\n\t\t},\n\t};\t\n});\n\nmsp.Proxy = Class(function () {\n\tthis.init = function () {\n\t\tthis.cspserver = csp.createServer(function(connection) {\n\t\t\tproxyConnection = new msp.ProxyConnection(connection);\n\t\t});\n\t};\n\tthis.listen = function (port, host) {\n\t\tthis.cspserver.listen(port, host);\n\t};\n});\n\n})(); // end closure w/ code for msp\n\nfunction start_server () {\n\tvar server = new msp.Proxy();\n\tserver.listen(8050);\n\tlog(\"Proxying from http://:8050\");\n};\nstart_server();");
jsio.setCachedSrc("../../packages/net/env/node/csp/util.js","/*\nHelper functions, &c., for a comet server by Jacob Rus.\n\n--------------------\n\nCopyright (c) 2009 Jacob Rus\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n*/\n\n// helper to test if string 2 is at the beginning of string 1\nexports.startswith = function (str1, str2) {\n\treturn str1.substring(0, str2.length) == str2;\n};\n\nexports.JSIOError = Class(Error, function () {\n\tthis.name = 'JSIOError';\n\tthis.toString = Error.prototype.toString;\n\tthis.init = function (message, fileName, lineNumber) {\n\t\tthis.name = this.name; // promote class property to instance\n\t\tthis.message = message || '';\n\t\tthis.fileName = fileName || '\u00abfilename\u00bb'; // location.href; // XXX what should go here?\n\t\tthis.lineNumber = isNaN(+lineNumber) ? 0 : +lineNumber\n\t};\n});\n\nexports.AssertionError = Class(exports.JSIOError, function (supr) {\n\tthis.name = 'AssertionError'\n\tthis.init = function () {supr(this, 'init', arguments)}\n});\n\nexports.assert = function (exp, message) {\n\tif (!exp) {\n\t\tthrow new exports.AssertionError(message)\n\t};\n};\n\n// schedule a callback to run at the next available moment,\n// equivalent to setTimeout(callback, 0)\nexports.reschedule = function (callback) {\n\treturn setTimeout(callback, 0);\n};\n\n// cached static files\nexports.staticFile = (function(){\n\tvar cache = {} // static file content indexed by filename\n\tvar getfile = function(path, callback) {\n\t\tcacheContent = cache[path];\n\t\tif (cacheContent !== undefined) {\n\t\t\t// the file is in the cache, return it\n\t\t\texports.reschedule(function(){\n\t\t\t\tcallback(null, [cacheContent]);\n\t\t\t});\n\t\t} else {\n\t\t\t// load file from disk, save it in the cache, and return it\n\t\t\tprocess.fs.readFile(path, 'utf8', function(err, fileContent){\n\t\t\t\tif (err) {\n\t\t\t\t\tcallback('staticFile readFile error ' + err)\n\t\t\t\t} else {\n\t\t\t\t\tcache[path] = fileContent;\n\t\t\t\t\tcallback(null, [fileContent]);\n\t\t\t\t}\n\t\t\t})\n\t\t};\n\t\treturn promise;\n\t};\n\treturn getfile;\n})();\n");
jsio.setCachedSrc("../../packages/net/env/node/csp/server.js","/*\nCSP server implemented against Node JS, by Jacob Rus.\n\n--------------------\n\nCopyright (c) 2009 Jacob Rus\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n*/\n \n// Make the dependancies work rather or not this file was used as a\n// node module or a jsio module.\n\njsio('import std.uuid as uuid');\njsio('import std.utf8 as utf8');\njsio('import std.base64 as base64');\njsio('import lib.Hash as Hash');\njsio('from .util import *');\n\nvar http = jsio.__env.require('http'),\n\tnodeUrl = jsio.__env.require('url');\n\nvar sessionDict = {},\n\tvarNames = {\n\t\t// per session\n\t\t'ct' : 'contentType',\n\t\t'ps' : 'prebufferSize',\n\t\t'p'\t : 'preamble',\n\t\t'rp' : 'requestPrefix',\n\t\t'rs' : 'requestSuffix',\n\t\t'bp' : 'batchPrefix',\n\t\t'bs' : 'batchSuffix',\n\t\t'i'\t : 'interval',\n\t\t'du' : 'duration',\n\t\t'is' : 'isStreaming',\n\t\t'g'\t : 'gzipOk',\n\t\t'se' : 'sse',\n\t\t// 's'\t: 'sessionKey', // per request, handled at the csp.Server level\n\t\t// 'a'\t: 'ackId',\t\t\t// left here to instruct other implementors.\n\t\t// 'd'\t: 'data',\n\t\t// 'n'\t: 'noCache',\n\t};\n\nexports.Session = Class(function() {\n\tthis.init = function () {\n\t\t// this.lastAck = 0; // 'a' variable\n\t\tthis.key = uuid.uuid(8);\t\t\t // generate 8-character base-62 UUID\n\t\tsessionDict[this.key] = this;\t // Add session to sessions dictionary\n\t\tthis.connection = null;\t\t\t\t // this.connection set from outside.\n\t\tthis.outgoingPacketBuffer = [];\n\t\tthis.incomingPacketBuffer = [];\n\t\tthis.lastSequentialIncomingId = 0\n\t\tthis.cometResponse = null;\n\t\tthis.durationTimer = null;\n\t\tthis.intervalTimer = null;\n\t\tthis.timeoutTimer = null;\n\t\tthis.outgoingPacketId = 1;\n\t\tthis.variables = { // set variables to defaults\n\t\t\t'contentType'   : 'text/html',\n\t\t\t// 'prebufferSize' : '0', // result stored in 'prebuffer' variable.\n\t\t\t'prebuffer'\t : '',\n\t\t\t'preamble'\t  : '',\n\t\t\t'requestPrefix' : '',\n\t\t\t'requestSuffix' : '',\n\t\t\t'batchPrefix'   : '',\n\t\t\t'batchSuffix'   : '',\n\t\t\t'interval'\t  : '0',\n\t\t\t'duration'\t  : '30',\n\t\t\t'isStreaming'   : '0',\n\t\t\t'gzipOk'\t\t: '',\n\t\t\t'sse'\t\t   : '',\n\t\t};\n\t\tthis.resetTimeoutTimer();\n\t};\n\tthis.teardownSession = function () {\n\t\tclearTimeout(this.durationTimer);\n\t\tthis.connection.readyState = (this.connection.readyState === 'open' ? 'writeOnly' : 'closed');\n\t\tthis.connection.emit('eof');\n\t\t// XXX when the client calls close, do we want to allow the server to\n\t\t// keep sending them stuff, write only? And what about when they time out?\n\t\tdelete sessionDict[this.key];\n\t};\n\t// send data to the client\n\tthis.send = function (data) {\n\t\t// base64-encode any string data with control characters or non-ASCII\n\t\tvar packet = (typeof data === 'string' && (/[^\\r\\n\\t\\x32-\\x7E]/).test(data)) ?\n\t\t\t[this.outgoingPacketId, 1, base64.encode(data)] :\n\t\t\t[this.outgoingPacketId, 0, data];\n\t\tthis.outgoingPacketId += 1;\n\t\tthis.outgoingPacketBuffer.push(packet);\n\t\tif (this.cometResponse) {\n\t\t\tthis.sendBatch([packet]);\n\t\t}; // else if no comet connection, just keep buffering packets\n\t};\n\tthis.close = function () {\n\t\t// call this to close a comet connection, and stop writing to it.\n\t\t// any remaining incoming packets will still fire 'receive' events.\n\t\tthis.send(null);\n\t\tthis.connection.readyState = (this.connection.readyState === 'open' ? 'readOnly' : 'closed');\n\t\tthis.connection.emit('close');\n\t};\n\t\n\tvar updatedHeaders = new Hash('gzipOk', 'contentType');\n\tthis.updateVars = function (params) {\n\t\tfor (var param in params) {\n\t\t\tvar key = varNames[param];\n\t\t\tif (!key) continue;\n\t\t\tvar value = params[param];\n\t\t\t// if gzipOk or contentType changes value, finish up any comet response with the previous values\n\t\t\tif (updatedHeaders.contains(key) && value != this.variables[key] && this.cometResponse) {\n\t\t\t\tthis.completeResponse();\n\t\t\t};\n\t\t\tif (key in this.variables) {\n\t\t\t\tthis.variables[key] = value;\n\t\t\t}\n\t\t\telse if (key == 'prebufferSize') {\n\t\t\t\tvar prebufferSize = parseInt(value);\n\t\t\t\tif (prebufferSize > 0) {\n\t\t\t\t\t// string of spaces of length prebufferSize\n\t\t\t\t\tthis.variables.prebuffer = (new Array(prebufferSize+1)).join(' ');\n\t\t\t\t};\n\t\t\t};\t\n\t\t};\n\t};\n\tthis.isStreaming = function () {\n\t\treturn (this.variables.isStreaming === '1') && (parseInt(this.variables.duration) > 0);\n\t};\n\tthis.resetDurationTimer = function () {\n\t\tvar duration = 1000 * parseInt(this.variables.duration);\n\t\tthis.durationTimer = setTimeout(bind(this, this.completeResponse), duration);\n\t};\n\tthis.resetIntervalTimer = function () {\n\t\tclearTimeout(this.intervalTimer);\n\t\tif (this.variables.interval === '0') {\n\t\t\treturn;\n\t\t};\n\t\tvar interval = 1000 * parseInt(this.variables.interval);\n\t\tthis.intervalTimer = setTimeout(bind(this, this.sendBatch), interval);\n\t};\n\tthis.resetTimeoutTimer = function () {\n\t\tclearTimeout(this.timeoutTimer);\n\t\t// Give the client 50% longer than the duration of a comet request before \n\t\t// we time them out.\n\t\tvar timeout = 1000 * parseInt(this.variables.duration) * 1.5;\n\t\tthis.timeoutTimer = setTimeout(bind(this, this.teardownSession), timeout);\n\t};\n\tthis.sendHeaders = function (response, contentLength) {\n\t\tvar allowOrigin = '*'; // XXX: Make Access-Control configurable\n\t\tif (contentLength === 'stream') {\n\t\t\tresponse.writeHead(200, {\n\t\t\t\t'Content-Type'\t\t\t\t: this.variables.contentType,\n\t\t\t\t'Cache-Control'\t\t\t   : 'no-cache, must-revalidate',\n\t\t\t\t'Transfer-Encoding'\t\t   : 'chunked',\n\t\t\t\t'Access-Control-Allow-Origin' : allowOrigin\n\t\t\t});\n\t\t}\n\t\telse if (contentLength >= 0) {\n\t\t\tresponse.writeHead(200, {\n\t\t\t\t'Content-Type'\t\t\t\t: this.variables.contentType,\n\t\t\t\t'Cache-Control'\t\t\t   : 'no-cache, must-revalidate',\n\t\t\t\t'Content-Length'\t\t\t  : contentLength,\n\t\t\t\t'Access-Control-Allow-Origin' : allowOrigin\n\t\t\t});\n\t\t};\n\t};\n\tthis.startStream = function () {\n\t\tthis.sendHeaders(this.cometResponse, 'stream');\n\t\tvar preamble = this.variables.prebuffer + this.variables.preamble;\n\t\tif (preamble) {\n\t\t\tthis.cometResponse.write(preamble);\n\t\t};\n\t\tthis.resetIntervalTimer();\n\t};\n\tthis.sendBatch = function (packetArray) {\n\t\tif (!packetArray) { packetArray = []; }; // default value\n\t\tvar prefix = this.variables.batchPrefix + '(';\n\t\tvar suffix = ')' + this.variables.batchSuffix;\n\t\tif (this.variables.sse === '1' && packetArray) {\n\t\t\t// ID of last packet in the batch is the \"SSE ID\"\n\t\t\tsuffix += 'id: ' + packetArray[packetArray.length - 1][0] + '\\r\\n';\n\t\t};\n\t\tvar batch = prefix + JSON.stringify(packetArray) + suffix;\n\t\tif (this.isStreaming()) {\n\t\t\tthis.cometResponse.write(batch);\n\t\t\tthis.resetIntervalTimer();\n\t\t} else {\n\t\t\tvar body = (this.variables.prebuffer + this.variables.preamble + batch);\n\t\t\tthis.sendHeaders(this.cometResponse, body.length)\n\t\t\tthis.cometResponse.write(body);\n\t\t\tthis.cometResponse.end();\n\t\t\tthis.cometResponse = null;\n\t\t\tclearTimeout(this.durationTimer);\n\t\t};\n\t};\n\tthis.completeResponse = function() {\n\t\tif (this.isStreaming()) {\n\t\t\tthis.cometResponse.end(); // close a stream\n\t\t\tthis.cometResponse = null;\n\t\t\tclearTimeout(this.durationTimer);\n\t\t\tclearTimeout(this.intervalTimer);\n\t\t} else {\n\t\t\tthis.sendBatch() // send empty batch to poll/longpoll\n\t\t};\n\t};\n\tthis.receiveAck = function (ackId) {\n\t\tthis.resetTimeoutTimer();\n\t\twhile (this.outgoingPacketBuffer.length && ackId >= this.outgoingPacketBuffer[0][0]) {\n\t\t\tthis.outgoingPacketBuffer.shift(); // remove first element\n\t\t};\n\t};\n\t// used for handshake, send, and close (not comet or reflect)\n\tthis.renderResponse = function (response, body) {\n\t\tvar prefix = this.variables.requestPrefix + '(';\n\t\tvar suffix = ')' + this.variables.requestSuffix;\n\t\tbody = prefix + body + suffix;\n\t\tthis.sendHeaders(response, body.length);\n\t\tresponse.write(body);\n\t\tresponse.end();\n\t};\n\t// a Server instance dispatches resources to this object's functions\n\tthis.dispatch = {\n\t\thandshake: function (request, response) {\n\t\t\tthis.renderResponse(response, JSON.stringify( {'session': this.key}));\n\t\t},\n\t\tcomet: function (request, response) {\n\t\t\tthis.cometResponse = response;\n\t\t\tif (this.isStreaming()) {\n\t\t\t\tthis.startStream();\n\t\t\t};\n\t\t\t// we have buffered packets, so send them.\n\t\t\tif (this.outgoingPacketBuffer.length) {\n\t\t\t\tthis.sendBatch(this.outgoingPacketBuffer);\n\t\t\t};\n\t\t\t// if we have no events to deliver, or if this is a stream, start a\n\t\t\t// duration timer, after which the response will always complete\n\t\t\tif (!this.outgoingPacketBuffer.length || this.isStreaming()) {\n\t\t\t\tthis.resetDurationTimer();\n\t\t\t};\n\t\t},\n\t\tsend: function (request, response) {\n\t\t\tvar batch = JSON.parse(request.data);\n\t\t\tlogger.debug('received packet batch:', batch);\n\t\t\twhile (batch[0] != undefined) {\n\t\t\t\t// packetId, encoding, content = batch.shift()\n\t\t\t\tvar packetContent,\n\t\t\t\t\tpacket = batch.shift(),\n\t\t\t\t\tpacketId = packet[0], encoding = packet[1], content = packet[2];\n\t\t\t\t\n\t\t\t\tif (content === null) {\n\t\t\t\t\tthis.close();\n\t\t\t\t} else if (encoding === 0) {\n\t\t\t\t\tpacketContent = content;\n\t\t\t\t} else if (encoding === 1) {\n\t\t\t\t\tpacketContent = base64.decode(content);\n\t\t\t\t} else {\n\t\t\t\t\tlogger.debug('BAD PACKET ENCODING,', encoding, '... dropping packet');\n\t\t\t\t\tbreak; // XXX probably should end connection here.\n\t\t\t\t};\n\t\t\t\tthis.incomingPacketBuffer[packetId - 1 - this.lastSequentialIncomingId] = packetContent;\n\t\t\t};\n\t\t\tlogger.debug('incomingPacketBuffer', this.incomingPacketBuffer);\n\t\t\twhile (this.incomingPacketBuffer[0] !== undefined) {\n\t\t\t\tvar nextPacketPayload = this.incomingPacketBuffer.shift();\n\t\t\t\tthis.lastSequentialIncomingId += 1;\n\t\t\t\tthis.connection._receive(nextPacketPayload);\n\t\t\t}; // this can leave packets in the buffer, to handled later, in order\n\t\t\tthis.renderResponse(response, '\"OK\"');\n\t\t},\n\t\tclose: function (request, response) {\n\t\t\tthis.teardownSession();\n\t\t\tthis.renderResponse(response, '\"OK\"');\n\t\t},\n\t\treflect: function (request, response) {\n\t\t\tvar body = request.data;\n\t\t\tthis.sendHeaders(response, body.length);\n\t\t\tresponse.write(body);\n\t\t\tresponse.end();\n\t\t},\n\t\tstreamtest: function (request, response) {\n\t\t\tlogger.debug('streamtest'); // XXX who knows what this does...?\n\t\t},\n\t};\n});\n\nexports.Connection = Class(process.EventEmitter, function() {\n\tthis.init = function (session) {\n\t\tthis.remoteAddress = null; // XXX get remote address from requests\n\t\tthis.readyState = 'open';\n\t\tthis._session = session;\n\t\tthis._encoding = 'binary';\n\t\tthis._utf8buffer = '';\n\t};\n\tthis._receive = function (data) {\n\t\tif (this._encoding === 'utf8') {\n\t\t\tthis._utf8buffer += data;\n\t\t\t// data, len_parsed = utf8.decode(this._utf8buffer)\n\t\t\tvar x = utf8.decode(this._utf8buffer), data = x[0], len_parsed = x[1];\n\t\t\tthis._utf8buffer = this._utf8buffer.slice(len_parsed) // buffer unparsed bytes\n\t\t};\n\t\tthis.emit('receive', data);\n\t};\n\t\n\tvar validEncodings = new Hash('utf8', 'plain', 'binary');\n\tthis.setEncoding = function (encoding) {\n\t\tassert(validEncodings.contains(encoding), 'unrecognized encoding: ' + encoding);\n\t\tif (encoding !== 'utf8') {\n\t\t\tassert(!(this._utf8buffer), 'cannot switch encodings with dirty utf8 buffer');\n\t\t};\n\t\tthis._encoding = encoding;\n\t};\n\t\n\tvar validReadyStates = new Hash('writeOnly', 'open');\n\tthis.send = function (data, encoding) {\n\t\tif (!validReadyStates.contains(this.readyState)) {\n\t\t\t// XXX make error type for this\n\t\t\tthrow new Error(\"Socket is not writable in readyState: \" + this.readyState);\n\t\t};\n\t\tencoding = encoding || this._encoding || 'binary'; // default to 'binary'\n\t\tassert(validEncodings.contains(encoding), 'unrecognized encoding: ' + encoding);\n\t\tdata = (encoding === 'utf8') ? utf8.encode(data) : data;\n\t\tthis._session.send(data);\n\t};\n\tthis.close = function () {\n\t\tthis._session.close();\n\t};\n});\n\nexports.createServer = function (connection_listener) {\n\treturn new exports.Server().addListener('connection', connection_listener);\n};\n\nexports.Server = Class(process.EventEmitter, function () {\n\tthis.init = function (sessionURL) {\n\t\tprocess.EventEmitter.call(this);\n\t\tthis._sessionUrl = sessionURL || ''; \n\t\tlog('starting server, session url is <' + this._sessionUrl + '>');\n\t};\n\tvar CSPError = Class(AssertionError, function (supr) {\n\t\tthis.name = 'CSPError'\n\t\tthis.init = function (code/*, other args */) {\n\t\t\tsupr(this, 'init', args);\n\t\t\tthis.code = code;\n\t\t\tvar args = Array.prototype.slice.call(arguments, 1);\n\t\t};\n\t});\n\tvar assertOrRenderError = function (exp, code, message) {\n\t\tif (!exp) { throw new CSPError(code, message) };\n\t};\n\tvar renderError = function (response, code, message) {\n\t\tresponse.writeHead(code, {'Content-Type'   : 'text/plain',\n\t\t\t\t\t\t\t\t   'Content-Length' : message.length});\n\t\tresponse.write(message);\n\t\tresponse.end();\n\t};\n\tvar sendStatic = function (path, response) {\n\t\tlogger.debug('SEND STATIC', path, response)\n\t\tstaticFile('./' + path.join('/'), function(err, content){\n\t\t\tif (err) {\n\t\t\t\trenderError(response, 404, 'No such file, ' + path);\n\t\t\t} else {\n\t\t\t\tresponse.writeHead(200, {'Content-Type'   : 'text/plain',\n\t\t\t\t\t\t\t\t\t\t  'Content-Length' : content.length});\n\t\t\t\tresponse.write(content);\n\t\t\t\tresponse.end();\n\t\t\t}\n\t\t})\n\t};\n\t// returns a request which fires with the whole post body as bytes, or\n\t// immediately with null for GET requests\n\tvar getRequestBody = function (request, callback) {\n\t\tif (request.method === 'GET') {\n\t\t\treschedule(function () {\n\t\t\t\tcallback('')\n\t\t\t});\n\t\t} else {\n\t\t\tvar body = [];\n\t\t\trequest.setEncoding('binary');\n\t\t\trequest\n\t\t\t\t.addListener('data', function (chunk) {\n\t\t\t\t\tbody.push(chunk); // body += chunk\n\t\t\t\t})\n\t\t\t\t.addListener('end', function () {\n\t\t\t\t\tcallback(body.join(''));\n\t\t\t\t});\n\t\t};\n\t};\n\t// The logic of the server goes in the 'handleRequest' function, which is\n\t// called every time a new request comes in.\n\tvar validResources = new Hash('static', 'handshake', 'comet', 'send', 'close', 'reflect', 'streamtest'),\n\t\tvalidMethods = new Hash('GET', 'POST');\n\tthis._handleRequest = function (request, response) {\n\t\tgetRequestBody(request, bind(this, function(body) {\n\t\t\tlogger.debug('received request', request.url);\n\t\t\ttry {\n\t\t\t\tvar uri = nodeUrl.parse(request.url, true),\n\t\t\t\t\tpath = uri.pathname,\n\t\t\t\t\tsessionUrl = this._sessionUrl;\n\n\t\t\t\tassertOrRenderError(startswith(path, sessionUrl + '/'),\n\t\t\t\t\t\t\t\t\t404, 'Request to invalid session URL');\n\t\t\t\tlogger.debug(request.method);\n\t\t\t\tassertOrRenderError(validMethods.contains(request.method),\n\t\t\t\t\t\t\t\t\t405, 'Invalid HTTP method, ' + request.method);\n\t\t\t\t\n\t\t\t\tvar resource = path.split('/').pop();\n\t\t\t\tif (resource === 'static') {\n\t\t\t\t\tassertOrRenderError(startswith(path, sessionUrl + '/'),\n\t\t\t\t\t\t\t\t\t\t404, 'sendStatic Not Implemented');\n\t\t\t\t\t// TODO: sendStatic(relativePath, response);\n\t\t\t\t\treturn;\n\t\t\t\t};\n\n\t\t\t\tassertOrRenderError(validResources.contains(resource),\n\t\t\t\t\t\t\t\t\t404, 'Invalid resource, ' + path);\n\n\t\t\t\tvar params = uri.query;\n\n\t\t\t\t// 'data' is either the POST body if it exists, or the 'd' variable\n\t\t\t\trequest.data = body || params.d || null;\n\t\t\t\tif (resource === 'handshake') {\n\t\t\t\t\tassertOrRenderError(!params.s, 400, 'Handshake cannot have session');\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvar dict = JSON.parse(request.data);\n\t\t\t\t\t\t// make sure our json dict is an object literal\n\t\t\t\t\t\tassert((dict instanceof Object) && !(dict instanceof Array));\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\tlogger.debug('INVALID HANDSHAKE, ', request, err);\n\t\t\t\t\t\tthrow new CSPError(400, 'Invalid data parameter for handshake');\n\t\t\t\t\t};\n\t\t\t\t\tvar session = new exports.Session();\n\t\t\t\t\tvar connection = new exports.Connection(session);\n\t\t\t\t\tsession.connection = connection;\n\t\t\t\t\tthis.emit('connection', connection);\n\t\t\t\t\tconnection.emit('connect');\n\t\t\t\t} else {\n\t\t\t\t\tvar session = sessionDict[params.s];\n\t\t\t\t\tassertOrRenderError(session, 400, 'Invalid or missing session');\n\t\t\t\t\t// 'ackId' is either the 'Last-Event-Id' header, or the 'a' variable\n\t\t\t\t\tvar ackId = parseInt(request.headers['Last-Event-Id']) || parseInt(params.a) || -1;\n\t\t\t\t\tsession.receiveAck(ackId);\n\t\t\t\t};\n\t\t\t\tsession.updateVars(params);\n\t\t\t\tsession.dispatch[resource].call(session, request, response); // logic is in session\n\t\t\t}\n\t\t\tcatch (err) {\n\t\t\t\tif (err instanceof CSPError) {\n\t\t\t\t\trenderError(response, err.code, err.message);\t\t\t\t\t \n\t\t\t\t} else {\n\t\t\t\t\tlogger.warn('Unexpected Error: ', err.message);\n\t\t\t\t\trenderError(response, 500, 'Unknown Server error');\n\t\t\t\t};\n\t\t\t};\n\t\t}));\n\t};\n\tthis.listen = function (port, host) {\n\t\tvar server = http.createServer(bind(this, this._handleRequest));\n\t\tif (!port) { throw logger.error('No port specified'); }\n\t\tserver.listen(port, host);\n\t};\n});\n\n/* // un-comment to run echo server when this file runs\n\njsio.__env.include('/utils.js');\nfunction start_echo_server () {\n\tvar server = csp.createServer(function(connection) {\n\t\tconnection.addListener('receive', function (data) {\n\t\t\tconnection.send(data);\n\t\t});\n\t});\n\tserver.listen(8000);\n\tputs('CSP-based echo server running.');\n};\n\nstart_echo_server();\n*/\n");
jsio.setCachedSrc("../../packages/std/uuid.js",'/*\nBased on Math.uuid.js 1.4 by Robert Kieffer\n\n----\nCopyright (c) 2008, Robert Kieffer\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n  * Redistributions of source code must retain the above copyright notice,\n\tthis list of conditions and the following disclaimer.\n  * Redistributions in binary form must reproduce the above copyright\n\tnotice, this list of conditions and the following disclaimer in the\n\tdocumentation and/or other materials provided with the distribution.\n  * Neither the name of Robert Kieffer nor the names of its contributors\n\tmay be used to endorse or promote products derived from this software\n\twithout specific prior written permission.\n  \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n\n*/\n\n\n\n/*\n * Generate a random uuid.\n *\n * USAGE: uuid.uuid(length, radix)\n *   length - the desired number of characters\n *   radix  - the number of allowable values for each character.\n *\n * EXAMPLES:\n *   // No arguments  - returns RFC4122, version 4 ID\n *   >>> std.uuid()\n *   "92329D39-6F5C-4520-ABFC-AAB64544E172"\n * \n *   // One argument - returns ID of the specified length\n *   >>> std.uuid(15)\t // 15 character ID (default base=62)\n *   "VcydxgltxrVZSTV"\n *\n *   // Two arguments - returns ID of the specified length, and radix. (Radix must be <= 62)\n *   >>> std.uuid(8, 2)  // 8 character ID (base=2)\n *   "01001010"\n *   >>> std.uuid(8, 10) // 8 character ID (base=10)\n *   "47473046"\n *   >>> std.uuid(8, 16) // 8 character ID (base=16)\n *   "098F4D35"\n */\n\n\nvar CHARS = \'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\'.split(\'\'); \nexports.uuid = function (len, radix) {\n\tvar chars = CHARS, uuid = [], rnd = Math.random;\n\tradix = radix || chars.length;\n\n\tif (len) {\n\t\t// Compact form\n\t\tfor (var i = 0; i < len; i++) uuid[i] = chars[0 | rnd()*radix];\n\t} else {\n\t\t// rfc4122, version 4 form\n\t\tvar r;\n\n\t\t// rfc4122 requires these characters\n\t\tuuid[8] = uuid[13] = uuid[18] = uuid[23] = \'-\';\n\t\tuuid[14] = \'4\';\n\n\t\t// Fill in random data.  At i==19 set the high bits of clock sequence as\n\t\t// per rfc4122, sec. 4.1.5\n\t\tfor (var i = 0; i < 36; i++) {\n\t\t\tif (!uuid[i]) {\n\t\t\t\tr = 0 | rnd()*16;\n\t\t\t\tuuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r & 0xf];\n\t\t\t}\n\t\t}\n\t}\n\treturn uuid.join(\'\');\n};\n\n');
jsio.setCachedSrc("../../packages/net/env/node/csp.js",'jsio(\'import net.interfaces\');\njsio(\'from .csp.server import createServer\');\n\nvar Transport = Class(net.interfaces.Transport, function() {\n\tthis.init = function(socket) {\n\t\tthis._socket = socket;\n\t\tlogger.debug(\'init\', socket);\n\t}\n\n\tthis.makeConnection = function(protocol) {\n\t\tlogger.debug(\'makeConnection:\', protocol);\n\t\tthis._socket.addListener("receive", bind(protocol, \'dataReceived\'));\n\n\t\tthis._socket.addListener("eof", this._socket.close);\n\t\tthis._socket.addListener("close", bind(protocol, \'connectionLost\')); // TODO: map error codes\n\t}\n\n\tthis.write = function(data) {\n\t\tthis._socket.send(data);\n\t}\n\n\tthis.loseConnection = function() {\n\t\tthis._socket.forceClose();\n\t}\n});\n\nexports.Listener = Class(net.interfaces.Listener, function(supr) {\n\tthis.listen = function() {\n\t\tvar s = createServer(bind(this, function(socket) {\n\t\t\tlogger.info("Incoming connection");\n\t\t\tsocket.setEncoding("utf8");\n\t\t\tsocket.addListener("connect", bind(this, function() {\n\t\t\t\tthis.onConnect(new Transport(socket));\n\t\t\t}));\n\t\t}));\n\t\tthis._cspServer = s;\n\t\tvar listenString = (this._opts.interface || "" ) + ":" + this._opts.port;\n\t\t// TODO: Show class name\n\t\tif (!this._opts.skipListen) {\n\t\t\tlogger.info("Listening csp@" + listenString);\n\t\t\ts.listen(this._opts.port, this._opts.interface || "");\n\t\t}\n\t}\n});\n');
jsio.setCachedSrc("../../packages/net/env/node/stdio.js","jsio('import net.interfaces');\n\nvar Transport = Class(net.interfaces.Transport, function(supr) {\n    this.init = function(inStream, outStream) {\n        this._inStream = inStream;\n        this._outStream = outStream;\n        this.setEncoding('plain')\n    }\n\n    this.setEncoding = function(encoding) {\n        supr(this, 'setEncoding', arguments);\n        if (encoding == 'plain') {\n            encoding = 'binary';\n        }\n        this._inStream.setEncoding(encoding);\n        this._outStream.setEncoding(encoding);\n    }\n\n    this.makeConnection = function(protocol) {\n        this._inStream.on('data', bind(protocol, 'dataReceived'));\n\t\tthis._inStream.on('end', bind(protocol, 'connectionLost'));\n    }\n\t\n    this.write = function(data) {\n        this._outStream.write(data);\n        this._outStream.flush();\n    }\n\n    this.loseConnection = function() {\n    }\n});\n\n\nexports.Connector = Class(net.interfaces.Connector, function() {\n    this.connect = function() {\n        var stdin = process.openStdin();\n        var stdout = process.stdout\n        var transport = new Transport(stdin, stdout)\n        this.onConnect(transport);\n    }\n});\n");
jsio.setCachedSrc("../../packages/net/env/node/tcp.js",'jsio(\'import net.interfaces\');\n\nvar nodeTcp = jsio.__env.require(\'net\');\n\nvar Transport = Class(net.interfaces.Transport, function() {\n\tthis.init = function(socket) {\n\t\tthis._socket = socket;\n\t}\n\n\tthis.makeConnection = function(protocol) {\n\t\tthis._socket.addListener("data", bind(protocol, \'dataReceived\'));\n\t\tthis._socket.addListener("close", bind(protocol, \'connectionLost\')); // TODO: map error codes\n\t\tthis._socket.addListener("end", this._socket.close);\n\t}\n\n\tthis.write = function(data) {\n\t\tthis._socket.write(data);\n\t}\n\n\tthis.loseConnection = function() {\n\t\tthis._socket.forceClose();\n\t}\n});\n\n\nexports.Connector = Class(net.interfaces.Connector, function() {\n\tthis.connect = function() {\n\t\t\n\t\tvar conn = nodeTcp.createConnection(this._opts.port, this._opts.host);\n\t\tconn.addListener("connect", bind(this, function() {\n\t\t\tthis.onConnect(new Transport(conn));\n\t\t}))\n//\t\tconn.addListener("close", bind(this, function() {\n//\t\t\tthis.onDisconnect();\n//\t\t}))\n//\t\tconn.addListener("receive", bind(this._protocol, \'dataReceived\'));\n\t\tthis._opts.encoding = \'plain\';\n\t\tconn.setEncoding("binary");\n\t\tif (typeof this._opts.timeout == \'number\') { conn.setTimeout(this._opts.timeout); }\n\t}\n});\n\nexports.Listener = Class(net.interfaces.Listener, function(supr) {\n\tthis.listen = function() {\n\t\tvar s = nodeTcp.createServer(bind(this, function(socket) {\n\t\t\tif (typeof this._opts.timeout == \'number\') { socket.setTimeout(this._opts.timeout) }\n\t\t\tsocket.setEncoding("utf8");\n\t\t\tsocket.addListener("connect", bind(this, function() {\n\t\t   \t\tthis.onConnect(new Transport(socket));\n   \t\t\t}));\n   \t\t}));\n\t\tvar listenString = (this._opts.interface || "" ) + ":" + this._opts.port;\n\t\t// TODO: Show class name\n\t\tlogger.info("Listening tcp@" + listenString);\n\t\ts.listen(this._opts.port, this._opts.interface || "");\n\t}\n});\n');
jsio.setCachedSrc("../../packages/net/protocols/buffered.js","jsio('from net.interfaces import Protocol');\njsio('from net.buffer import Buffer');\n\nexports.BufferedProtocol = Class(Protocol, function(supr) {\n\n\tthis.init = function() {\n\t\tthis.buffer = new Buffer();\n\t}\n\n\t// Overwrite this instead of dataReceived in base classes\n\tthis.bufferUpdated = function() {}\n\n\tthis.dataReceived = function(data) {\n\t\tthis.buffer.append(data);\n\t\tthis.bufferUpdated();\n\t}\n\n})");
jsio.setCachedSrc("../../packages/net/buffer.js",'jsio(\'from net.interfaces import Protocol\');\n\nvar EmptyBufferError = exports.EmptyBufferError = Class(function () {\n\tthis.init = function(message) { this.message = message; }\n})\n\nexports.Buffer = Class(function(supr) {\n\n\tthis.init = function(rawBuffer) {\n\t\t\n\t\tthis._rawBuffer = !!rawBuffer ? rawBuffer : "";\n\t}\n\n\tthis.getLength = function() {\n\t\treturn this._rawBuffer.length;\n\t}\n\n\tthis.append = function(data) {\n\t\tlogger.debug(\'append\', JSON.stringify(data));\n\t\tthis._rawBuffer += data;\n\t}\n\n\tthis.peekBytes = function(num) {\n\t\tif (!!num)\n\t\t\treturn this._rawBuffer.slice(0, num);\n\t\telse \n\t\t\treturn this._rawBuffer;\n\t}\n\n\tthis.peekToDelimiter = function(delimiter) {\n\t\tdelimiter = delimiter ? delimiter : \'\\n\';\n\t\tvar i = this._rawBuffer.indexOf(delimiter);\n\t\tif (i == -1)\n\t\t\tthrow new EmptyBufferError("delimiter " + delimiter + "not present in buffer");\n\t\telse\n\t\t\treturn this._rawBuffer.slice(0, i);\n\t}\n\n\tthis.consumeBytes = function(num) {\n\t\tvar output = this.peekBytes(num);\n\t\tthis._rawBuffer = this._rawBuffer.slice(output.length);\n\t\treturn output;\n\t}\n\tthis.consumeMaxBytes = function(num) {\n\t\tvar output = this._rawBuffer.slice(0, num);\n\t\tthis._rawBuffer = this._rawBuffer(num);\n\t\treturn output;\n\t}\n\tthis.consumeAllBytes = function() {\n\t\tvar temp = this._rawBuffer;\n\t\tthis._rawBuffer = "";\n\t\treturn temp;\n\t}\n\t\n\tthis.consumeThroughDelimiter = function(delimiter) {\n\t\treturn this.consumeToDelimiter(delimiter) + this.consumeBytes(delimiter.length);\n\t}\n\n\tthis.consumeToDelimiter = function(delimiter) {\n\t\tdelimiter = !!delimiter ? delimiter : "\\n"\n\t\tvar output = this.peekToDelimiter(delimiter);\n\t\tthis._rawBuffer = this._rawBuffer.slice(output.length);\n\t\treturn output;\n\t}\n\n\tthis.hasBytes = function(num) {\n\t\tnum = num ? num : 0;\n\t\treturn this._rawBuffer.length >= num;\n\t}\n\n\tthis.hasDelimiter = function(delimiter) {\n\t\tdelimiter = !!delimiter ? delimiter : \'\\n\';\n\t\treturn (this._rawBuffer.indexOf(delimiter) != -1);\n\t}\n\n})\n');
jsio.setCachedSrc("../../packages/net/protocols/Cuppa.js","\njsio(\"import lib.Callback;\");\njsio(\"import lib.PubSub;\");\n\njsio(\"from net.protocols.rtjp import RTJPProtocol;\");\n\nlogger.setLevel(0);\n\nvar Error = Class(function() {\n\tthis.init = function(protocol, id, msg, details, requestId) {\n\t\tthis.id = id;\n\t\tthis.msg = msg;\n\t\tthis.details = details;\n\t\tthis.requestId = requestId;\n\t}\n});\n\nvar RPCRequest = Class(function() {\n\tthis.init = function(protocol, id) {\n\t\tthis.protocol = protocol;\n\t\tthis.id = id;\n\t\tthis._onError = new lib.Callback();\n\t\tthis._onSuccess = new lib.Callback();\n\t}\n\n\tthis.onError = function() { this._onError.forward(arguments); }\n\tthis.onSuccess = function() { this._onSuccess.forward(arguments); }\n\t\n\tthis.bindLater = function(l) {\n\t\tvar args = [].slice(arguments, 1);\n\t\tthis._onError.forward([l, l.fail].concat(args));\n\t\tthis._onSuccess.forward([l, l.succed].concat(args));\n\t\treturn l;\n\t}\n\t\n\t\n});\n\nvar ReceivedRequest = Class(function() {\n\tthis.type = \"request\"\n\n\tthis.init = function(protocol, id, name, args, target) {\n\t\tthis.protocol = protocol\n\t\tthis.id = id;\n\t\tthis.name = name\n\t\tthis.responded = false;\n\t\tthis.args = args;\n\t\tthis.target = target;\n\t}\n\n\tthis.error = function(msg, details) {\n\t\tif (this.responded) { throw new Error(\"already responded\"); }\n\t\tif (this._timer) { \n\t\t\tclearTimeout(this._timer); \n\t\t\tthis._timer = null; \n\t\t}\n\t\targs = {\n\t\t\tid: this.id,\n\t\t\tmsg: msg + \"\"\n\t\t}\n\t\tif (details !== undefined) { args.details = details }\n\t\tthis.responded = true;        \n\t\tthis.protocol.sendFrame('ERROR', args);\n\t}\n\n\tthis.respond = function(args) {\n\t\tif (this.responded) { throw new Error(\"already responded\"); }\n\t\tif (this._timer) { \n\t\t\tclearTimeout(this._timer); \n\t\t\tthis._timer = null; \n\t\t}\n\t\tthis.responded = true;\n\t\tthis.protocol.sendFrame('RESPONSE', {\n\t\t\tid: this.id,\n\t\t\targs: args == undefined ? {} : args // python cuppa ignores responses with undefined args\n\t\t});\n\t}\n\t\n\tthis.timeoutAfter = function(duration, msg) {\n\t\tif (this.responded) { return; }\n\t\tif (this._timer) { clearTimeout(this._timer); }\n\t\tthis._timer = setTimeout(bind(this, '_timeout', msg), duration);\n\t}\n\t\n\tthis._timeout = function(msg) {\n\t\tif (!this.responded) {\n\t\t\tthis.error(msg);\n\t\t}\n\t}\n    \n});\n\nvar ReceivedEvent = Class(function() {\n\tthis.init = function(protocol, id, name, args, target) {\n\t\tthis.id = id;\n\t\tthis.name = name;\n\t\tthis.args = args;\n\t\tthis.target = target;\n\t}\n});\n\nexports = Class(RTJPProtocol, function(supr) {\n\tthis.init = function() {\n\t\tsupr(this, 'init', arguments);\n\t\t\n\t\tthis._onConnect = new lib.Callback();\n\t\tthis._onDisconnect = new lib.Callback();\n\t\t\n\t\tthis._requests = {};\n\t\t\n\t\tthis.onEvent = new lib.PubSub();\n\t\tthis.onRequest = new lib.PubSub();\n\t}\n\t\n\tthis.disconnect = function() { this.transport.loseConnection(); }\n\t\n\t// pass something to call (ctx, method, args...) when connected\n\tthis.onConnect = function() { this._onConnect.forward(arguments); }\n\tthis.onDisconnect = function() { this._onDisconnect.forward(arguments); }\n\t\n\tthis.reset = function() {\n\t\tthis._onConnect.reset();\n\t\tthis._onDisconnect.reset();\n\t}\n\t\n\t// called when we're connected\n\tthis.connectionMade = function() {\n\t\tthis._isConnected = true;\n\t\tthis._onConnect.fire();\n\t}\n\t\n\tthis.connectionLost = function(err) {\n\t\tfor (var i in this._requests) {\n\t\t\tvar req = this._requests[i];\n\t\t\tdelete this._requests[i];\n\t\t\treq._onError.fire(err);\n\t\t}\n\t\t\n\t\tthis._isConnected = false;\n\t\tthis._onDisconnect.fire(err);\n\t}\n\t\n\tthis.sendRequest = function(name, args, target, cb) {\n\t\tif (arguments.length > 4) { // allow bound functions (e.g. [this, 'onResponse', 123])\n\t\t\tcb = bind.apply(GLOBAL, Array.prototype.slice.call(arguments, 3));\n\t\t}\n\t\t\n\t\tlogger.debug('SEND REQUEST', name, args, target);\n\t\t\n\t\tvar frameArgs = {\n\t\t\tname: name,\n\t\t\targs: args\n\t\t};\n\t\t\n\t\tif (target) { frameArgs.target = target; }\n\t\t\n\t\tvar id = this.sendFrame('RPC', frameArgs),\n\t\t\treq = this._requests[id] = new RPCRequest(this, id);\n\t\t\n\t\tif (cb) {\n\t\t\treq.onSuccess(GLOBAL, cb, false); // will call cb(false, args...)\n\t\t\treq.onError(GLOBAL, cb); // will call cb(err)\n\t\t}\n\t\t\n\t\treturn req;\n\t}\n\t\n\tthis.sendEvent = function(name, args, target) {\n\t\tlogger.debug('SEND EVENT', name, args, target);\n\t\tthis.sendFrame('EVENT', {name: name, args: args, target: target || null});\n\t}\n\t\n\tthis.frameReceived = function(id, name, args) {\n\t\tlogger.debug('RECEIVED', id, name, args);\n\t\tswitch(name.toUpperCase()) {\n\t\t\tcase 'RESPONSE':\n\t\t\t\tvar req = this._requests[args.id];\n\t\t\t\tif (!req) { return; }\n\t\t\t\tdelete this._requests[args.id];\n\t\t\t\treq._onSuccess.fire(args.args);\n\t\t\t\tbreak;\n\t\t\tcase 'ERROR':\n\t\t\t\tvar msg = args.msg || 'unknown',\n\t\t\t\t\trequestId = args.id,\n\t\t\t\t\treq = this._requests[requestId],\n\t\t\t\t\terr = new Error(this, id, msg, args.details, requestId);\n\t\t\t\t\n\t\t\t\tif (!req) {\n\t\t\t\t\treturn this.errorReceived(err);\n\t\t\t\t} else {\n\t\t\t\t\tdelete this._requests[requestId];\n\t\t\t\t\treq._onError.fire(err);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'RPC':\n\t\t\tcase 'EVENT':\n\t\t\t\tlogger.debug('RECEIVED', name, args.name);\n\t\t\t\t\n\t\t\t\tif (!args.name) {\n\t\t\t\t\treturn self.sendFrame('ERROR', { 'id': args.id || id, 'msg': 'missing \"name\"' });\n\t\t\t\t}\n\t\t\t\tvar frameArgs = args.args || {},\n\t\t\t\t\ttarget = args.target || null,\n\t\t\t\t\tisRPC = name.toUpperCase() == 'RPC',\n\t\t\t\t\treqCtor = isRPC ? ReceivedRequest : ReceivedEvent,\n\t\t\t\t\tpubTarget = isRPC ? this.onRequest : this.onEvent,\n\t\t\t\t\treq = new reqCtor(this, args.id || id, args.name, frameArgs, target);\n\t\t\t\t\n\t\t\t\tpubTarget.publish(req.name, req);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n});\n");
jsio.setCachedSrc("../../packages/net/protocols/rtjp.js",'jsio(\'import net.interfaces\');\njsio(\'from net.protocols.delimited import DelimitedProtocol\');\n\nexports.RTJPProtocol = Class(DelimitedProtocol, function(supr) {\n\tthis.init = function() {\n\t\tvar delimiter = \'\\r\\n\';\n\t\tsupr(this, \'init\', [delimiter]);\n\t\tthis.frameId = 0;\n\t}\n\n\tthis.connectionMade = function() {\n\t\tif (this._client && this._client.connectionMade) { this._client.connectionMade(); }\n\t\tlogger.debug("connectionMade");\n\t}\n\t\n\tvar error = function(e) {\n\t\tlogger.error(e);\n\t}\n\t\n\t// Inherit and overwrite\n\tthis.frameReceived = function(id, name, args) {\n\t}\n\n\t// Public\n\tthis.sendFrame = function(name, args) {\n\t\tif (!args) {\n\t\t\targs = {}\n\t\t}\n\t\tlogger.debug(\'sendFrame\', name, args);\n\t\tthis.sendLine(JSON.stringify([++this.frameId, name, args]));\n\t\treturn this.frameId;\n\t}\n\n\tthis.lineReceived = function(line) {\n\t\ttry {\n\t\t\tvar frame = JSON.parse(line);\n\t\t\tif (frame.length != 3) {\n\t\t\t\treturn error.call(this, "Invalid frame length");\n\t\t\t}\n\t\t\tif (typeof(frame[0]) != "number") {\n\t\t\t\treturn error.call(this, "Invalid frame id");\n\t\t\t}\n\t\t\tif (typeof(frame[1]) != "string") {\n\t\t\t\treturn error.call(this, "Invalid frame name");\n\t\t\t}\n\t\t\tlogger.debug("frameReceived:", frame[0], frame[1], frame[2]);\n\t\t} catch(e) {\n\t\t\terror.call(this, e);\n\t\t}\n\t\t\n\t\tif (frame) {\n\t\t\tthis.frameReceived(frame[0], frame[1], frame[2]);\n\t\t}\n\t}\n\n\tthis.connectionLost = function() {\n\t\tlogger.debug(\'conn lost\');\n\t}\n});\n\n\n\n');
jsio.setCachedSrc("../../packages/net/protocols/delimited.js","jsio('import net.interfaces');\n\nexports.DelimitedProtocol = Class(net.interfaces.Protocol, function(supr) {\n\n\tthis.init = function(delimiter) {\n\t\tif (!delimiter) {\n\t\t\tdelimiter = '\\r\\n'\n\t\t}\n\t\tthis.delimiter = delimiter;\n\t\tthis.buffer = \"\"\n\t}\n\t\n\tthis.connectionMade = function() {\n\t\tlogger.debug('connectionMade');\n\t}\n\t\n\tthis.dataReceived = function(data) {\n\t\tif (!data) { return; }\n\t\tlogger.debug('dataReceived:(' + data.length + ')', data);\n\t\tlogger.debug('last 2:', data.slice(data.length-2));\n\t\tthis.buffer += data;\n\t\tlogger.debug('index', this.buffer.indexOf(this.delimiter));\n\t\tvar i;\n\t\twhile ((i = this.buffer.indexOf(this.delimiter)) != -1) {\n\t\t\tvar line = this.buffer.slice(0, i);\n\t\t\tthis.buffer = this.buffer.slice(i + this.delimiter.length);\n\t\t\tthis.lineReceived(line);\n\t\t}\n\t}\n\n\tthis.lineReceived = function(line) {\n\t\tlogger.debug('Not implemented, lineReceived:', line);\n\t}\n\tthis.sendLine = function(line) {\n\t\tlogger.debug('WRITE:', line + this.delimiter);\n\t\tthis.transport.write(line + this.delimiter);\n\t}\n\tthis.connectionLost = function() {\n\t\tlogger.debug('connectionLost');\n\t}\n});\n\n");
jsio.setCachedSrc("../../packages/net/protocols/echo.js","jsio('import net.interfaces');\n\nexports.Protocol = Class(net.interfaces.Protocol, function() {\n\tthis.connectionMade = function() {\n\t\tlogger.debug('in connectionMade');\n\t\tthis.transport.write('Welcome')\n\t}\n\t\n\tthis.dataReceived = function(data) {\n\t\tlogger.debug('dataReceived:', data);\n\t\tthis.transport.write('Echo: ' + data);\n\t}\n\tthis.connectionLost = function() {\n\t\tlogger.debug('conn lost');\n\t}\n});\n\nexports.Server = Class(net.interfaces.Server, function(supr) {\n\tthis.init = function() {\n\t\tsupr(this, 'init', [exports.Protocol]);\n\t}\n});\n\n");
jsio.setCachedSrc("../../packages/net/protocols/mspp.js","jsio('import net');\njsio('from net.protocols.buffered import BufferedProtocol');\njsio('import std.utf8 as utf8');\n\n/*\nworks like this:\nOPEN\nupstream:\nlength_after_colon:id,0host,port\n\ndownstream:\nlength_after_colon:id,0\n-----\nCLOSE\nupstream:\nlength_after_colon:id,1\n\ndownstream:\nlength_after_colon:id,1errcode\n-----\nDATA\nupstream/downstream:\nlength_after_colon:id,2datadatadata\n*/\n\nvar loggers = {};\nloggers.stream = logging.getLogger('MSPPStream');\nloggers.protocol = logging.getLogger('MSPPProtocol');\n\nvar frames = {\n\t'OPEN':  0,\n\t'CLOSE': 1,\n\t'DATA':  2\n};\n\nexports.MSPPStream = Class(function() {\n\tthis.setMultiplexer = function(multiplexer) {\n\t\tloggers.stream.debug('setMultiplexer: '+multiplexer);\n\t\tthis.multiplexer = multiplexer;\n\t}\n\n\tthis.setEncoding = function(encoding) {\n\t\tloggers.stream.debug('setEncoding: '+encoding);\n\t\tthis.encoding = encoding;\n\t}\n\n\tthis.open = function(host, port, isBinary) {\n\t\tif (isBinary)\n\t\t\tthis.encoding = 'utf8';\n\t\tthis.id = this.multiplexer.openStream(this, host, port);\n\t\tloggers.stream.debug('open '+this.id+\": \"+host+\" \"+port+\" \"+isBinary);\n\t}\n\n\tthis.close = function() {\n\t\tloggers.stream.debug('close '+this.id);\n\t\tthis.multiplexer.close(this.id);\n\t}\n\n\tthis.send = function(data, encoding) {\n\t\tloggers.stream.debug('send '+this.id+\": \"+data+\" \"+encoding);\n\t\tif ((encoding || this.encoding) == 'utf8')\n\t\t\tdata = utf8.encode(data);\n\t\tthis.multiplexer.writeToStream(this.id, data);\n\t}\n\n\tthis._onreadraw = function(data) {\n\t\tif (this.encoding == 'utf8') {\n\t\t\tvar raw = utf8.decode(data);\n\t\t\tvar length = raw[1];\n\t\t\t// TODO: actually buffer this stuff properly\n\t\t\tif (length != data.length) {\n\t\t\t\tthrow new Error(\"Incomplete utf8 codepoint\");\n\t\t\t}\n\t\t\tdata = raw[0]\n\t\t}\n\t\tloggers.stream.debug('_onreadraw '+data);\n\t\tthis.onread(data);\n\t}\n\n\tthis.onopen = function() {}\n\tthis.onclose = function(err) {}\n\tthis.onread = function(data) {}\n});\n\nvar state = {};\nstate.closed = 0;\nstate.connecting = 1;\nstate.consuming = 2;\n\nexports.MSPPProtocol = Class(BufferedProtocol, function(supr) {\n\tthis.init = function() {\n\t\tloggers.protocol.debug('new MSPPProtocol');\n\t\tsupr(this, 'init', []);\n\t\tthis.state = state.closed;\n\t\tthis.transportType = null;\n\t\tthis.transportOptions = null;\n\t\tthis.currentId = 0;\n\t\tthis.streams = {};\n\t\tthis.writeBuffer = [];\n\t}\n\n\tthis.setTransport = function(transportType, transportOptions) {\n\t\tthis.transportType = transportType;\n\t\tthis.transportOptions = transportOptions;\n\t}\n\n\tthis.connectionMade = function(isReconnect) {\n\t\tloggers.protocol.debug('connectionMade');\n\t\tthis.state = state.consuming;\n\t\tfor (var i = 0; i < this.writeBuffer.length; i++)\n\t\t\tthis._write(this.writeBuffer[i]);\n\t\twriteBuffer = [];\n\t}\n\n\tthis.connectionLost = function(reason) {\n\t\tloggers.protocol.debug('closed: '+reason);\n\t\tthis.state = state.closed;\n\t\tfor (var stream in this.streams)\n\t\t\tthis.streams[stream].onclose(reason);\n\t}\n\n\tthis.openStream = function(stream, host, port) {\n\t\tif (this.state == state.closed) {\n\t\t\tthis.state = state.connecting;\n\t\t\tnet.connect(this, this.transportType, this.transportOptions);\n\t\t}\n\t\tvar id = ++this.currentId;\n\t\tthis.streams[id] = stream;\n\t\tthis._write([id, frames.OPEN, host+\",\"+port]);\n\t\treturn id;\n\t}\n\n\tthis.closeStream = function(id) {\n\t\tthis._write([id, frames.CLOSE, \"\"]);\n\t}\n\n\tthis.writeToStream = function(id, data) {\n\t\tthis._write([id, frames.DATA, data]);\n\t}\n\n\tthis.bufferUpdated = function() {\n\t\tloggers.protocol.debug(\"bufferUpdated. state: \"+this.state+\". buffer: \"+this.buffer._rawBuffer);\n\t\tif (this.state != state.consuming)\n\t\t\tthrow new Error(\"buffer update in invalid MSPP state: \"+this.state);\n\t\tif (! this.buffer.hasDelimiter(':'))\n\t\t\treturn;\n\t\tvar lStr = this.buffer.peekToDelimiter(':');\n\t\tvar len = parseInt(lStr);\n\t\tif (! this.buffer.hasBytes(len + lStr.length + 1))\n\t\t\treturn;\n\t\tthis.buffer.consumeThroughDelimiter(':');\n\t\tvar streamId = this.buffer.consumeToDelimiter(',');\n\t\tthis.buffer.consumeBytes(1);\n\t\tvar frameType = parseInt(this.buffer.consumeBytes(1));\n\t\tlen -= (streamId.length + 2);\n\t\tstreamId = parseInt(streamId);\n\t\tvar data = this.buffer.consumeBytes(len);\n\t\tswitch(frameType) {\n\t\t\tcase frames.OPEN:\n\t\t\t\tthis.streams[streamId].onopen();\n\t\t\t\tbreak;\n\t\t\tcase frames.CLOSE:\n\t\t\t\tthis.streams[streamId].onclose(data);\n\t\t\t\tbreak;\n\t\t\tcase frames.DATA:\n\t\t\t\tthis.streams[streamId]._onreadraw(data);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error('invalid MSPP data type!');\n\t\t}\n\t}\n\n\tthis._write = function(data) {\n\t\tif (this.state != state.consuming) {\n\t\t\tloggers.protocol.debug(\"buffering write: \"+data);\n\t\t\tthis.writeBuffer.push(data);\n\t\t\treturn;\n\t\t}\n\t\tvar s = data[0] + \",\" + data[1] + data[2];\n\t\ts = s.length + \":\" + s;\n\t\tloggers.protocol.debug('write: '+s);\n\t\tthis.transport.write(s);\n\t}\n});\n");
jsio.setCachedSrc("../../packages/net/protocols/stomp.js","jsio('from net.protocols.buffered import BufferedProtocol');\njsio('from util.sprintf import sprintf');\n\nexports.StompProtocol = Class(BufferedProtocol, function(supr) {\n\n\tthis.init = function() {\n\t\tsupr(this, 'init', []);\n\t\tthis.state = 'peek';\n\t}\n\n\tthis.connect = function(username, password) {\n\t\tvar frame = new StompFrame('CONNECT')\n\t\tif (!!username)\n\t\t\tframe.setHeader('login', username);\n\t\tif (!!password)\n\t\t\tframe.setHeader('passcode', password);\n\t\tthis.sendFrame(frame);\n\t}\n\n\tthis.send = function(destination, body, headers) {\n\t\tvar frame = new StompFrame('SEND', body, headers)\n\t\tframe.setHeader('destination', destination);\n\t\tthis.sendFrame(frame);\n\t}\n\n\tthis.subscribe = function(destination, headers) {\n\t\tvar frame = new StompFrame('SUBSCRIBE', null, headers)\n\t\tframe.setHeader('destination', destination);\n\t\tthis.sendFrame(frame);\n\t}\n\tthis.unsubscribe = function(destination, headers) {\n\t\tvar frame = new StompFrame('UNSUBSCRIBE', null, headers)\n\t\tframe.setHeader('destination', destination);\n\t\tthis.sendFrame(frame);\n\t}\n\n\tthis.sendFrame = function(frame) {\n\t\tthis.transport.write(frame.serialize());\n\t}\n\n\tthis.frameReceived = function(frame) {\n\t\tlogger.info('frame received', frame);\n\t}\n\t\n\tthis.bufferUpdated = function() {\n\t\tlogger.debug('bufferUpdated');\n\t\tvar counter = 0;\n\t\twhile (++counter < 10) {\n\t\t\tswitch(this.state) {\n\t\t\t\tcase 'peek':\n\t\t\t\t\tif (this.buffer.peekBytes(1) == '\\n') {\n\t\t\t\t\t\tlogger.debug('consuming a single \\n byte')\n\t\t\t\t\t\tthis.buffer.consumeBytes(1)\n\t\t\t\t\t}\n\t\t\t\t\tthis.state = 'method';\n\t\t\t\t\t/* FALL THROUGH */\n\t\t\t\tcase 'method':\n\t\t\t\t\tlogger.debug('case method');\n\t\t\t\t\t// Fix for stomp servers that send extra \\n byte\n\t\t\t\t\tif (!this.buffer.hasLine())\n\t\t\t\t\t\treturn;\n\t\t\t\t\tthis._frame = new StompFrame();\n\t\t\t\t\tvar method = this.buffer.consumeThroughDelimiter();\n\t\t\t\t\tlogger.debug('method is', JSON.stringify(method));\n\t\t\t\t\tthis._frame.setMethod(method);\n\t\t\t\t\tthis.state = 'headers';\n\t\t\t\t\t/* FALL THROUGH */\n\t\t\t\tcase 'headers':\n\t\t\t\t\tlogger.debug('case headers');\n\t\t\t\t\tvar M = 0;\n\t\t\t\t\twhile (this.buffer.hasLine() && ++M < 10) {\n\t\t\t\t\t\tvar line = this.buffer.consumeThroughDelimiter();\n\t\t\t\t\t\tif (line.length == 0) {\n\t\t\t\t\t\t\tthis.state = 'body';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar segments = line.split(':')\n\t\t\t\t\t\tvar key = segments[0];\n\t\t\t\t\t\t// I guess we allow \": \" in the header value.\n\t\t\t\t\t\tvar value = segments.slice(1).join(':')\n\t\t\t\t\t\twhile (value[0] == ' ') value = value.slice(1);\n\t\t\t\t\t\twhile (value[1] == ' ') value = value.slice(0, value.length-1);\n\t\t\t\t\t\tlogger.debug('add header', key, value);\n\t\t\t\t\t\tthis._frame.setHeader(key, value);\n\t\t\t\t\t}\n\t\t\t\t\tif (this.state == 'headers')\n\t\t\t\t\t\treturn;\n\t\t\t\t\t/* FALL THROUGH */\n\t\t\t\tcase 'body':\n\t\t\t\t\tif (this._frame.getBodyMode() == 'length') {\n\t\t\t\t\t\tif (!this.buffer.hasBytes(this._frame.getContentLength()+1))\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\tthis._frame.setBody(this.buffer.consumeBytes(this._frame.getContentLength()))\n\t\t\t\t\t\t// Remove trailing \\x00\n\t\t\t\t\t\tthis.buffer.consumeBytes(1)\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (!this.buffer.hasLine('\\x00'))\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\tthis._frame.setBody(this.buffer.consumeThroughDelimiter('\\x00'));\n\t\t\t\t\t}\n\t\t\t\t\tthis.frameReceived(this._frame);\n\t\t\t\t\tthis._frame = null;\n\t\t\t\t\tthis.state = 'peek';\n\t\t\t\t\t/* FALL THROUGH and LOOP */\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n})\n\nvar StompFrame = exports.StompFrame = Class(function() {\n\n\tthis.init = function(_method, _body, _headers) {\n\t\tthis._headers = !!_headers ? _headers : {}\n\t\tthis._method = !!_method ? _method : null\n\t\tthis._body = !!_body ? _body : \"\";\n\t}\n\tthis.setHeader = function(key, val) {\n\t\tthis._headers[key] = val;\n\t}\n\tthis.getHeader = function(key) {\n\t\treturn this._headers[key];\n\t}\n\tthis.getHeaders = function() {\n\t\treturn this._headers;\n\t}\n\tthis.setMethod = function(m) {\n\t\t// TODO: enforce method constraints here?\n\t\t//\t   -mcarter 9/18/09\n\t\tthis._method = m;\n\t}\n\tthis.getMethod = function() {\n\t\treturn this._method;\n\t}\n\tthis.setBody = function(b) {\n\t\tthis._body = b;\n\t}\n\tthis.getbody = function() {\n\t\treturn this._body;\n\t}\n\tthis.toString = function() {\n\t\tvar i = 0;\n\t\tfor (var key in this._headers) {\n\t\t\t++i;\n\t\t}\n\t\treturn sprintf(\"[StompFrame method(%s), num-headers(%d), body-length(%d)]\", \n\t\t\t\t\t   this._method, i, this._body.length);\n\t}\n\tthis.getContentLength = function() {\n\t\treturn parseInt(this._headers['content-length']);\n\t}\n\tthis.getBodyMode = function() {\n\t\tif ('content-length' in this._headers) {\n\t\t\treturn 'length';\n\t\t}\n\t\treturn 'delimited';\n\t}\n\tthis.serialize = function() {\n\t\tvar output = this._method + '\\n'\n\t\tfor (var key in this._headers) {\n\t\t\toutput += key + ': ' + this._headers[key] + '\\n';\n\t\t}\n\t\toutput += 'content-length: ' + this._body.length + '\\n';\n\t\toutput += '\\n';\n\t\toutput += this._body;\n\t\toutput += '\\x00'\n\t\treturn output;\n\t}\n});\n");
jsio.setCachedSrc("../../packages/util/sprintf.js","// XXX: Lets have a reasonable implementation of this fucntion\n//\t  -mcarter 9/18/09\n\n// Code from http://www.webtoolkit.info/javascript-sprintf.html\n// Seems to be an MIT-like license, with linking in source code required\n// License:\n//   As long as you leave the copyright notice of the original script, or link\n//   back to this website, you can use any of the content published on this \n//   website free of charge for any use: commercial or noncommercial.\n//   (http://www.webtoolkit.info/licence.html 9/18/09)\n\n// there was no original copyright notice in the code. just a link to:\n// http://www.webtoolkit.info\n\n\nvar sprintfWrapper = {\n \n\tinit : function () {\n \n\t\tif (typeof arguments == \"undefined\") { return null; }\n\t\tif (arguments.length < 1) { return null; }\n\t\tif (typeof arguments[0] != \"string\") { return null; }\n\t\tif (typeof RegExp == \"undefined\") { return null; }\n \n\t\tvar string = arguments[0];\n\t\tvar exp = new RegExp(/(%([%]|(\\-)?(\\+|\\x20)?(0)?(\\d+)?(\\.(\\d)?)?([bcdfosxX])))/g);\n\t\tvar matches = new Array();\n\t\tvar strings = new Array();\n\t\tvar convCount = 0;\n\t\tvar stringPosStart = 0;\n\t\tvar stringPosEnd = 0;\n\t\tvar matchPosEnd = 0;\n\t\tvar newString = '';\n\t\tvar match = null;\n \n\t\twhile (match = exp.exec(string)) {\n\t\t\tif (match[9]) { convCount += 1; }\n \n\t\t\tstringPosStart = matchPosEnd;\n\t\t\tstringPosEnd = exp.lastIndex - match[0].length;\n\t\t\tstrings[strings.length] = string.substring(stringPosStart, stringPosEnd);\n \n\t\t\tmatchPosEnd = exp.lastIndex;\n\t\t\tmatches[matches.length] = {\n\t\t\t\tmatch: match[0],\n\t\t\t\tleft: match[3] ? true : false,\n\t\t\t\tsign: match[4] || '',\n\t\t\t\tpad: match[5] || ' ',\n\t\t\t\tmin: match[6] || 0,\n\t\t\t\tprecision: match[8],\n\t\t\t\tcode: match[9] || '%',\n\t\t\t\tnegative: parseInt(arguments[convCount]) < 0 ? true : false,\n\t\t\t\targument: typeof(arguments[convCount]) == 'object' ? JSON.stringify(arguments[convCount]) : String(arguments[convCount])\n\t\t\t};\n\t\t}\n\t\tstrings[strings.length] = string.substring(matchPosEnd);\n \n\t\tif (matches.length == 0) { return string; }\n\t\tif ((arguments.length - 1) < convCount) { return null; }\n \n\t\tvar code = null;\n\t\tvar match = null;\n\t\tvar i = null;\n \n\t\tfor (i=0; i<matches.length; i++) {\n \n\t\t\tif (matches[i].code == '%') { substitution = '%' }\n\t\t\telse if (matches[i].code == 'b') {\n\t\t\t\tmatches[i].argument = String(Math.abs(parseInt(matches[i].argument)).toString(2));\n\t\t\t\tsubstitution = sprintfWrapper.convert(matches[i], true);\n\t\t\t}\n\t\t\telse if (matches[i].code == 'c') {\n\t\t\t\tmatches[i].argument = String(String.fromCharCode(parseInt(Math.abs(parseInt(matches[i].argument)))));\n\t\t\t\tsubstitution = sprintfWrapper.convert(matches[i], true);\n\t\t\t}\n\t\t\telse if (matches[i].code == 'd') {\n\t\t\t\tmatches[i].argument = String(Math.abs(parseInt(matches[i].argument)));\n\t\t\t\tsubstitution = sprintfWrapper.convert(matches[i]);\n\t\t\t}\n\t\t\telse if (matches[i].code == 'f') {\n\t\t\t\tmatches[i].argument = String(Math.abs(parseFloat(matches[i].argument)).toFixed(matches[i].precision ? matches[i].precision : 6));\n\t\t\t\tsubstitution = sprintfWrapper.convert(matches[i]);\n\t\t\t}\n\t\t\telse if (matches[i].code == 'o') {\n\t\t\t\tmatches[i].argument = String(Math.abs(parseInt(matches[i].argument)).toString(8));\n\t\t\t\tsubstitution = sprintfWrapper.convert(matches[i]);\n\t\t\t}\n\t\t\telse if (matches[i].code == 's') {\n\t\t\t\tmatches[i].argument = matches[i].argument.substring(0, matches[i].precision ? matches[i].precision : matches[i].argument.length)\n\t\t\t\tsubstitution = sprintfWrapper.convert(matches[i], true);\n\t\t\t}\n\t\t\telse if (matches[i].code == 'x') {\n\t\t\t\tmatches[i].argument = String(Math.abs(parseInt(matches[i].argument)).toString(16));\n\t\t\t\tsubstitution = sprintfWrapper.convert(matches[i]);\n\t\t\t}\n\t\t\telse if (matches[i].code == 'X') {\n\t\t\t\tmatches[i].argument = String(Math.abs(parseInt(matches[i].argument)).toString(16));\n\t\t\t\tsubstitution = sprintfWrapper.convert(matches[i]).toUpperCase();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsubstitution = matches[i].match;\n\t\t\t}\n \n\t\t\tnewString += strings[i];\n\t\t\tnewString += substitution;\n \n\t\t}\n\t\tnewString += strings[i];\n \n\t\treturn newString;\n \n\t},\n \n\tconvert : function(match, nosign){\n\t\tif (nosign) {\n\t\t\tmatch.sign = '';\n\t\t} else {\n\t\t\tmatch.sign = match.negative ? '-' : match.sign;\n\t\t}\n\t\tvar l = match.min - match.argument.length + 1 - match.sign.length;\n\t\tvar pad = new Array(l < 0 ? 0 : l).join(match.pad);\n\t\tif (!match.left) {\n\t\t\tif (match.pad == \"0\" || nosign) {\n\t\t\t\treturn match.sign + pad + match.argument;\n\t\t\t} else {\n\t\t\t\treturn pad + match.sign + match.argument;\n\t\t\t}\n\t\t} else {\n\t\t\tif (match.pad == \"0\" || nosign) {\n\t\t\t\treturn match.sign + match.argument + pad.replace(/0/g, ' ');\n\t\t\t} else {\n\t\t\t\treturn match.sign + match.argument + pad;\n\t\t\t}\n\t\t}\n\t}\n}\n \nexports.sprintf = sprintfWrapper.init;");
jsio.setCachedSrc("../../packages/net/later.js","exports.Later = Class(function() {\n\tthis.init = function() {\n\t\tthis.cb = null\n\t\tthis.eb = null\n\t\tthis.values = []\n\t\tthis.errors = []\n\t\tthis.cancelback = null;\n\t}\n\t\n\tthis.succeed = this.callback = function() {\n\t\tlogger.debug('callback', [].slice.call(arguments, 0));\n\t\tif (this.cb) {\n\t\t\tvar result = this.cb.apply(this, arguments);\n\t\t\tif (result == false) {\n\t\t\t\tthis.cancel();\n\t\t\t}\n\t\t} else {\n\t\t\tthis.values.push(arguments);\n\t\t}\n\t}\n\n\tthis.fail = this.errback = function() {\n\t\tlogger.debug('eb', [].slice.call(arguments, 0));\n\t\tif (this.eb) {\n\t\t\tthis.eb.apply(this, arguments);\n\t\t}\n\t\telse {\n\t\t\tthis.errors.push(arguments);\n\t\t}\n\t}\n\n   this.cancel = function() {\n\t\tif (this.cancelback) {\n\t\t\tvar cb = this.cancelback;\n\t\t\tthis.cancelback = null;\n\t\t\tcb.call(this);\n\t\t}\n\t}\n\tthis.setCallback = function(cb) {\n\t\tthis.cb = cb;\n\t\tfor (var i = 0, v; v=this.values[i]; ++i) {\n\t\t\tthis.cb.apply(this, v);\n\t\t}\n\t\tthis.values = [];\n\t\treturn this;\n\t}\n\tthis.setErrback = function(eb) {\n\t\tthis.eb = eb;\n\t\tfor (var i = 0, v; e=this.errors[i]; ++i) {\n\t\t\tthis.eb.apply(this, e);\n\t\t}\n\t\tthis.errors = [];\n\t\treturn this;\n\t}\n\tthis.setCancelback = function(cancelback) {\n\t\tthis.cancelback = cancelback;\n\t\treturn this;\n\t}\n})\n\nexports.Later.fail = function() { var l = new Later(); return l.fail.apply(l, arguments); }\nexports.Later.succeed = function() { var l = new Later(); return l.succeed.apply(l, arguments); }\n\n");
jsio.setCachedSrc("../../packages/preprocessors/class.js","var importExpr = /^([^'\"]*)(class\\s+([a-zA-Z][a-zA-Z0-9]*)\\s+.*|from\\s+.*)$/gm;\n\nexports = function(path, moduleDef, opts) {\n\tmoduleDef.src = moduleDef.src.replace(importExpr, '$1' + 'jsio' + '(\"$2\");');\n}\n");jsio.setCachedSrc("../../packages/preprocessors/import.js","var importExpr = /^(\\s*)(import\\s+.*|from\\s+.*)$/gm;\n\nexports = function(path, moduleDef, opts) {\n\tmoduleDef.src = moduleDef.src.replace(importExpr, '$1' + 'jsio' + '(\"$2\");');\n}\n");
jsio.setCachedSrc("../../packages/preprocessors/sanswith.js","var jsioImportG = /jsio\\s*\\(\\s*['\"](.+?)['\"]\\s*(,\\s*(\\{[^}]+\\}))?\\)/g,\n\tjsioImport = /jsio\\s*\\(\\s*['\"](.+?)['\"]\\s*(,\\s*(\\{[^}]+\\}))?\\)/,\n\tcmds = jsio.__jsio.__cmds;\n\nvar gModuleScope;\n\nexports = function(path, moduleDef, opts) {\n\t\n\t// define the globals for the module that are created by import statements\n\tgModuleScope = [];\n\t\n\tfunction replacer(str) {\n\t\tvar match = str.match(jsioImport),\n\t\t\timports = [],\n\t\t\treq = match[1],\n\t\t\tlocalOpts = {}; // TODO: should we try to parse opts?\n\n\t\tfor (var i = 0, cmd; cmd = cmds[i]; ++i) {\n\t\t\tif (cmds[i]({}, req, localOpts, imports)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (var i = 0, len = imports.length; i < len; ++i) {\n\t\t\tif (!imports[i]) { continue; }\n\t\t\tif (imports[i].as) {\n\t\t\t\timports[i] = codeConstruct(imports[i].as) + codeImport(imports[i].from, match[3] || '');\n\t\t\t} else if (imports[i]['import']) {\n\t\t\t\tvar srcs = [],\n\t\t\t\t\tlocals = [],\n\t\t\t\t\tmapping = imports[i]['import'];\n\t\t\t\tfor (var key in mapping) {\n\t\t\t\t\tsrcs.push(key);\n\t\t\t\t\tlocals.push(mapping[key]);\n\t\t\t\t}\n\t\t\t\timports[i] = 'var ' + locals.join(',') + ';(function() {var a=' + codeImport(imports[i].from) + ';';\n\t\t\t\t\n\t\t\t\tfor (var j = 0, len = locals.length; j < len; ++j) {\n\t\t\t\t\timports[i] += locals[j] + '=a.' + srcs[j];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\timports[i] += '})();';\n\t\t\t}\n\t\t}\n\n\t\treturn '/*| ' + match[0] + '; */ ' + imports.join('');\n\t}\n\t\n\t\n\tmoduleDef.src = moduleDef.src.replace(jsioImportG, replacer);\n\t\n\tif (gModuleScope.length) { moduleDef.src = 'var ' + gModuleScope.join(',') + ';' + moduleDef.src; }\n}\n\nGLOBAL.__jsiomerge = function(a, b) {\n\tfor (var k in b) {\n\t\tif(!(k in a)) {\n\t\t\ta[k] = b[k];\n\t\t}\n\t\t\n\t//\tif(!a.preprocessors) { a.preprocessors = []; }\n\t//\ta.preprocessors.push('sanswith');\n\t}\n\treturn a;\n}\n\nfunction codeConstruct(obj) {\n\tvar parts = obj.split('.');\n\tfor (var i = 0; i < parts.length; ++i) {\n\t\tif (!parts[i]) {\n\t\t\tparts.splice(i--, 1);\n\t\t}\n\t}\n\t\n\tvar base = parts.shift(),\n\t\tlast = parts.length - 1;\n\t\n\tgModuleScope.push(base);\n\t\n\treturn last == -1\n\t\t? base + '='\n\t\t: 'if(!' + base + ')' + base+'={};'\n\t\t\t+ parts.map(function(part, i) {\n\t\t\t\tvar name = base + '.' + parts.slice(0, i + 1).join('.');\n\t\t\t\treturn i != last ? 'if(!' + name + ')' + name + '={};' : name + '=';\n\t\t\t}).join('');\n}\n\nvar _jsio = 'jsio';\nfunction codeImport(modulePath, optStr) {\n\treturn _jsio + '(\"import ' + modulePath + '\", __jsiomerge(' + (optStr || '{}') + ', {dontExport: true}))';\n}\n");
jsio.setCachedSrc("../../packages/std/XML.js","\n\nexports.parseString = function(str){\n\tif (jsio.__env.name == 'browser'){\n\t\t// Is it IE? XXX TODO: test this on a Windows computer\n\t\tif (window.ActiveXObject){ \n\t\t\tvar parser = new ActiveXObject('Microsoft.XMLDOM');\n\t\t\treturn parser.loadXML(str);\n\t\t} else {\n\t\t\tvar parser = new DOMParser();\n\t\t\treturn parser.parseFromString(str, 'text/xml');\n\t\t}\n\t}else if(jsio.__env.name == 'node'){\n\t};\n\n};\n");
jsio.setCachedSrc("../../packages/util/ajax.js","\njsio(\"import std.uri as URI;\");\n\nvar doc;\nexports.getDoc = function() {\n\tif (doc) { return doc; }\n\ttry {\n\t\tdoc = window.ActiveXObject && new ActiveXObject('htmlfile');\n\t\tif (doc) {\n\t\t\tdoc.open().write('<html></html>');\n\t\t\tdoc.close();\n\t\t\twindow.attachEvent('onunload', function() {\n\t\t\t\ttry { doc.body.innerHTML = ''; } catch(e) {}\n\t\t\t\tdoc = null;\n\t\t\t});\n\t\t}\n\t} catch(e) {}\n\t\n\tif (!doc) { doc = document; }\n\treturn doc;\n};\n\nvar ctor = function() {\n\tvar win = window,\n\t\tdoc = exports.getDoc();\n\t//if (doc.parentWindow) { win = doc.parentWindow; }\n\t\n\treturn new (ctor = win.XMLHttpRequest ? win.XMLHttpRequest\n\t\t: function() { return win.ActiveXObject && new win.ActiveXObject('Msxml2.XMLHTTP') || null; });\n};\n\nexports.createXHR = function() { return new ctor(); }\n\nexports.post = function(opts, cb) {\n\treturn exports.get(merge({method: 'POST'}, opts), cb);\n}\n\nexports.get = function(opts, cb) {\n\tif (typeof opts == 'string') { opts = {url: opts}; }\n\tvar method = opts.method || 'GET';\n\tvar url = opts.url;\n\tvar isObject = opts.data && typeof opts.data == 'object';\n\tif (!opts.url) { logger.error('no url provided'); return; }\n\t\n\tvar data = method == 'POST' ? isObject ? JSON.stringify(opts.data) : opts.data : null;\n\tif (method == 'GET' && opts.data) {\n\t\turl = new URI(url).addQuery(isObject ? opts.data : URI.parseQuery(opts.data)).toString();\n\t}\n\t\n\tvar xhr = exports.createXHR();\n\txhr.open(method, url, !(opts.async == false));\n\txhr.setRequestHeader('Content-Type', 'text/plain');\n\txhr.onreadystatechange = bind(this, onReadyStateChange, xhr, opts.type, cb);\n\txhr.send(data || null);\n}\n\nfunction onReadyStateChange(xhr, type, cb) {\n\tif (xhr.readyState != 4) { return; }\n\tif (xhr.status != 200) {\n\t\tcb(xhr.response, null);\n\t} else {\n\t\tvar data = xhr.responseText;\n\t\tif (type == 'json') {\n\t\t\tdata = JSON.parse(data);\n\t\t}\n\t\tcb(null, data);\n\t}\n}\n");
jsio.setCachedSrc("../../packages/util/Animation.js","var SyncTimer = Class(function() {\n\tthis.init = function() {\n\t\tthis._items = [];\n\t\tthis._tick = bind(this, 'tick');\n\t\tthis._length = 0;\n\t}\n\t\n\tthis.tick = function() {\n\t\tvar now = +new Date();\n\t\tvar dt = now - this._last;\n\t\tthis._last = now;\n\t\t\n\t\t// items might get removed as we iterate, so this._length can change\n\t\tfor (var i = 0; i < this._length; ++i) {\n\t\t\tthis._items[i](dt);\n\t\t}\n\t}\n\t\n\tthis.add = function(cb) { \n\t\tif (cb) {\n\t\t\tthis._items.push(cb);\n\t\t\t++this._length;\n\t\t\tcb(0);\n\t\t\tthis.start();\n\t\t}\n\t}\n\t\n\tthis.remove = function(cb) {\n\t\tfor (var i = 0, n = this._items.length; i < n; ++i) {\n\t\t\tif (this._items[i] == cb) {\n\t\t\t\tthis._items.splice(i, 1);\n\t\t\t\tif (!--this._length) { this.stop(); }\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tthis.start = function() {\n\t\tif (!this._isRunning) {\n\t\t\tthis._isRunning = true;\n\t\t\tthis._last = +new Date();\n\t\t\tthis._timer = setInterval(this._tick, 15);\n\t\t}\n\t}\n\t\n\tthis.stop = function() {\n\t\tif (this._isRunning) {\n\t\t\tthis._isRunning = false;\n\t\t\tclearInterval(this._timer);\n\t\t}\n\t}\n});\n\nvar timer = new SyncTimer();\n\nexports = Class(function() {\n\tthis.init = function(params) {\n\t\tthis._start = 'start' in params ? params.start : 0;\n\t\tthis._end = 'end' in params ? params.end : 1;\n\t\tthis._transition = params.transition || null;\n\t\tthis._easing = params.easing || false;\n\t\tthis._subject = params.subject;\n\t\tthis._duration = params.duration || 1000;\n\t\tthis._s = params.current || this._start;\n\t\tthis._onFinish = params.onFinish || null;\n\n\t\tthis._range = this._end - this._start;\n\t\tthis._isAnimating = false;\n\t\tthis._animate = bind(this, 'animate');\n\t\tthis._timer = null;\n\t}\n\t\n\tthis.stop = function() { this.jumpTo(this._s); }\n\tthis.play = function() { this.seekTo(this._end); }\n\t\n\tthis.seekTo = function(s, dur) {\n\t\tif (s == this._s) { return; }\n\t\t\n\t\tthis._t0 = 0;\n\t\tthis._s0 = this._s;\n\t\tthis._s1 = s;\n\t\tif(dur) this._duration = dur;\n\t\t\n\t\tthis._ds = s - this._s;\n\t\tvar dt = this._ds / this._range * this._duration;\n\t\tthis._dt = dt < 0 ? -dt : dt;\n\t\t\n\t\tif(!this._isAnimating) {\n\t\t\tthis._isAnimating = true;\n\t\t\ttimer.add(this._animate);\n\t\t}\n\t\t\n\t\treturn this;\n\t}\n\t\n\tthis.onFinish = function(onFinish) { this._onFinish = onFinish; return this; }\n\t\n\tthis.jumpTo = function(s) {\n\t\tthis._s1 = this._s0 = s;\n\t\tthis._t0 = 0;\n\t\tthis._dt = 1;\n\t\tthis._ds = 0;\n\t\tthis.animate(0);\n\t\treturn this; \n\t}\n\t\n\tthis.animate = function(dt) {\n\t\tvar elapsed = (this._t0 += dt);\n\t\tvar dt = elapsed / this._dt;\n\t\tif(dt > 1) { dt = 1; }\n\t\tthis._s = this._s0 + dt * this._ds;\n\t\t\n\t\tvar x = this._transition ? this._transition(this._s) : this._s;\n\t\ttry {\n\t\t\tthis._subject(this._start + this._range * x, this._s);\n\t\t} finally {\n\t\t\tif(dt == 1) {\n\t\t\t\ttimer.remove(this._animate);\n\t\t\t\tthis._isAnimating = false;\n\t\t\t\tif(this._onFinish) {\n\t\t\t\t\tthis._onFinish();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n});\n\nexports.linear = function (n) { return n; }\nexports.easeIn = function (n) { return n * n; }\nexports.easeInOut = function (n) { return (n *= 2) < 1 ? 0.5 * n * n * n : 0.5 * ((n -= 2) * n * n + 2); }\nexports.easeOut = function(n) { return n * (2 - n); }");
jsio.setCachedSrc("../../packages/util/jslint.js","//\n// This file is a copy of jslint.js with *two* modifications:\n//   1. warning is printed when this module is imported\n//   2. global function JSLINT replaced with assignment to exports instead\n//\nlogger.warn('String.prototype has been modified.  Current browser session should only be used for debugging.');\n\n// jslint.js\n// 2010-11-18\n\n/*\nCopyright (c) 2002 Douglas Crockford  (www.JSLint.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nThe Software shall be used for Good, not Evil.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\n/*\n    JSLINT is a global function. It takes two parameters.\n\n        var myResult = JSLINT(source, option);\n\n    The first parameter is either a string or an array of strings. If it is a\n    string, it will be split on '\\n' or '\\r'. If it is an array of strings, it\n    is assumed that each string represents one line. The source can be a\n    JavaScript text, or HTML text, or a JSON text, or a CSS text.\n\n    The second parameter is an optional object of options which control the\n    operation of JSLINT. Most of the options are booleans: They are all are\n    optional and have a default value of false.\n\n    If it checks out, JSLINT returns true. Otherwise, it returns false.\n\n    If false, you can inspect JSLINT.errors to find out the problems.\n    JSLINT.errors is an array of objects containing these members:\n\n    {\n        line      : The line (relative to 0) at which the lint was found\n        character : The character (relative to 0) at which the lint was found\n        reason    : The problem\n        evidence  : The text line in which the problem occurred\n        raw       : The raw message before the details were inserted\n        a         : The first detail\n        b         : The second detail\n        c         : The third detail\n        d         : The fourth detail\n    }\n\n    If a fatal error was found, a null will be the last element of the\n    JSLINT.errors array.\n\n    You can request a Function Report, which shows all of the functions\n    and the parameters and vars that they use. This can be used to find\n    implied global variables and other problems. The report is in HTML and\n    can be inserted in an HTML <body>.\n\n        var myReport = JSLINT.report(limited);\n\n    If limited is true, then the report will be limited to only errors.\n\n    You can request a data structure which contains JSLint's results.\n\n        var myData = JSLINT.data();\n\n    It returns a structure with this form:\n\n    {\n        errors: [\n            {\n                line: NUMBER,\n                character: NUMBER,\n                reason: STRING,\n                evidence: STRING\n            }\n        ],\n        functions: [\n            name: STRING,\n            line: NUMBER,\n            last: NUMBER,\n            param: [\n                STRING\n            ],\n            closure: [\n                STRING\n            ],\n            var: [\n                STRING\n            ],\n            exception: [\n                STRING\n            ],\n            outer: [\n                STRING\n            ],\n            unused: [\n                STRING\n            ],\n            global: [\n                STRING\n            ],\n            label: [\n                STRING\n            ]\n        ],\n        globals: [\n            STRING\n        ],\n        member: {\n            STRING: NUMBER\n        },\n        unuseds: [\n            {\n                name: STRING,\n                line: NUMBER\n            }\n        ],\n        implieds: [\n            {\n                name: STRING,\n                line: NUMBER\n            }\n        ],\n        urls: [\n            STRING\n        ],\n        json: BOOLEAN\n    }\n\n    Empty arrays will not be included.\n\n*/\n\n/*jslint\n    evil: true, nomen: false, onevar: false, regexp: false, strict: true\n*/\n\n/*members \"\\b\", \"\\t\", \"\\n\", \"\\f\", \"\\r\", \"!=\", \"!==\", \"\\\"\", \"%\",\n    \"(begin)\", \"(breakage)\", \"(context)\", \"(error)\", \"(global)\",\n    \"(identifier)\", \"(last)\", \"(line)\", \"(loopage)\", \"(name)\", \"(onevar)\",\n    \"(params)\", \"(scope)\", \"(statement)\", \"(verb)\", \"*\", \"+\", \"++\", \"-\",\n    \"--\", \"\\/\", \"<\", \"<=\", \"==\", \"===\", \">\", \">=\", ADSAFE,\n    ActiveXObject, Array, Boolean, COM, CScript, Canvas, CustomAnimation,\n    Date, Debug, E, Enumerator, Error, EvalError, FadeAnimation, Flash,\n    FormField, Frame, Function, HotKey, Image, JSON, LN10, LN2, LOG10E,\n    LOG2E, MAX_VALUE, MIN_VALUE, Math, MenuItem, MoveAnimation,\n    NEGATIVE_INFINITY, Number, Object, Option, PI, POSITIVE_INFINITY, Point,\n    RangeError, Rectangle, ReferenceError, RegExp, ResizeAnimation,\n    RotateAnimation, SQRT1_2, SQRT2, ScrollBar, String, Style, SyntaxError,\n    System, Text, TextArea, Timer, TypeError, URIError, URL, VBArray,\n    WScript, Web, Window, XMLDOM, XMLHttpRequest, \"\\\\\", a, abbr, acronym,\n    activeborder, activecaption, addEventListener, address, adsafe, alert,\n    aliceblue, all, animator, antiquewhite, appleScript, applet, apply,\n    approved, appworkspace, aqua, aquamarine, area, arguments, arity,\n    article, aside, audio, autocomplete, azure, b, background,\n    \"background-attachment\", \"background-color\", \"background-image\",\n    \"background-position\", \"background-repeat\", base, bdo, beep, beige, big,\n    bisque, bitwise, black, blanchedalmond, block, blockquote, blue,\n    blueviolet, blur, body, border, \"border-bottom\", \"border-bottom-color\",\n    \"border-bottom-style\", \"border-bottom-width\", \"border-collapse\",\n    \"border-color\", \"border-left\", \"border-left-color\", \"border-left-style\",\n    \"border-left-width\", \"border-right\", \"border-right-color\",\n    \"border-right-style\", \"border-right-width\", \"border-spacing\",\n    \"border-style\", \"border-top\", \"border-top-color\", \"border-top-style\",\n    \"border-top-width\", \"border-width\", bottom, br, braille, brown, browser,\n    burlywood, button, buttonface, buttonhighlight, buttonshadow,\n    buttontext, bytesToUIString, c, cadetblue, call, callee, caller, canvas,\n    cap, caption, \"caption-side\", captiontext, cases, center, charAt,\n    charCodeAt, character, chartreuse, chocolate, chooseColor, chooseFile,\n    chooseFolder, cite, clear, clearInterval, clearTimeout, clip, close,\n    closeWidget, closed, closure, cm, code, col, colgroup, color, command,\n    comment, condition, confirm, console, constructor, content,\n    convertPathToHFS, convertPathToPlatform, coral, cornflowerblue,\n    cornsilk, \"counter-increment\", \"counter-reset\", create, crimson, css,\n    cursor, cyan, d, darkblue, darkcyan, darkgoldenrod, darkgray, darkgreen,\n    darkkhaki, darkmagenta, darkolivegreen, darkorange, darkorchid, darkred,\n    darksalmon, darkseagreen, darkslateblue, darkslategray, darkturquoise,\n    darkviolet, data, datalist, dd, debug, decodeURI, decodeURIComponent,\n    deeppink, deepskyblue, defaultStatus, defineClass, del, deserialize,\n    details, devel, dfn, dialog, dimension, dimgray, dir, direction,\n    display, div, dl, document, dodgerblue, dt, edition, else, em, embed,\n    embossed, empty, \"empty-cells\", encodeURI, encodeURIComponent,\n    entityify, eqeqeq, errors, es5, escape, eval, event, evidence, evil, ex,\n    exception, exec, exps, fieldset, figure, filesystem, firebrick, first,\n    float, floor, floralwhite, focus, focusWidget, font, \"font-family\",\n    \"font-size\", \"font-size-adjust\", \"font-stretch\", \"font-style\",\n    \"font-variant\", \"font-weight\", footer, forestgreen, forin, form,\n    fragment, frame, frames, frameset, from, fromCharCode, fuchsia, fud,\n    funct, function, functions, g, gainsboro, gc, getComputedStyle,\n    ghostwhite, global, globals, gold, goldenrod, gray, graytext, green,\n    greenyellow, h1, h2, h3, h4, h5, h6, handheld, hasOwnProperty, head,\n    header, height, help, hgroup, highlight, highlighttext, history,\n    honeydew, hotpink, hr, \"hta:application\", html, i, iTunes, id,\n    identifier, iframe, img, immed, implieds, in, inactiveborder,\n    inactivecaption, inactivecaptiontext, include, indent, indexOf,\n    indianred, indigo, infobackground, infotext, init, input, ins, isAlpha,\n    isApplicationRunning, isDigit, isFinite, isNaN, ivory, join, jslint,\n    json, kbd, keygen, khaki, konfabulatorVersion, label, labelled, lang,\n    last, lavender, lavenderblush, lawngreen, laxbreak, lbp, led, left,\n    legend, lemonchiffon, length, \"letter-spacing\", li, lib, lightblue,\n    lightcoral, lightcyan, lightgoldenrodyellow, lightgreen, lightpink,\n    lightsalmon, lightseagreen, lightskyblue, lightslategray,\n    lightsteelblue, lightyellow, lime, limegreen, line, \"line-height\",\n    linen, link, \"list-style\", \"list-style-image\", \"list-style-position\",\n    \"list-style-type\", load, loadClass, location, log, m, magenta, map,\n    margin, \"margin-bottom\", \"margin-left\", \"margin-right\", \"margin-top\",\n    mark, \"marker-offset\", maroon, match, \"max-height\", \"max-width\", maxerr,\n    maxlen, md5, mediumaquamarine, mediumblue, mediumorchid, mediumpurple,\n    mediumseagreen, mediumslateblue, mediumspringgreen, mediumturquoise,\n    mediumvioletred, member, menu, menutext, message, meta, meter,\n    midnightblue, \"min-height\", \"min-width\", mintcream, mistyrose, mm,\n    moccasin, moveBy, moveTo, name, nav, navajowhite, navigator, navy, new,\n    newcap, noframes, nomen, noscript, nud, object, ol, oldlace, olive,\n    olivedrab, on, onbeforeunload, onblur, onerror, onevar, onfocus, onload,\n    onresize, onunload, opacity, open, openURL, opener, opera, optgroup,\n    option, orange, orangered, orchid, outer, outline, \"outline-color\",\n    \"outline-style\", \"outline-width\", output, overflow, \"overflow-x\",\n    \"overflow-y\", p, padding, \"padding-bottom\", \"padding-left\",\n    \"padding-right\", \"padding-top\", \"page-break-after\", \"page-break-before\",\n    palegoldenrod, palegreen, paleturquoise, palevioletred, papayawhip,\n    param, parent, parseFloat, parseInt, passfail, pc, peachpuff, peru,\n    pink, play, plum, plusplus, pop, popupMenu, position, powderblue, pre,\n    predef, preferenceGroups, preferences, print, progress, projection,\n    prompt, prototype, pt, purple, push, px, q, quit, quotes, random, range,\n    raw, reach, readFile, readUrl, reason, red, regexp, reloadWidget,\n    removeEventListener, replace, report, reserved, resizeBy, resizeTo,\n    resolvePath, resumeUpdates, rhino, right, rosybrown, royalblue, rp, rt,\n    ruby, runCommand, runCommandInBg, saddlebrown, safe, salmon, samp,\n    sandybrown, saveAs, savePreferences, screen, script, scroll, scrollBy,\n    scrollTo, scrollbar, seagreen, seal, search, seashell, section, select,\n    serialize, setInterval, setTimeout, shift, showWidgetPreferences,\n    sienna, silver, skyblue, slateblue, slategray, sleep, slice, small,\n    snow, sort, source, span, spawn, speak, speech, split, springgreen, src,\n    stack, status, steelblue, strict, strong, style, styleproperty, sub,\n    substr, sup, supplant, suppressUpdates, sync, system, table,\n    \"table-layout\", tan, tbody, td, teal, tellWidget, test, \"text-align\",\n    \"text-decoration\", \"text-indent\", \"text-shadow\", \"text-transform\",\n    textarea, tfoot, th, thead, thistle, threeddarkshadow, threedface,\n    threedhighlight, threedlightshadow, threedshadow, time, title,\n    toLowerCase, toString, toUpperCase, toint32, token, tomato, top, tr, tt,\n    tty, turquoise, tv, type, u, ul, undef, unescape, \"unicode-bidi\",\n    unused, unwatch, updateNow, urls, value, valueOf, var, version,\n    \"vertical-align\", video, violet, visibility, watch, wheat, white,\n    \"white-space\", whitesmoke, widget, width, window, windowframe, windows,\n    windowtext, \"word-spacing\", \"word-wrap\", yahooCheckLogin, yahooLogin,\n    yahooLogout, yellow, yellowgreen, \"z-index\"\n*/\n\n// We build the application inside a function so that we produce only a single\n// global variable. The function will be invoked, its return value is the JSLINT\n// application itself.\n\n\"use strict\";\n\nvar JSLINT = exports = (function () {\n    var adsafe_id,      // The widget's ADsafe id.\n        adsafe_may,     // The widget may load approved scripts.\n        adsafe_went,    // ADSAFE.go has been called.\n        anonname,       // The guessed name for anonymous functions.\n        approved,       // ADsafe approved urls.\n\n// These are operators that should not be used with the ! operator.\n\n        bang = {\n            '<': true,\n            '<=': true,\n            '==': true,\n            '===': true,\n            '!==': true,\n            '!=': true,\n            '>': true,\n            '>=': true,\n            '+': true,\n            '-': true,\n            '*': true,\n            '/': true,\n            '%': true\n        },\n\n// These are members that should not be permitted in the safe subset.\n\n        banned = {              // the member names that ADsafe prohibits.\n            'arguments'     : true,\n            callee          : true,\n            caller          : true,\n            constructor     : true,\n            'eval'          : true,\n            prototype       : true,\n            stack           : true,\n            unwatch         : true,\n            valueOf         : true,\n            watch           : true\n        },\n\n\n// These are the JSLint boolean options.\n\n        boolOptions = {\n            adsafe     : true, // if ADsafe should be enforced\n            bitwise    : true, // if bitwise operators should not be allowed\n            browser    : true, // if the standard browser globals should be predefined\n            cap        : true, // if upper case HTML should be allowed\n            css        : true, // if CSS workarounds should be tolerated\n            debug      : true, // if debugger statements should be allowed\n            devel      : true, // if logging should be allowed (console, alert, etc.)\n            eqeqeq     : true, // if === should be required\n            es5        : true, // if ES5 syntax should be allowed\n            evil       : true, // if eval should be allowed\n            forin      : true, // if for in statements must filter\n            fragment   : true, // if HTML fragments should be allowed\n            immed      : true, // if immediate invocations must be wrapped in parens\n            laxbreak   : true, // if line breaks should not be checked\n            newcap     : true, // if constructor names must be capitalized\n            nomen      : true, // if names should be checked\n            on         : true, // if HTML event handlers should be allowed\n            onevar     : true, // if only one var statement per function should be allowed\n            passfail   : true, // if the scan should stop on first error\n            plusplus   : true, // if increment/decrement should not be allowed\n            regexp     : true, // if the . should not be allowed in regexp literals\n            rhino      : true, // if the Rhino environment globals should be predefined\n            undef      : true, // if variables should be declared before used\n            safe       : true, // if use of some browser features should be restricted\n            windows    : true, // if MS Windows-specigic globals should be predefined\n            strict     : true, // require the \"use strict\"; pragma\n            sub        : true, // if all forms of subscript notation are tolerated\n            white      : true, // if strict whitespace rules apply\n            widget     : true  // if the Yahoo Widgets globals should be predefined\n        },\n\n// browser contains a set of global names which are commonly provided by a\n// web browser environment.\n\n        browser = {\n            addEventListener: false,\n            blur            : false,\n            clearInterval   : false,\n            clearTimeout    : false,\n            close           : false,\n            closed          : false,\n            defaultStatus   : false,\n            document        : false,\n            event           : false,\n            focus           : false,\n            frames          : false,\n            getComputedStyle: false,\n            history         : false,\n            Image           : false,\n            length          : false,\n            location        : false,\n            moveBy          : false,\n            moveTo          : false,\n            name            : false,\n            navigator       : false,\n            onbeforeunload  : true,\n            onblur          : true,\n            onerror         : true,\n            onfocus         : true,\n            onload          : true,\n            onresize        : true,\n            onunload        : true,\n            open            : false,\n            opener          : false,\n            Option          : false,\n            parent          : false,\n            print           : false,\n            removeEventListener: false,\n            resizeBy        : false,\n            resizeTo        : false,\n            screen          : false,\n            scroll          : false,\n            scrollBy        : false,\n            scrollTo        : false,\n            setInterval     : false,\n            setTimeout      : false,\n            status          : false,\n            top             : false,\n            XMLHttpRequest  : false\n        },\n\n        cssAttributeData,\n        cssAny,\n\n        cssColorData = {\n            \"aliceblue\"             : true,\n            \"antiquewhite\"          : true,\n            \"aqua\"                  : true,\n            \"aquamarine\"            : true,\n            \"azure\"                 : true,\n            \"beige\"                 : true,\n            \"bisque\"                : true,\n            \"black\"                 : true,\n            \"blanchedalmond\"        : true,\n            \"blue\"                  : true,\n            \"blueviolet\"            : true,\n            \"brown\"                 : true,\n            \"burlywood\"             : true,\n            \"cadetblue\"             : true,\n            \"chartreuse\"            : true,\n            \"chocolate\"             : true,\n            \"coral\"                 : true,\n            \"cornflowerblue\"        : true,\n            \"cornsilk\"              : true,\n            \"crimson\"               : true,\n            \"cyan\"                  : true,\n            \"darkblue\"              : true,\n            \"darkcyan\"              : true,\n            \"darkgoldenrod\"         : true,\n            \"darkgray\"              : true,\n            \"darkgreen\"             : true,\n            \"darkkhaki\"             : true,\n            \"darkmagenta\"           : true,\n            \"darkolivegreen\"        : true,\n            \"darkorange\"            : true,\n            \"darkorchid\"            : true,\n            \"darkred\"               : true,\n            \"darksalmon\"            : true,\n            \"darkseagreen\"          : true,\n            \"darkslateblue\"         : true,\n            \"darkslategray\"         : true,\n            \"darkturquoise\"         : true,\n            \"darkviolet\"            : true,\n            \"deeppink\"              : true,\n            \"deepskyblue\"           : true,\n            \"dimgray\"               : true,\n            \"dodgerblue\"            : true,\n            \"firebrick\"             : true,\n            \"floralwhite\"           : true,\n            \"forestgreen\"           : true,\n            \"fuchsia\"               : true,\n            \"gainsboro\"             : true,\n            \"ghostwhite\"            : true,\n            \"gold\"                  : true,\n            \"goldenrod\"             : true,\n            \"gray\"                  : true,\n            \"green\"                 : true,\n            \"greenyellow\"           : true,\n            \"honeydew\"              : true,\n            \"hotpink\"               : true,\n            \"indianred\"             : true,\n            \"indigo\"                : true,\n            \"ivory\"                 : true,\n            \"khaki\"                 : true,\n            \"lavender\"              : true,\n            \"lavenderblush\"         : true,\n            \"lawngreen\"             : true,\n            \"lemonchiffon\"          : true,\n            \"lightblue\"             : true,\n            \"lightcoral\"            : true,\n            \"lightcyan\"             : true,\n            \"lightgoldenrodyellow\"  : true,\n            \"lightgreen\"            : true,\n            \"lightpink\"             : true,\n            \"lightsalmon\"           : true,\n            \"lightseagreen\"         : true,\n            \"lightskyblue\"          : true,\n            \"lightslategray\"        : true,\n            \"lightsteelblue\"        : true,\n            \"lightyellow\"           : true,\n            \"lime\"                  : true,\n            \"limegreen\"             : true,\n            \"linen\"                 : true,\n            \"magenta\"               : true,\n            \"maroon\"                : true,\n            \"mediumaquamarine\"      : true,\n            \"mediumblue\"            : true,\n            \"mediumorchid\"          : true,\n            \"mediumpurple\"          : true,\n            \"mediumseagreen\"        : true,\n            \"mediumslateblue\"       : true,\n            \"mediumspringgreen\"     : true,\n            \"mediumturquoise\"       : true,\n            \"mediumvioletred\"       : true,\n            \"midnightblue\"          : true,\n            \"mintcream\"             : true,\n            \"mistyrose\"             : true,\n            \"moccasin\"              : true,\n            \"navajowhite\"           : true,\n            \"navy\"                  : true,\n            \"oldlace\"               : true,\n            \"olive\"                 : true,\n            \"olivedrab\"             : true,\n            \"orange\"                : true,\n            \"orangered\"             : true,\n            \"orchid\"                : true,\n            \"palegoldenrod\"         : true,\n            \"palegreen\"             : true,\n            \"paleturquoise\"         : true,\n            \"palevioletred\"         : true,\n            \"papayawhip\"            : true,\n            \"peachpuff\"             : true,\n            \"peru\"                  : true,\n            \"pink\"                  : true,\n            \"plum\"                  : true,\n            \"powderblue\"            : true,\n            \"purple\"                : true,\n            \"red\"                   : true,\n            \"rosybrown\"             : true,\n            \"royalblue\"             : true,\n            \"saddlebrown\"           : true,\n            \"salmon\"                : true,\n            \"sandybrown\"            : true,\n            \"seagreen\"              : true,\n            \"seashell\"              : true,\n            \"sienna\"                : true,\n            \"silver\"                : true,\n            \"skyblue\"               : true,\n            \"slateblue\"             : true,\n            \"slategray\"             : true,\n            \"snow\"                  : true,\n            \"springgreen\"           : true,\n            \"steelblue\"             : true,\n            \"tan\"                   : true,\n            \"teal\"                  : true,\n            \"thistle\"               : true,\n            \"tomato\"                : true,\n            \"turquoise\"             : true,\n            \"violet\"                : true,\n            \"wheat\"                 : true,\n            \"white\"                 : true,\n            \"whitesmoke\"            : true,\n            \"yellow\"                : true,\n            \"yellowgreen\"           : true,\n\n            \"activeborder\"          : true,\n            \"activecaption\"         : true,\n            \"appworkspace\"          : true,\n            \"background\"            : true,\n            \"buttonface\"            : true,\n            \"buttonhighlight\"       : true,\n            \"buttonshadow\"          : true,\n            \"buttontext\"            : true,\n            \"captiontext\"           : true,\n            \"graytext\"              : true,\n            \"highlight\"             : true,\n            \"highlighttext\"         : true,\n            \"inactiveborder\"        : true,\n            \"inactivecaption\"       : true,\n            \"inactivecaptiontext\"   : true,\n            \"infobackground\"        : true,\n            \"infotext\"              : true,\n            \"menu\"                  : true,\n            \"menutext\"              : true,\n            \"scrollbar\"             : true,\n            \"threeddarkshadow\"      : true,\n            \"threedface\"            : true,\n            \"threedhighlight\"       : true,\n            \"threedlightshadow\"     : true,\n            \"threedshadow\"          : true,\n            \"window\"                : true,\n            \"windowframe\"           : true,\n            \"windowtext\"            : true\n        },\n\n        cssBorderStyle,\n        cssBreak,\n\n        cssLengthData = {\n            '%': true,\n            'cm': true,\n            'em': true,\n            'ex': true,\n            'in': true,\n            'mm': true,\n            'pc': true,\n            'pt': true,\n            'px': true\n        },\n\n        cssMedia,\n        cssOverflow,\n\n        devel = {\n            alert           : false,\n            confirm         : false,\n            console         : false,\n            Debug           : false,\n            opera           : false,\n            prompt          : false\n        },\n\n        escapes = {\n            '\\b': '\\\\b',\n            '\\t': '\\\\t',\n            '\\n': '\\\\n',\n            '\\f': '\\\\f',\n            '\\r': '\\\\r',\n            '\"' : '\\\\\"',\n            '/' : '\\\\/',\n            '\\\\': '\\\\\\\\'\n        },\n\n        funct,          // The current function\n\n        functionicity = [\n            'closure', 'exception', 'global', 'label',\n            'outer', 'unused', 'var'\n        ],\n\n        functions,      // All of the functions\n\n        global,         // The global scope\n        htmltag = {\n            a:        {},\n            abbr:     {},\n            acronym:  {},\n            address:  {},\n            applet:   {},\n            area:     {empty: true, parent: ' map '},\n            article:  {},\n            aside:    {},\n            audio:    {},\n            b:        {},\n            base:     {empty: true, parent: ' head '},\n            bdo:      {},\n            big:      {},\n            blockquote: {},\n            body:     {parent: ' html noframes '},\n            br:       {empty: true},\n            button:   {},\n            canvas:   {parent: ' body p div th td '},\n            caption:  {parent: ' table '},\n            center:   {},\n            cite:     {},\n            code:     {},\n            col:      {empty: true, parent: ' table colgroup '},\n            colgroup: {parent: ' table '},\n            command:  {parent: ' menu '},\n            datalist: {},\n            dd:       {parent: ' dl '},\n            del:      {},\n            details:  {},\n            dialog:   {},\n            dfn:      {},\n            dir:      {},\n            div:      {},\n            dl:       {},\n            dt:       {parent: ' dl '},\n            em:       {},\n            embed:    {},\n            fieldset: {},\n            figure:   {},\n            font:     {},\n            footer:   {},\n            form:     {},\n            frame:    {empty: true, parent: ' frameset '},\n            frameset: {parent: ' html frameset '},\n            h1:       {},\n            h2:       {},\n            h3:       {},\n            h4:       {},\n            h5:       {},\n            h6:       {},\n            head:     {parent: ' html '},\n            header:   {},\n            hgroup:   {},\n            hr:       {empty: true},\n            'hta:application':\n                      {empty: true, parent: ' head '},\n            html:     {parent: '*'},\n            i:        {},\n            iframe:   {},\n            img:      {empty: true},\n            input:    {empty: true},\n            ins:      {},\n            kbd:      {},\n            keygen:   {},\n            label:    {},\n            legend:   {parent: ' details fieldset figure '},\n            li:       {parent: ' dir menu ol ul '},\n            link:     {empty: true, parent: ' head '},\n            map:      {},\n            mark:     {},\n            menu:     {},\n            meta:     {empty: true, parent: ' head noframes noscript '},\n            meter:    {},\n            nav:      {},\n            noframes: {parent: ' html body '},\n            noscript: {parent: ' body head noframes '},\n            object:   {},\n            ol:       {},\n            optgroup: {parent: ' select '},\n            option:   {parent: ' optgroup select '},\n            output:   {},\n            p:        {},\n            param:    {empty: true, parent: ' applet object '},\n            pre:      {},\n            progress: {},\n            q:        {},\n            rp:       {},\n            rt:       {},\n            ruby:     {},\n            samp:     {},\n            script:   {empty: true, parent: ' body div frame head iframe p pre span '},\n            section:  {},\n            select:   {},\n            small:    {},\n            span:     {},\n            source:   {},\n            strong:   {},\n            style:    {parent: ' head ', empty: true},\n            sub:      {},\n            sup:      {},\n            table:    {},\n            tbody:    {parent: ' table '},\n            td:       {parent: ' tr '},\n            textarea: {},\n            tfoot:    {parent: ' table '},\n            th:       {parent: ' tr '},\n            thead:    {parent: ' table '},\n            time:     {},\n            title:    {parent: ' head '},\n            tr:       {parent: ' table tbody thead tfoot '},\n            tt:       {},\n            u:        {},\n            ul:       {},\n            'var':    {},\n            video:    {}\n        },\n\n        ids,            // HTML ids\n        implied,        // Implied globals\n        inblock,\n        indent,\n        jsonmode,\n        lines,\n        lookahead,\n        member,\n        membersOnly,\n        nexttoken,\n        noreach,\n        option,\n        predefined,     // Global variables defined by option\n        prereg,\n        prevtoken,\n\n        rhino = {\n            defineClass : false,\n            deserialize : false,\n            gc          : false,\n            help        : false,\n            load        : false,\n            loadClass   : false,\n            print       : false,\n            quit        : false,\n            readFile    : false,\n            readUrl     : false,\n            runCommand  : false,\n            seal        : false,\n            serialize   : false,\n            spawn       : false,\n            sync        : false,\n            toint32     : false,\n            version     : false\n        },\n\n        scope,      // The current scope\n        src,\n        stack,\n\n// standard contains the global names that are provided by the\n// ECMAScript standard.\n\n        standard = {\n            Array               : false,\n            Boolean             : false,\n            Date                : false,\n            decodeURI           : false,\n            decodeURIComponent  : false,\n            encodeURI           : false,\n            encodeURIComponent  : false,\n            Error               : false,\n            'eval'              : false,\n            EvalError           : false,\n            Function            : false,\n            hasOwnProperty      : false,\n            isFinite            : false,\n            isNaN               : false,\n            JSON                : false,\n            Math                : false,\n            Number              : false,\n            Object              : false,\n            parseInt            : false,\n            parseFloat          : false,\n            RangeError          : false,\n            ReferenceError      : false,\n            RegExp              : false,\n            String              : false,\n            SyntaxError         : false,\n            TypeError           : false,\n            URIError            : false\n        },\n\n        standard_member = {\n            E                   : true,\n            LN2                 : true,\n            LN10                : true,\n            LOG2E               : true,\n            LOG10E              : true,\n            MAX_VALUE           : true,\n            MIN_VALUE           : true,\n            NEGATIVE_INFINITY   : true,\n            PI                  : true,\n            POSITIVE_INFINITY   : true,\n            SQRT1_2             : true,\n            SQRT2               : true\n        },\n\n        strict_mode,\n        syntax = {},\n        tab,\n        token,\n        urls,\n        warnings,\n\n// widget contains the global names which are provided to a Yahoo\n// (fna Konfabulator) widget.\n\n        widget = {\n            alert                   : true,\n            animator                : true,\n            appleScript             : true,\n            beep                    : true,\n            bytesToUIString         : true,\n            Canvas                  : true,\n            chooseColor             : true,\n            chooseFile              : true,\n            chooseFolder            : true,\n            closeWidget             : true,\n            COM                     : true,\n            convertPathToHFS        : true,\n            convertPathToPlatform   : true,\n            CustomAnimation         : true,\n            escape                  : true,\n            FadeAnimation           : true,\n            filesystem              : true,\n            Flash                   : true,\n            focusWidget             : true,\n            form                    : true,\n            FormField               : true,\n            Frame                   : true,\n            HotKey                  : true,\n            Image                   : true,\n            include                 : true,\n            isApplicationRunning    : true,\n            iTunes                  : true,\n            konfabulatorVersion     : true,\n            log                     : true,\n            md5                     : true,\n            MenuItem                : true,\n            MoveAnimation           : true,\n            openURL                 : true,\n            play                    : true,\n            Point                   : true,\n            popupMenu               : true,\n            preferenceGroups        : true,\n            preferences             : true,\n            print                   : true,\n            prompt                  : true,\n            random                  : true,\n            Rectangle               : true,\n            reloadWidget            : true,\n            ResizeAnimation         : true,\n            resolvePath             : true,\n            resumeUpdates           : true,\n            RotateAnimation         : true,\n            runCommand              : true,\n            runCommandInBg          : true,\n            saveAs                  : true,\n            savePreferences         : true,\n            screen                  : true,\n            ScrollBar               : true,\n            showWidgetPreferences   : true,\n            sleep                   : true,\n            speak                   : true,\n            Style                   : true,\n            suppressUpdates         : true,\n            system                  : true,\n            tellWidget              : true,\n            Text                    : true,\n            TextArea                : true,\n            Timer                   : true,\n            unescape                : true,\n            updateNow               : true,\n            URL                     : true,\n            Web                     : true,\n            widget                  : true,\n            Window                  : true,\n            XMLDOM                  : true,\n            XMLHttpRequest          : true,\n            yahooCheckLogin         : true,\n            yahooLogin              : true,\n            yahooLogout             : true\n        },\n\n        windows = {\n            ActiveXObject: false,\n            CScript      : false,\n            Debug        : false,\n            Enumerator   : false,\n            System       : false,\n            VBArray      : false,\n            WScript      : false\n        },\n\n//  xmode is used to adapt to the exceptions in html parsing.\n//  It can have these states:\n//      false   .js script file\n//      html\n//      outer\n//      script\n//      style\n//      scriptstring\n//      styleproperty\n\n        xmode,\n        xquote,\n\n// Regular expressions. Some of these are ridiculously long.\n\n// unsafe comment or string\n        ax = /@cc|<\\/?|script|\\]\\s*\\]|<\\s*!|&lt/i,\n// unsafe characters that are silently deleted by one or more browsers\n        cx = /[\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/,\n// token\n        tx = /^\\s*([(){}\\[.,:;'\"~\\?\\]#@]|==?=?|\\/(\\*(jslint|members?|global)?|=|\\/)?|\\*[\\/=]?|\\+(?:=|\\++)?|-(?:=|-+)?|%=?|&[&=]?|\\|[|=]?|>>?>?=?|<([\\/=!]|\\!(\\[|--)?|<=?)?|\\^=?|\\!=?=?|[a-zA-Z_$][a-zA-Z0-9_$]*|[0-9]+([xX][0-9a-fA-F]+|\\.[0-9]*)?([eE][+\\-]?[0-9]+)?)/,\n// html token\n        hx = /^\\s*(['\"=>\\/&#]|<(?:\\/|\\!(?:--)?)?|[a-zA-Z][a-zA-Z0-9_\\-:]*|[0-9]+|--)/,\n// characters in strings that need escapement\n        nx = /[\\u0000-\\u001f&<\"\\/\\\\\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/,\n        nxg = /[\\u0000-\\u001f&<\"\\/\\\\\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n// outer html token\n        ox = /[>&]|<[\\/!]?|--/,\n// star slash\n        lx = /\\*\\/|\\/\\*/,\n// identifier\n        ix = /^([a-zA-Z_$][a-zA-Z0-9_$]*)$/,\n// javascript url\n        jx = /^(?:javascript|jscript|ecmascript|vbscript|mocha|livescript)\\s*:/i,\n// url badness\n        ux = /&|\\+|\\u00AD|\\.\\.|\\/\\*|%[^;]|base64|url|expression|data|mailto/i,\n// style\n        sx = /^\\s*([{:#%.=,>+\\[\\]@()\"';]|\\*=?|\\$=|\\|=|\\^=|~=|[a-zA-Z_][a-zA-Z0-9_\\-]*|[0-9]+|<\\/|\\/\\*)/,\n        ssx = /^\\s*([@#!\"'};:\\-%.=,+\\[\\]()*_]|[a-zA-Z][a-zA-Z0-9._\\-]*|\\/\\*?|\\d+(?:\\.\\d+)?|<\\/)/,\n// attributes characters\n        qx = /[^a-zA-Z0-9+\\-_\\/ ]/,\n// query characters for ids\n        dx = /[\\[\\]\\/\\\\\"'*<>.&:(){}+=#]/,\n\n        rx = {\n            outer: hx,\n            html: hx,\n            style: sx,\n            styleproperty: ssx\n        };\n\n    function F() {}\n\n    if (typeof Object.create !== 'function') {\n        Object.create = function (o) {\n            F.prototype = o;\n            return new F();\n        };\n    }\n\n\n    function is_own(object, name) {\n        return Object.prototype.hasOwnProperty.call(object, name);\n    }\n\n\n    function combine(t, o) {\n        var n;\n        for (n in o) {\n            if (is_own(o, n)) {\n                t[n] = o[n];\n            }\n        }\n    }\n\n    String.prototype.entityify = function () {\n        return this\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;');\n    };\n\n    String.prototype.isAlpha = function () {\n        return (this >= 'a' && this <= 'z\\uffff') ||\n            (this >= 'A' && this <= 'Z\\uffff');\n    };\n\n\n    String.prototype.isDigit = function () {\n        return (this >= '0' && this <= '9');\n    };\n\n\n    String.prototype.supplant = function (o) {\n        return this.replace(/\\{([^{}]*)\\}/g, function (a, b) {\n            var r = o[b];\n            return typeof r === 'string' || typeof r === 'number' ? r : a;\n        });\n    };\n\n    String.prototype.name = function () {\n\n// If the string looks like an identifier, then we can return it as is.\n// If the string contains no control characters, no quote characters, and no\n// backslash characters, then we can simply slap some quotes around it.\n// Otherwise we must also replace the offending characters with safe\n// sequences.\n\n        if (ix.test(this)) {\n            return this;\n        }\n        if (nx.test(this)) {\n            return '\"' + this.replace(nxg, function (a) {\n                var c = escapes[a];\n                if (c) {\n                    return c;\n                }\n                return '\\\\u' + ('0000' + a.charCodeAt().toString(16)).slice(-4);\n            }) + '\"';\n        }\n        return '\"' + this + '\"';\n    };\n\n\n    function assume() {\n        if (!option.safe) {\n            if (option.rhino) {\n                combine(predefined, rhino);\n            }\n            if (option.devel) {\n                combine(predefined, devel);\n            }\n            if (option.browser) {\n                combine(predefined, browser);\n            }\n            if (option.windows) {\n                combine(predefined, windows);\n            }\n            if (option.widget) {\n                combine(predefined, widget);\n            }\n        }\n    }\n\n\n// Produce an error warning.\n\n    function quit(m, l, ch) {\n        throw {\n            name: 'JSLintError',\n            line: l,\n            character: ch,\n            message: m + \" (\" + Math.floor((l / lines.length) * 100) +\n                    \"% scanned).\"\n        };\n    }\n\n    function warning(m, t, a, b, c, d) {\n        var ch, l, w;\n        t = t || nexttoken;\n        if (t.id === '(end)') {  // `~\n            t = token;\n        }\n        l = t.line || 0;\n        ch = t.from || 0;\n        w = {\n            id: '(error)',\n            raw: m,\n            evidence: lines[l - 1] || '',\n            line: l,\n            character: ch,\n            a: a,\n            b: b,\n            c: c,\n            d: d\n        };\n        w.reason = m.supplant(w);\n        JSLINT.errors.push(w);\n        if (option.passfail) {\n            quit('Stopping. ', l, ch);\n        }\n        warnings += 1;\n        if (warnings >= option.maxerr) {\n            quit(\"Too many errors.\", l, ch);\n        }\n        return w;\n    }\n\n    function warningAt(m, l, ch, a, b, c, d) {\n        return warning(m, {\n            line: l,\n            from: ch\n        }, a, b, c, d);\n    }\n\n    function error(m, t, a, b, c, d) {\n        var w = warning(m, t, a, b, c, d);\n        quit(\"Stopping, unable to continue.\", w.line, w.character);\n    }\n\n    function errorAt(m, l, ch, a, b, c, d) {\n        return error(m, {\n            line: l,\n            from: ch\n        }, a, b, c, d);\n    }\n\n\n\n// lexical analysis\n\n    var lex = (function lex() {\n        var character, from, line, s;\n\n// Private lex methods\n\n        function nextLine() {\n            var at;\n            if (line >= lines.length) {\n                return false;\n            }\n            character = 1;\n            s = lines[line];\n            line += 1;\n            at = s.search(/ \\t/);\n            if (at >= 0) {\n                warningAt(\"Mixed spaces and tabs.\", line, at + 1);\n            }\n            s = s.replace(/\\t/g, tab);\n            at = s.search(cx);\n            if (at >= 0) {\n                warningAt(\"Unsafe character.\", line, at);\n            }\n            if (option.maxlen && option.maxlen < s.length) {\n                warningAt(\"Line too long.\", line, s.length);\n            }\n            return true;\n        }\n\n// Produce a token object.  The token inherits from a syntax symbol.\n\n        function it(type, value) {\n            var i, t;\n            if (type === '(color)' || type === '(range)') {\n                t = {type: type};\n            } else if (type === '(punctuator)' ||\n                    (type === '(identifier)' && is_own(syntax, value))) {\n                t = syntax[value] || syntax['(error)'];\n            } else {\n                t = syntax[type];\n            }\n            t = Object.create(t);\n            if (type === '(string)' || type === '(range)') {\n                if (jx.test(value)) {\n                    warningAt(\"Script URL.\", line, from);\n                }\n            }\n            if (type === '(identifier)') {\n                t.identifier = true;\n                if (value === '__iterator__' || value === '__proto__') {\n                    errorAt(\"Reserved name '{a}'.\",\n                        line, from, value);\n                } else if (option.nomen &&\n                        (value.charAt(0) === '_' ||\n                         value.charAt(value.length - 1) === '_')) {\n                    warningAt(\"Unexpected {a} in '{b}'.\", line, from,\n                        \"dangling '_'\", value);\n                }\n            }\n            t.value = value;\n            t.line = line;\n            t.character = character;\n            t.from = from;\n            i = t.id;\n            if (i !== '(endline)') {\n                prereg = i &&\n                    (('(,=:[!&|?{};'.indexOf(i.charAt(i.length - 1)) >= 0) ||\n                    i === 'return');\n            }\n            return t;\n        }\n\n// Public lex methods\n\n        return {\n            init: function (source) {\n                if (typeof source === 'string') {\n                    lines = source\n                        .replace(/\\r\\n/g, '\\n')\n                        .replace(/\\r/g, '\\n')\n                        .split('\\n');\n                } else {\n                    lines = source;\n                }\n                line = 0;\n                nextLine();\n                from = 1;\n            },\n\n            range: function (begin, end) {\n                var c, value = '';\n                from = character;\n                if (s.charAt(0) !== begin) {\n                    errorAt(\"Expected '{a}' and instead saw '{b}'.\",\n                            line, character, begin, s.charAt(0));\n                }\n                for (;;) {\n                    s = s.slice(1);\n                    character += 1;\n                    c = s.charAt(0);\n                    switch (c) {\n                    case '':\n                        errorAt(\"Missing '{a}'.\", line, character, c);\n                        break;\n                    case end:\n                        s = s.slice(1);\n                        character += 1;\n                        return it('(range)', value);\n                    case xquote:\n                    case '\\\\':\n                        warningAt(\"Unexpected '{a}'.\", line, character, c);\n                    }\n                    value += c;\n                }\n\n            },\n\n// token -- this is called by advance to get the next token.\n\n            token: function () {\n                var b, c, captures, d, depth, high, i, l, low, q, t;\n\n                function match(x) {\n                    var r = x.exec(s), r1;\n                    if (r) {\n                        l = r[0].length;\n                        r1 = r[1];\n                        c = r1.charAt(0);\n                        s = s.substr(l);\n                        from = character + l - r1.length;\n                        character += l;\n                        return r1;\n                    }\n                }\n\n                function string(x) {\n                    var c, j, r = '';\n\n                    if (jsonmode && x !== '\"') {\n                        warningAt(\"Strings must use doublequote.\",\n                                line, character);\n                    }\n\n                    if (xquote === x || (xmode === 'scriptstring' && !xquote)) {\n                        return it('(punctuator)', x);\n                    }\n\n                    function esc(n) {\n                        var i = parseInt(s.substr(j + 1, n), 16);\n                        j += n;\n                        if (i >= 32 && i <= 126 &&\n                                i !== 34 && i !== 92 && i !== 39) {\n                            warningAt(\"Unnecessary escapement.\", line, character);\n                        }\n                        character += n;\n                        c = String.fromCharCode(i);\n                    }\n                    j = 0;\n                    for (;;) {\n                        while (j >= s.length) {\n                            j = 0;\n                            if (xmode !== 'html' || !nextLine()) {\n                                errorAt(\"Unclosed string.\", line, from);\n                            }\n                        }\n                        c = s.charAt(j);\n                        if (c === x) {\n                            character += 1;\n                            s = s.substr(j + 1);\n                            return it('(string)', r, x);\n                        }\n                        if (c < ' ') {\n                            if (c === '\\n' || c === '\\r') {\n                                break;\n                            }\n                            warningAt(\"Control character in string: {a}.\",\n                                    line, character + j, s.slice(0, j));\n                        } else if (c === xquote) {\n                            warningAt(\"Bad HTML string\", line, character + j);\n                        } else if (c === '<') {\n                            if (option.safe && xmode === 'html') {\n                                warningAt(\"ADsafe string violation.\",\n                                        line, character + j);\n                            } else if (s.charAt(j + 1) === '/' && (xmode || option.safe)) {\n                                warningAt(\"Expected '<\\\\/' and instead saw '</'.\", line, character);\n                            } else if (s.charAt(j + 1) === '!' && (xmode || option.safe)) {\n                                warningAt(\"Unexpected '<!' in a string.\", line, character);\n                            }\n                        } else if (c === '\\\\') {\n                            if (xmode === 'html') {\n                                if (option.safe) {\n                                    warningAt(\"ADsafe string violation.\",\n                                            line, character + j);\n                                }\n                            } else if (xmode === 'styleproperty') {\n                                j += 1;\n                                character += 1;\n                                c = s.charAt(j);\n                                if (c !== x) {\n                                    warningAt(\"Escapement in style string.\",\n                                            line, character + j);\n                                }\n                            } else {\n                                j += 1;\n                                character += 1;\n                                c = s.charAt(j);\n                                switch (c) {\n                                case xquote:\n                                    warningAt(\"Bad HTML string\", line,\n                                        character + j);\n                                    break;\n                                case '\\\\':\n                                case '\\'':\n                                case '\"':\n                                case '/':\n                                    break;\n                                case 'b':\n                                    c = '\\b';\n                                    break;\n                                case 'f':\n                                    c = '\\f';\n                                    break;\n                                case 'n':\n                                    c = '\\n';\n                                    break;\n                                case 'r':\n                                    c = '\\r';\n                                    break;\n                                case 't':\n                                    c = '\\t';\n                                    break;\n                                case 'u':\n                                    esc(4);\n                                    break;\n                                case 'v':\n                                    c = '\\v';\n                                    break;\n                                case 'x':\n                                    if (jsonmode) {\n                                        warningAt(\"Avoid \\\\x-.\", line, character);\n                                    }\n                                    esc(2);\n                                    break;\n                                default:\n                                    warningAt(\"Bad escapement.\", line, character);\n                                }\n                            }\n                        }\n                        r += c;\n                        character += 1;\n                        j += 1;\n                    }\n                }\n\n                for (;;) {\n                    if (!s) {\n                        return it(nextLine() ? '(endline)' : '(end)', '');\n                    }\n                    while (xmode === 'outer') {\n                        i = s.search(ox);\n                        if (i === 0) {\n                            break;\n                        } else if (i > 0) {\n                            character += 1;\n                            s = s.slice(i);\n                            break;\n                        } else {\n                            if (!nextLine()) {\n                                return it('(end)', '');\n                            }\n                        }\n                    }\n//                     t = match(rx[xmode] || tx);\n//                     if (!t) {\n//                         if (xmode === 'html') {\n//                             return it('(error)', s.charAt(0));\n//                         } else {\n//                             t = '';\n//                             c = '';\n//                             while (s && s < '!') {\n//                                 s = s.substr(1);\n//                             }\n//                             if (s) {\n//                                 errorAt(\"Unexpected '{a}'.\",\n//                                         line, character, s.substr(0, 1));\n//                             }\n//                         }\n                    t = match(rx[xmode] || tx);\n                    if (!t) {\n                        t = '';\n                        c = '';\n                        while (s && s < '!') {\n                            s = s.substr(1);\n                        }\n                        if (s) {\n                            if (xmode === 'html') {\n                                return it('(error)', s.charAt(0));\n                            } else {\n                                errorAt(\"Unexpected '{a}'.\",\n                                        line, character, s.substr(0, 1));\n                            }\n                        }\n                    } else {\n\n    //      identifier\n\n                        if (c.isAlpha() || c === '_' || c === '$') {\n                            return it('(identifier)', t);\n                        }\n\n    //      number\n\n                        if (c.isDigit()) {\n                            if (xmode !== 'style' && !isFinite(Number(t))) {\n                                warningAt(\"Bad number '{a}'.\",\n                                    line, character, t);\n                            }\n                            if (xmode !== 'style' &&\n                                     xmode !== 'styleproperty' &&\n                                     s.substr(0, 1).isAlpha()) {\n                                warningAt(\"Missing space after '{a}'.\",\n                                        line, character, t);\n                            }\n                            if (c === '0') {\n                                d = t.substr(1, 1);\n                                if (d.isDigit()) {\n                                    if (token.id !== '.' && xmode !== 'styleproperty') {\n                                        warningAt(\"Don't use extra leading zeros '{a}'.\",\n                                            line, character, t);\n                                    }\n                                } else if (jsonmode && (d === 'x' || d === 'X')) {\n                                    warningAt(\"Avoid 0x-. '{a}'.\",\n                                            line, character, t);\n                                }\n                            }\n                            if (t.substr(t.length - 1) === '.') {\n                                warningAt(\n        \"A trailing decimal point can be confused with a dot '{a}'.\",\n                                        line, character, t);\n                            }\n                            return it('(number)', t);\n                        }\n                        switch (t) {\n\n    //      string\n\n                        case '\"':\n                        case \"'\":\n                            return string(t);\n\n    //      // comment\n\n                        case '//':\n                            if (src || (xmode && xmode !== 'script')) {\n                                warningAt(\"Unexpected comment.\", line, character);\n                            } else if (xmode === 'script' && /<\\s*\\//i.test(s)) {\n                                warningAt(\"Unexpected <\\/ in comment.\", line, character);\n                            } else if ((option.safe || xmode === 'script') && ax.test(s)) {\n                                warningAt(\"Dangerous comment.\", line, character);\n                            }\n                            s = '';\n                            token.comment = true;\n                            break;\n\n    //      /* comment\n\n                        case '/*':\n                            if (src || (xmode && xmode !== 'script' && xmode !== 'style' && xmode !== 'styleproperty')) {\n                                warningAt(\"Unexpected comment.\", line, character);\n                            }\n                            if (option.safe && ax.test(s)) {\n                                warningAt(\"ADsafe comment violation.\", line, character);\n                            }\n                            for (;;) {\n                                i = s.search(lx);\n                                if (i >= 0) {\n                                    break;\n                                }\n                                if (!nextLine()) {\n                                    errorAt(\"Unclosed comment.\", line, character);\n                                } else {\n                                    if (option.safe && ax.test(s)) {\n                                        warningAt(\"ADsafe comment violation.\",\n                                                line, character);\n                                    }\n                                }\n                            }\n                            character += i + 2;\n                            if (s.substr(i, 1) === '/') {\n                                errorAt(\"Nested comment.\", line, character);\n                            }\n                            s = s.substr(i + 2);\n                            token.comment = true;\n                            break;\n\n    //      /*members /*jslint /*global\n\n                        case '/*members':\n                        case '/*member':\n                        case '/*jslint':\n                        case '/*global':\n                        case '*/':\n                            return {\n                                value: t,\n                                type: 'special',\n                                line: line,\n                                character: character,\n                                from: from\n                            };\n\n                        case '':\n                            break;\n    //      /\n                        case '/':\n                            if (token.id === '/=') {\n                                errorAt(\n\"A regular expression literal can be confused with '/='.\", line, from);\n                            }\n                            if (prereg) {\n                                depth = 0;\n                                captures = 0;\n                                l = 0;\n                                for (;;) {\n                                    b = true;\n                                    c = s.charAt(l);\n                                    l += 1;\n                                    switch (c) {\n                                    case '':\n                                        errorAt(\"Unclosed regular expression.\",\n                                                line, from);\n                                        return;\n                                    case '/':\n                                        if (depth > 0) {\n                                            warningAt(\"Unescaped '{a}'.\",\n                                                    line, from + l, '/');\n                                        }\n                                        c = s.substr(0, l - 1);\n                                        q = {\n                                            g: true,\n                                            i: true,\n                                            m: true\n                                        };\n                                        while (q[s.charAt(l)] === true) {\n                                            q[s.charAt(l)] = false;\n                                            l += 1;\n                                        }\n                                        character += l;\n                                        s = s.substr(l);\n                                        q = s.charAt(0);\n                                        if (q === '/' || q === '*') {\n                                            errorAt(\"Confusing regular expression.\",\n                                                    line, from);\n                                        }\n                                        return it('(regexp)', c);\n                                    case '\\\\':\n                                        c = s.charAt(l);\n                                        if (c < ' ') {\n                                            warningAt(\n\"Unexpected control character in regular expression.\", line, from + l);\n                                        } else if (c === '<') {\n                                            warningAt(\n\"Unexpected escaped character '{a}' in regular expression.\", line, from + l, c);\n                                        }\n                                        l += 1;\n                                        break;\n                                    case '(':\n                                        depth += 1;\n                                        b = false;\n                                        if (s.charAt(l) === '?') {\n                                            l += 1;\n                                            switch (s.charAt(l)) {\n                                            case ':':\n                                            case '=':\n                                            case '!':\n                                                l += 1;\n                                                break;\n                                            default:\n                                                warningAt(\n\"Expected '{a}' and instead saw '{b}'.\", line, from + l, ':', s.charAt(l));\n                                            }\n                                        } else {\n                                            captures += 1;\n                                        }\n                                        break;\n                                    case '|':\n                                        b = false;\n                                        break;\n                                    case ')':\n                                        if (depth === 0) {\n                                            warningAt(\"Unescaped '{a}'.\",\n                                                    line, from + l, ')');\n                                        } else {\n                                            depth -= 1;\n                                        }\n                                        break;\n                                    case ' ':\n                                        q = 1;\n                                        while (s.charAt(l) === ' ') {\n                                            l += 1;\n                                            q += 1;\n                                        }\n                                        if (q > 1) {\n                                            warningAt(\n\"Spaces are hard to count. Use {{a}}.\", line, from + l, q);\n                                        }\n                                        break;\n                                    case '[':\n                                        c = s.charAt(l);\n                                        if (c === '^') {\n                                            l += 1;\n                                            if (option.regexp) {\n                                                warningAt(\"Insecure '{a}'.\",\n                                                        line, from + l, c);\n                                            } else if (s.charAt(l) === ']') {\n                                                errorAt(\"Unescaped '{a}'.\",\n                                                    line, from + l, '^');\n                                            }\n                                        }\n                                        q = false;\n                                        if (c === ']') {\n                                            warningAt(\"Empty class.\", line,\n                                                    from + l - 1);\n                                            q = true;\n                                        }\nklass:                                  do {\n                                            c = s.charAt(l);\n                                            l += 1;\n                                            switch (c) {\n                                            case '[':\n                                            case '^':\n                                                warningAt(\"Unescaped '{a}'.\",\n                                                        line, from + l, c);\n                                                q = true;\n                                                break;\n                                            case '-':\n                                                if (q) {\n                                                    q = false;\n                                                } else {\n                                                    warningAt(\"Unescaped '{a}'.\",\n                                                            line, from + l, '-');\n                                                    q = true;\n                                                }\n                                                break;\n                                            case ']':\n                                                if (!q) {\n                                                    warningAt(\"Unescaped '{a}'.\",\n                                                            line, from + l - 1, '-');\n                                                }\n                                                break klass;\n                                            case '\\\\':\n                                                c = s.charAt(l);\n                                                if (c < ' ') {\n                                                    warningAt(\n\"Unexpected control character in regular expression.\", line, from + l);\n                                                } else if (c === '<') {\n                                                    warningAt(\n\"Unexpected escaped character '{a}' in regular expression.\", line, from + l, c);\n                                                }\n                                                l += 1;\n                                                q = true;\n                                                break;\n                                            case '/':\n                                                warningAt(\"Unescaped '{a}'.\",\n                                                        line, from + l - 1, '/');\n                                                q = true;\n                                                break;\n                                            case '<':\n                                                if (xmode === 'script') {\n                                                    c = s.charAt(l);\n                                                    if (c === '!' || c === '/') {\n                                                        warningAt(\n\"HTML confusion in regular expression '<{a}'.\", line, from + l, c);\n                                                    }\n                                                }\n                                                q = true;\n                                                break;\n                                            default:\n                                                q = true;\n                                            }\n                                        } while (c);\n                                        break;\n                                    case '.':\n                                        if (option.regexp) {\n                                            warningAt(\"Insecure '{a}'.\", line,\n                                                    from + l, c);\n                                        }\n                                        break;\n                                    case ']':\n                                    case '?':\n                                    case '{':\n                                    case '}':\n                                    case '+':\n                                    case '*':\n                                        warningAt(\"Unescaped '{a}'.\", line,\n                                                from + l, c);\n                                        break;\n                                    case '<':\n                                        if (xmode === 'script') {\n                                            c = s.charAt(l);\n                                            if (c === '!' || c === '/') {\n                                                warningAt(\n\"HTML confusion in regular expression '<{a}'.\", line, from + l, c);\n                                            }\n                                        }\n                                    }\n                                    if (b) {\n                                        switch (s.charAt(l)) {\n                                        case '?':\n                                        case '+':\n                                        case '*':\n                                            l += 1;\n                                            if (s.charAt(l) === '?') {\n                                                l += 1;\n                                            }\n                                            break;\n                                        case '{':\n                                            l += 1;\n                                            c = s.charAt(l);\n                                            if (c < '0' || c > '9') {\n                                                warningAt(\n\"Expected a number and instead saw '{a}'.\", line, from + l, c);\n                                            }\n                                            l += 1;\n                                            low = +c;\n                                            for (;;) {\n                                                c = s.charAt(l);\n                                                if (c < '0' || c > '9') {\n                                                    break;\n                                                }\n                                                l += 1;\n                                                low = +c + (low * 10);\n                                            }\n                                            high = low;\n                                            if (c === ',') {\n                                                l += 1;\n                                                high = Infinity;\n                                                c = s.charAt(l);\n                                                if (c >= '0' && c <= '9') {\n                                                    l += 1;\n                                                    high = +c;\n                                                    for (;;) {\n                                                        c = s.charAt(l);\n                                                        if (c < '0' || c > '9') {\n                                                            break;\n                                                        }\n                                                        l += 1;\n                                                        high = +c + (high * 10);\n                                                    }\n                                                }\n                                            }\n                                            if (s.charAt(l) !== '}') {\n                                                warningAt(\n\"Expected '{a}' and instead saw '{b}'.\", line, from + l, '}', c);\n                                            } else {\n                                                l += 1;\n                                            }\n                                            if (s.charAt(l) === '?') {\n                                                l += 1;\n                                            }\n                                            if (low > high) {\n                                                warningAt(\n\"'{a}' should not be greater than '{b}'.\", line, from + l, low, high);\n                                            }\n                                        }\n                                    }\n                                }\n                                c = s.substr(0, l - 1);\n                                character += l;\n                                s = s.substr(l);\n                                return it('(regexp)', c);\n                            }\n                            return it('(punctuator)', t);\n\n    //      punctuator\n\n                        case '<!--':\n                            l = line;\n                            c = character;\n                            for (;;) {\n                                i = s.indexOf('--');\n                                if (i >= 0) {\n                                    break;\n                                }\n                                i = s.indexOf('<!');\n                                if (i >= 0) {\n                                    errorAt(\"Nested HTML comment.\",\n                                        line, character + i);\n                                }\n                                if (!nextLine()) {\n                                    errorAt(\"Unclosed HTML comment.\", l, c);\n                                }\n                            }\n                            l = s.indexOf('<!');\n                            if (l >= 0 && l < i) {\n                                errorAt(\"Nested HTML comment.\",\n                                    line, character + l);\n                            }\n                            character += i;\n                            if (s.charAt(i + 2) !== '>') {\n                                errorAt(\"Expected --\>.\", line, character);\n                            }\n                            character += 3;\n                            s = s.slice(i + 3);\n                            break;\n                        case '#':\n                            if (xmode === 'html' || xmode === 'styleproperty') {\n                                for (;;) {\n                                    c = s.charAt(0);\n                                    if ((c < '0' || c > '9') &&\n                                            (c < 'a' || c > 'f') &&\n                                            (c < 'A' || c > 'F')) {\n                                        break;\n                                    }\n                                    character += 1;\n                                    s = s.substr(1);\n                                    t += c;\n                                }\n                                if (t.length !== 4 && t.length !== 7) {\n                                    warningAt(\"Bad hex color '{a}'.\", line,\n                                        from + l, t);\n                                }\n                                return it('(color)', t);\n                            }\n                            return it('(punctuator)', t);\n                        default:\n                            if (xmode === 'outer' && c === '&') {\n                                character += 1;\n                                s = s.substr(1);\n                                for (;;) {\n                                    c = s.charAt(0);\n                                    character += 1;\n                                    s = s.substr(1);\n                                    if (c === ';') {\n                                        break;\n                                    }\n                                    if (!((c >= '0' && c <= '9') ||\n                                            (c >= 'a' && c <= 'z') ||\n                                            c === '#')) {\n                                        errorAt(\"Bad entity\", line, from + l,\n                                        character);\n                                    }\n                                }\n                                break;\n                            }\n                            return it('(punctuator)', t);\n                        }\n                    }\n                }\n            }\n        };\n    }());\n\n\n    function addlabel(t, type) {\n\n        if (option.safe && funct['(global)'] &&\n                typeof predefined[t] !== 'boolean') {\n            warning('ADsafe global: ' + t + '.', token);\n        } else if (t === 'hasOwnProperty') {\n            warning(\"'hasOwnProperty' is a really bad name.\");\n        }\n\n// Define t in the current function in the current scope.\n\n        if (is_own(funct, t) && !funct['(global)']) {\n            warning(funct[t] === true ?\n                \"'{a}' was used before it was defined.\" :\n                \"'{a}' is already defined.\",\n                nexttoken, t);\n        }\n        funct[t] = type;\n        if (funct['(global)']) {\n            global[t] = funct;\n            if (is_own(implied, t)) {\n                warning(\"'{a}' was used before it was defined.\", nexttoken, t);\n                delete implied[t];\n            }\n        } else {\n            scope[t] = funct;\n        }\n    }\n\n\n    function doOption() {\n        var b, obj, filter, o = nexttoken.value, t, v;\n        switch (o) {\n        case '*/':\n            error(\"Unbegun comment.\");\n            break;\n        case '/*members':\n        case '/*member':\n            o = '/*members';\n            if (!membersOnly) {\n                membersOnly = {};\n            }\n            obj = membersOnly;\n            break;\n        case '/*jslint':\n            if (option.safe) {\n                warning(\"ADsafe restriction.\");\n            }\n            obj = option;\n            filter = boolOptions;\n            break;\n        case '/*global':\n            if (option.safe) {\n                warning(\"ADsafe restriction.\");\n            }\n            obj = predefined;\n            break;\n        default:\n        }\n        t = lex.token();\nloop:   for (;;) {\n            for (;;) {\n                if (t.type === 'special' && t.value === '*/') {\n                    break loop;\n                }\n                if (t.id !== '(endline)' && t.id !== ',') {\n                    break;\n                }\n                t = lex.token();\n            }\n            if (t.type !== '(string)' && t.type !== '(identifier)' &&\n                    o !== '/*members') {\n                error(\"Bad option.\", t);\n            }\n            v = lex.token();\n            if (v.id === ':') {\n                v = lex.token();\n                if (obj === membersOnly) {\n                    error(\"Expected '{a}' and instead saw '{b}'.\",\n                            t, '*/', ':');\n                }\n                if (t.value === 'indent' && o === '/*jslint') {\n                    b = +v.value;\n                    if (typeof b !== 'number' || !isFinite(b) || b <= 0 ||\n                            Math.floor(b) !== b) {\n                        error(\"Expected a small integer and instead saw '{a}'.\",\n                                v, v.value);\n                    }\n                    obj.white = true;\n                    obj.indent = b;\n                } else if (t.value === 'maxerr' && o === '/*jslint') {\n                    b = +v.value;\n                    if (typeof b !== 'number' || !isFinite(b) || b <= 0 ||\n                            Math.floor(b) !== b) {\n                        error(\"Expected a small integer and instead saw '{a}'.\",\n                                v, v.value);\n                    }\n                    obj.maxerr = b;\n                } else if (t.value === 'maxlen' && o === '/*jslint') {\n                    b = +v.value;\n                    if (typeof b !== 'number' || !isFinite(b) || b <= 0 ||\n                            Math.floor(b) !== b) {\n                        error(\"Expected a small integer and instead saw '{a}'.\",\n                                v, v.value);\n                    }\n                    obj.maxlen = b;\n                } else if (v.value === 'true') {\n                    obj[t.value] = true;\n                } else if (v.value === 'false') {\n                    obj[t.value] = false;\n                } else {\n                    error(\"Bad option value.\", v);\n                }\n                t = lex.token();\n            } else {\n                if (o === '/*jslint') {\n                    error(\"Missing option value.\", t);\n                }\n                obj[t.value] = false;\n                t = v;\n            }\n        }\n        if (filter) {\n            assume();\n        }\n    }\n\n\n// We need a peek function. If it has an argument, it peeks that much farther\n// ahead. It is used to distinguish\n//     for ( var i in ...\n// from\n//     for ( var i = ...\n\n    function peek(p) {\n        var i = p || 0, j = 0, t;\n\n        while (j <= i) {\n            t = lookahead[j];\n            if (!t) {\n                t = lookahead[j] = lex.token();\n            }\n            j += 1;\n        }\n        return t;\n    }\n\n\n\n// Produce the next token. It looks for programming errors.\n\n    function advance(id, t) {\n        switch (token.id) {\n        case '(number)':\n            if (nexttoken.id === '.') {\n                warning(\n\"A dot following a number can be confused with a decimal point.\", token);\n            }\n            break;\n        case '-':\n            if (nexttoken.id === '-' || nexttoken.id === '--') {\n                warning(\"Confusing minusses.\");\n            }\n            break;\n        case '+':\n            if (nexttoken.id === '+' || nexttoken.id === '++') {\n                warning(\"Confusing plusses.\");\n            }\n            break;\n        }\n        if (token.type === '(string)' || token.identifier) {\n            anonname = token.value;\n        }\n\n        if (id && nexttoken.id !== id) {\n            if (t) {\n                if (nexttoken.id === '(end)') {\n                    warning(\"Unmatched '{a}'.\", t, t.id);\n                } else {\n                    warning(\n\"Expected '{a}' to match '{b}' from line {c} and instead saw '{d}'.\",\n                            nexttoken, id, t.id, t.line, nexttoken.value);\n                }\n            } else if (nexttoken.type !== '(identifier)' ||\n                            nexttoken.value !== id) {\n                warning(\"Expected '{a}' and instead saw '{b}'.\",\n                        nexttoken, id, nexttoken.value);\n            }\n        }\n        prevtoken = token;\n        token = nexttoken;\n        for (;;) {\n            nexttoken = lookahead.shift() || lex.token();\n            if (nexttoken.id === '(end)' || nexttoken.id === '(error)') {\n                return;\n            }\n            if (nexttoken.type === 'special') {\n                doOption();\n            } else {\n                if (nexttoken.id !== '(endline)') {\n                    break;\n                }\n            }\n        }\n    }\n\n\n// This is the heart of JSLINT, the Pratt parser. In addition to parsing, it\n// is looking for ad hoc lint patterns. We add to Pratt's model .fud, which is\n// like nud except that it is only used on the first token of a statement.\n// Having .fud makes it much easier to define JavaScript. I retained Pratt's\n// nomenclature.\n\n// .nud     Null denotation\n// .fud     First null denotation\n// .led     Left denotation\n//  lbp     Left binding power\n//  rbp     Right binding power\n\n// They are key to the parsing method called Top Down Operator Precedence.\n\n    function parse(rbp, initial) {\n        var left;\n        if (nexttoken.id === '(end)') {\n            error(\"Unexpected early end of program.\", token);\n        }\n        advance();\n        if (option.safe && typeof predefined[token.value] === 'boolean' &&\n                (nexttoken.id !== '(' && nexttoken.id !== '.')) {\n            warning('ADsafe violation.', token);\n        }\n        if (initial) {\n            anonname = 'anonymous';\n            funct['(verb)'] = token.value;\n        }\n        if (initial === true && token.fud) {\n            left = token.fud();\n        } else {\n            if (token.nud) {\n                left = token.nud();\n            } else {\n                if (nexttoken.type === '(number)' && token.id === '.') {\n                    warning(\n\"A leading decimal point can be confused with a dot: '.{a}'.\",\n                            token, nexttoken.value);\n                    advance();\n                    return token;\n                } else {\n                    error(\"Expected an identifier and instead saw '{a}'.\",\n                            token, token.id);\n                }\n            }\n            while (rbp < nexttoken.lbp) {\n                advance();\n                if (token.led) {\n                    left = token.led(left);\n                } else {\n                    error(\"Expected an operator and instead saw '{a}'.\",\n                        token, token.id);\n                }\n            }\n        }\n        return left;\n    }\n\n\n// Functions for conformance of style.\n\n    function adjacent(left, right) {\n        left = left || token;\n        right = right || nexttoken;\n        if (option.white || xmode === 'styleproperty' || xmode === 'style') {\n            if (left.character !== right.from && left.line === right.line) {\n                warning(\"Unexpected space after '{a}'.\", right, left.value);\n            }\n        }\n    }\n\n    function nobreak(left, right) {\n        left = left || token;\n        right = right || nexttoken;\n        if (left.character !== right.from || left.line !== right.line) {\n            warning(\"Unexpected space before '{a}'.\", right, right.value);\n        }\n    }\n\n    function nospace(left, right) {\n        left = left || token;\n        right = right || nexttoken;\n        if (option.white && !left.comment) {\n            if (left.line === right.line) {\n                adjacent(left, right);\n            }\n        }\n    }\n\n\n    function nonadjacent(left, right) {\n        if (option.white) {\n            left = left || token;\n            right = right || nexttoken;\n            if (left.line === right.line && left.character === right.from) {\n                warning(\"Missing space after '{a}'.\",\n                        nexttoken, left.value);\n            }\n        }\n    }\n\n    function nobreaknonadjacent(left, right) {\n        left = left || token;\n        right = right || nexttoken;\n        if (!option.laxbreak && left.line !== right.line) {\n            warning(\"Bad line breaking before '{a}'.\", right, right.id);\n        } else if (option.white) {\n            left = left || token;\n            right = right || nexttoken;\n            if (left.character === right.from) {\n                warning(\"Missing space after '{a}'.\",\n                        nexttoken, left.value);\n            }\n        }\n    }\n\n    function indentation(bias) {\n        var i;\n        if (option.white && nexttoken.id !== '(end)') {\n            i = indent + (bias || 0);\n            if (nexttoken.from !== i) {\n                warning(\n\"Expected '{a}' to have an indentation at {b} instead at {c}.\",\n                        nexttoken, nexttoken.value, i, nexttoken.from);\n            }\n        }\n    }\n\n    function nolinebreak(t) {\n        t = t || token;\n        if (t.line !== nexttoken.line) {\n            warning(\"Line breaking error '{a}'.\", t, t.value);\n        }\n    }\n\n\n    function comma() {\n        if (token.line !== nexttoken.line) {\n            if (!option.laxbreak) {\n                warning(\"Bad line breaking before '{a}'.\", token, nexttoken.id);\n            }\n        } else if (token.character !== nexttoken.from && option.white) {\n            warning(\"Unexpected space after '{a}'.\", nexttoken, token.value);\n        }\n        advance(',');\n        nonadjacent(token, nexttoken);\n    }\n\n\n// Functional constructors for making the symbols that will be inherited by\n// tokens.\n\n    function symbol(s, p) {\n        var x = syntax[s];\n        if (!x || typeof x !== 'object') {\n            syntax[s] = x = {\n                id: s,\n                lbp: p,\n                value: s\n            };\n        }\n        return x;\n    }\n\n\n    function delim(s) {\n        return symbol(s, 0);\n    }\n\n\n    function stmt(s, f) {\n        var x = delim(s);\n        x.identifier = x.reserved = true;\n        x.fud = f;\n        return x;\n    }\n\n\n    function blockstmt(s, f) {\n        var x = stmt(s, f);\n        x.block = true;\n        return x;\n    }\n\n\n    function reserveName(x) {\n        var c = x.id.charAt(0);\n        if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {\n            x.identifier = x.reserved = true;\n        }\n        return x;\n    }\n\n\n    function prefix(s, f) {\n        var x = symbol(s, 150);\n        reserveName(x);\n        x.nud = (typeof f === 'function') ? f : function () {\n            this.right = parse(150);\n            this.arity = 'unary';\n            if (this.id === '++' || this.id === '--') {\n                if (option.plusplus) {\n                    warning(\"Unexpected use of '{a}'.\", this, this.id);\n                } else if ((!this.right.identifier || this.right.reserved) &&\n                        this.right.id !== '.' && this.right.id !== '[') {\n                    warning(\"Bad operand.\", this);\n                }\n            }\n            return this;\n        };\n        return x;\n    }\n\n\n    function type(s, f) {\n        var x = delim(s);\n        x.type = s;\n        x.nud = f;\n        return x;\n    }\n\n\n    function reserve(s, f) {\n        var x = type(s, f);\n        x.identifier = x.reserved = true;\n        return x;\n    }\n\n\n    function reservevar(s, v) {\n        return reserve(s, function () {\n            if (typeof v === 'function') {\n                v(this);\n            }\n            return this;\n        });\n    }\n\n\n    function infix(s, f, p, w) {\n        var x = symbol(s, p);\n        reserveName(x);\n        x.led = function (left) {\n            if (!w) {\n                nobreaknonadjacent(prevtoken, token);\n                nonadjacent(token, nexttoken);\n            }\n            if (typeof f === 'function') {\n                return f(left, this);\n            } else {\n                this.left = left;\n                this.right = parse(p);\n                return this;\n            }\n        };\n        return x;\n    }\n\n\n    function relation(s, f) {\n        var x = symbol(s, 100);\n        x.led = function (left) {\n            nobreaknonadjacent(prevtoken, token);\n            nonadjacent(token, nexttoken);\n            var right = parse(100);\n            if ((left && left.id === 'NaN') || (right && right.id === 'NaN')) {\n                warning(\"Use the isNaN function to compare with NaN.\", this);\n            } else if (f) {\n                f.apply(this, [left, right]);\n            }\n            if (left.id === '!') {\n                warning(\"Confusing use of '{a}'.\", left, '!');\n            }\n            if (right.id === '!') {\n                warning(\"Confusing use of '{a}'.\", left, '!');\n            }\n            this.left = left;\n            this.right = right;\n            return this;\n        };\n        return x;\n    }\n\n\n    function isPoorRelation(node) {\n        return node &&\n              ((node.type === '(number)' && +node.value === 0) ||\n               (node.type === '(string)' && node.value === '') ||\n                node.type === 'true' ||\n                node.type === 'false' ||\n                node.type === 'undefined' ||\n                node.type === 'null');\n    }\n\n\n    function assignop(s, f) {\n        symbol(s, 20).exps = true;\n        return infix(s, function (left, that) {\n            var l;\n            that.left = left;\n            if (predefined[left.value] === false &&\n                    scope[left.value]['(global)'] === true) {\n                warning(\"Read only.\", left);\n            } else if (left['function']) {\n                warning(\"'{a}' is a function.\", left, left.value);\n            }\n            if (option.safe) {\n                l = left;\n                do {\n                    if (typeof predefined[l.value] === 'boolean') {\n                        warning('ADsafe violation.', l);\n                    }\n                    l = l.left;\n                } while (l);\n            }\n            if (left) {\n                if (left.id === '.' || left.id === '[') {\n                    if (!left.left || left.left.value === 'arguments') {\n                        warning('Bad assignment.', that);\n                    }\n                    that.right = parse(19);\n                    return that;\n                } else if (left.identifier && !left.reserved) {\n                    if (funct[left.value] === 'exception') {\n                        warning(\"Do not assign to the exception parameter.\", left);\n                    }\n                    that.right = parse(19);\n                    return that;\n                }\n                if (left === syntax['function']) {\n                    warning(\n\"Expected an identifier in an assignment and instead saw a function invocation.\",\n                                token);\n                }\n            }\n            error(\"Bad assignment.\", that);\n        }, 20);\n    }\n\n\n    function bitwise(s, f, p) {\n        var x = symbol(s, p);\n        reserveName(x);\n        x.led = (typeof f === 'function') ? f : function (left) {\n            if (option.bitwise) {\n                warning(\"Unexpected use of '{a}'.\", this, this.id);\n            }\n            this.left = left;\n            this.right = parse(p);\n            return this;\n        };\n        return x;\n    }\n\n\n    function bitwiseassignop(s) {\n        symbol(s, 20).exps = true;\n        return infix(s, function (left, that) {\n            if (option.bitwise) {\n                warning(\"Unexpected use of '{a}'.\", that, that.id);\n            }\n            nonadjacent(prevtoken, token);\n            nonadjacent(token, nexttoken);\n            if (left) {\n                if (left.id === '.' || left.id === '[' ||\n                        (left.identifier && !left.reserved)) {\n                    parse(19);\n                    return that;\n                }\n                if (left === syntax['function']) {\n                    warning(\n\"Expected an identifier in an assignment, and instead saw a function invocation.\",\n                                token);\n                }\n                return that;\n            }\n            error(\"Bad assignment.\", that);\n        }, 20);\n    }\n\n\n    function suffix(s, f) {\n        var x = symbol(s, 150);\n        x.led = function (left) {\n            if (option.plusplus) {\n                warning(\"Unexpected use of '{a}'.\", this, this.id);\n            } else if ((!left.identifier || left.reserved) &&\n                    left.id !== '.' && left.id !== '[') {\n                warning(\"Bad operand.\", this);\n            }\n            this.left = left;\n            return this;\n        };\n        return x;\n    }\n\n\n    function optionalidentifier() {\n        if (nexttoken.identifier) {\n            advance();\n            if (option.safe && banned[token.value]) {\n                warning(\"ADsafe violation: '{a}'.\", token, token.value);\n            } else if (token.reserved && !option.es5) {\n                warning(\"Expected an identifier and instead saw '{a}' (a reserved word).\",\n                        token, token.id);\n            }\n            return token.value;\n        }\n    }\n\n\n    function identifier() {\n        var i = optionalidentifier();\n        if (i) {\n            return i;\n        }\n        if (token.id === 'function' && nexttoken.id === '(') {\n            warning(\"Missing name in function statement.\");\n        } else {\n            error(\"Expected an identifier and instead saw '{a}'.\",\n                    nexttoken, nexttoken.value);\n        }\n    }\n\n\n    function reachable(s) {\n        var i = 0, t;\n        if (nexttoken.id !== ';' || noreach) {\n            return;\n        }\n        for (;;) {\n            t = peek(i);\n            if (t.reach) {\n                return;\n            }\n            if (t.id !== '(endline)') {\n                if (t.id === 'function') {\n                    warning(\n\"Inner functions should be listed at the top of the outer function.\", t);\n                    break;\n                }\n                warning(\"Unreachable '{a}' after '{b}'.\", t, t.value, s);\n                break;\n            }\n            i += 1;\n        }\n    }\n\n\n    function statement(noindent) {\n        var i = indent, r, s = scope, t = nexttoken;\n\n// We don't like the empty statement.\n\n        if (t.id === ';') {\n            warning(\"Unnecessary semicolon.\", t);\n            advance(';');\n            return;\n        }\n\n// Is this a labelled statement?\n\n        if (t.identifier && !t.reserved && peek().id === ':') {\n            advance();\n            advance(':');\n            scope = Object.create(s);\n            addlabel(t.value, 'label');\n            if (!nexttoken.labelled) {\n                warning(\"Label '{a}' on {b} statement.\",\n                        nexttoken, t.value, nexttoken.value);\n            }\n            if (jx.test(t.value + ':')) {\n                warning(\"Label '{a}' looks like a javascript url.\",\n                        t, t.value);\n            }\n            nexttoken.label = t.value;\n            t = nexttoken;\n        }\n\n// Parse the statement.\n\n        if (!noindent) {\n            indentation();\n        }\n        r = parse(0, true);\n\n// Look for the final semicolon.\n\n        if (!t.block) {\n            if (!r || !r.exps) {\n                warning(\n\"Expected an assignment or function call and instead saw an expression.\",\n                        token);\n            } else if (r.id === '(' && r.left.id === 'new') {\n                warning(\"Do not use 'new' for side effects.\");\n            }\n            if (nexttoken.id !== ';') {\n                warningAt(\"Missing semicolon.\", token.line,\n                        token.from + token.value.length);\n            } else {\n                adjacent(token, nexttoken);\n                advance(';');\n                nonadjacent(token, nexttoken);\n            }\n        }\n\n// Restore the indentation.\n\n        indent = i;\n        scope = s;\n        return r;\n    }\n\n\n    function use_strict() {\n        if (nexttoken.value === 'use strict') {\n            advance();\n            advance(';');\n            strict_mode = true;\n            option.newcap = true;\n            option.undef = true;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n\n    function statements(begin) {\n        var a = [], f, p;\n        if (begin && !use_strict() && option.strict) {\n            warning('Missing \"use strict\" statement.', nexttoken);\n        }\n        if (option.adsafe) {\n            switch (begin) {\n            case 'script':\n                if (!adsafe_may) {\n                    if (nexttoken.value !== 'ADSAFE' ||\n                            peek(0).id !== '.' ||\n                            (peek(1).value !== 'id' &&\n                            peek(1).value !== 'go')) {\n                        error('ADsafe violation: Missing ADSAFE.id or ADSAFE.go.',\n                            nexttoken);\n                    }\n                }\n                if (nexttoken.value === 'ADSAFE' &&\n                        peek(0).id === '.' &&\n                        peek(1).value === 'id') {\n                    if (adsafe_may) {\n                        error('ADsafe violation.', nexttoken);\n                    }\n                    advance('ADSAFE');\n                    advance('.');\n                    advance('id');\n                    advance('(');\n                    if (nexttoken.value !== adsafe_id) {\n                        error('ADsafe violation: id does not match.', nexttoken);\n                    }\n                    advance('(string)');\n                    advance(')');\n                    advance(';');\n                    adsafe_may = true;\n                }\n                break;\n            case 'lib':\n                if (nexttoken.value === 'ADSAFE') {\n                    advance('ADSAFE');\n                    advance('.');\n                    advance('lib');\n                    advance('(');\n                    advance('(string)');\n                    comma();\n                    f = parse(0);\n                    if (f.id !== 'function') {\n                        error('The second argument to lib must be a function.', f);\n                    }\n                    p = f.funct['(params)'];\n                    p = p && p.join(', ');\n                    if (p && p !== 'lib') {\n                        error(\"Expected '{a}' and instead saw '{b}'.\",\n                            f, '(lib)', '(' + p + ')');\n                    }\n                    advance(')');\n                    advance(';');\n                    return a;\n                } else {\n                    error(\"ADsafe lib violation.\");\n                }\n            }\n        }\n        while (!nexttoken.reach && nexttoken.id !== '(end)') {\n            if (nexttoken.id === ';') {\n                warning(\"Unnecessary semicolon.\");\n                advance(';');\n            } else {\n                a.push(statement());\n            }\n        }\n        return a;\n    }\n\n\n    function block(f) {\n        var a, b = inblock, old_indent = indent, s = scope, t;\n        inblock = f;\n        scope = Object.create(scope);\n        nonadjacent(token, nexttoken);\n        t = nexttoken;\n        if (nexttoken.id === '{') {\n            advance('{');\n            if (nexttoken.id !== '}' || token.line !== nexttoken.line) {\n                indent += option.indent;\n                while (!f && nexttoken.from > indent) {\n                    indent += option.indent;\n                }\n                if (!f) {\n                    use_strict();\n                }\n                a = statements();\n                indent -= option.indent;\n                indentation();\n            }\n            advance('}', t);\n            indent = old_indent;\n        } else {\n            warning(\"Expected '{a}' and instead saw '{b}'.\",\n                    nexttoken, '{', nexttoken.value);\n            noreach = true;\n            a = [statement()];\n            noreach = false;\n        }\n        funct['(verb)'] = null;\n        scope = s;\n        inblock = b;\n        if (f && (!a || a.length === 0)) {\n            warning(\"Empty block.\");\n        }\n        return a;\n    }\n\n\n    function countMember(m) {\n        if (membersOnly && typeof membersOnly[m] !== 'boolean') {\n            warning(\"Unexpected /*member '{a}'.\", token, m);\n        }\n        if (typeof member[m] === 'number') {\n            member[m] += 1;\n        } else {\n            member[m] = 1;\n        }\n    }\n\n\n    function note_implied(token) {\n        var name = token.value, line = token.line, a = implied[name];\n        if (typeof a === 'function') {\n            a = false;\n        }\n        if (!a) {\n            a = [line];\n            implied[name] = a;\n        } else if (a[a.length - 1] !== line) {\n            a.push(line);\n        }\n    }\n\n\n// CSS parsing.\n\n\n    function cssName() {\n        if (nexttoken.identifier) {\n            advance();\n            return true;\n        }\n    }\n\n\n    function cssNumber() {\n        if (nexttoken.id === '-') {\n            advance('-');\n            adjacent();\n            nolinebreak();\n        }\n        if (nexttoken.type === '(number)') {\n            advance('(number)');\n            return true;\n        }\n    }\n\n\n    function cssString() {\n        if (nexttoken.type === '(string)') {\n            advance();\n            return true;\n        }\n    }\n\n\n    function cssColor() {\n        var i, number, value;\n        if (nexttoken.identifier) {\n            value = nexttoken.value;\n            if (value === 'rgb' || value === 'rgba') {\n                advance();\n                advance('(');\n                for (i = 0; i < 3; i += 1) {\n                    if (i) {\n                        advance(',');\n                    }\n                    number = nexttoken.value;\n                    if (nexttoken.type !== '(number)' || number < 0) {\n                        warning(\"Expected a positive number and instead saw '{a}'\",\n                            nexttoken, number);\n                        advance();\n                    } else {\n                        advance();\n                        if (nexttoken.id === '%') {\n                            advance('%');\n                            if (number > 100) {\n                                warning(\"Expected a percentage and instead saw '{a}'\",\n                                    token, number);\n                            }\n                        } else {\n                            if (number > 255) {\n                                warning(\"Expected a small number and instead saw '{a}'\",\n                                    token, number);\n                            }\n                        }\n                    }\n                }\n                if (value === 'rgba') {\n                    advance(',');\n                    number = +nexttoken.value;\n                    if (nexttoken.type !== '(number)' || number < 0 || number > 1) {\n                        warning(\"Expected a number between 0 and 1 and instead saw '{a}'\",\n                            nexttoken, number);\n                    }\n                    advance();\n                    if (nexttoken.id === '%') {\n                        warning(\"Unexpected '%'.\");\n                        advance('%');\n                    }\n                }\n                advance(')');\n                return true;\n            } else if (cssColorData[nexttoken.value] === true) {\n                advance();\n                return true;\n            }\n        } else if (nexttoken.type === '(color)') {\n            advance();\n            return true;\n        }\n        return false;\n    }\n\n\n    function cssLength() {\n        if (nexttoken.id === '-') {\n            advance('-');\n            adjacent();\n            nolinebreak();\n        }\n        if (nexttoken.type === '(number)') {\n            advance();\n            if (nexttoken.type !== '(string)' &&\n                    cssLengthData[nexttoken.value] === true) {\n                adjacent();\n                advance();\n            } else if (+token.value !== 0) {\n                warning(\"Expected a linear unit and instead saw '{a}'.\",\n                    nexttoken, nexttoken.value);\n            }\n            return true;\n        }\n        return false;\n    }\n\n\n    function cssLineHeight() {\n        if (nexttoken.id === '-') {\n            advance('-');\n            adjacent();\n        }\n        if (nexttoken.type === '(number)') {\n            advance();\n            if (nexttoken.type !== '(string)' &&\n                    cssLengthData[nexttoken.value] === true) {\n                adjacent();\n                advance();\n            }\n            return true;\n        }\n        return false;\n    }\n\n\n    function cssWidth() {\n        if (nexttoken.identifier) {\n            switch (nexttoken.value) {\n            case 'thin':\n            case 'medium':\n            case 'thick':\n                advance();\n                return true;\n            }\n        } else {\n            return cssLength();\n        }\n    }\n\n\n    function cssMargin() {\n        if (nexttoken.identifier) {\n            if (nexttoken.value === 'auto') {\n                advance();\n                return true;\n            }\n        } else {\n            return cssLength();\n        }\n    }\n\n    function cssAttr() {\n        if (nexttoken.identifier && nexttoken.value === 'attr') {\n            advance();\n            advance('(');\n            if (!nexttoken.identifier) {\n                warning(\"Expected a name and instead saw '{a}'.\",\n                        nexttoken, nexttoken.value);\n            }\n            advance();\n            advance(')');\n            return true;\n        }\n        return false;\n    }\n\n\n    function cssCommaList() {\n        while (nexttoken.id !== ';') {\n            if (!cssName() && !cssString()) {\n                warning(\"Expected a name and instead saw '{a}'.\",\n                        nexttoken, nexttoken.value);\n            }\n            if (nexttoken.id !== ',') {\n                return true;\n            }\n            comma();\n        }\n    }\n\n\n    function cssCounter() {\n        if (nexttoken.identifier && nexttoken.value === 'counter') {\n            advance();\n            advance('(');\n            advance();\n            if (nexttoken.id === ',') {\n                comma();\n                if (nexttoken.type !== '(string)') {\n                    warning(\"Expected a string and instead saw '{a}'.\",\n                        nexttoken, nexttoken.value);\n                }\n                advance();\n            }\n            advance(')');\n            return true;\n        }\n        if (nexttoken.identifier && nexttoken.value === 'counters') {\n            advance();\n            advance('(');\n            if (!nexttoken.identifier) {\n                warning(\"Expected a name and instead saw '{a}'.\",\n                        nexttoken, nexttoken.value);\n            }\n            advance();\n            if (nexttoken.id === ',') {\n                comma();\n                if (nexttoken.type !== '(string)') {\n                    warning(\"Expected a string and instead saw '{a}'.\",\n                        nexttoken, nexttoken.value);\n                }\n                advance();\n            }\n            if (nexttoken.id === ',') {\n                comma();\n                if (nexttoken.type !== '(string)') {\n                    warning(\"Expected a string and instead saw '{a}'.\",\n                        nexttoken, nexttoken.value);\n                }\n                advance();\n            }\n            advance(')');\n            return true;\n        }\n        return false;\n    }\n\n\n    function cssShape() {\n        var i;\n        if (nexttoken.identifier && nexttoken.value === 'rect') {\n            advance();\n            advance('(');\n            for (i = 0; i < 4; i += 1) {\n                if (!cssLength()) {\n                    warning(\"Expected a number and instead saw '{a}'.\",\n                        nexttoken, nexttoken.value);\n                    break;\n                }\n            }\n            advance(')');\n            return true;\n        }\n        return false;\n    }\n\n\n    function cssUrl() {\n        var c, url;\n        if (nexttoken.identifier && nexttoken.value === 'url') {\n            nexttoken = lex.range('(', ')');\n            url = nexttoken.value;\n            c = url.charAt(0);\n            if (c === '\"' || c === '\\'') {\n                if (url.slice(-1) !== c) {\n                    warning(\"Bad url string.\");\n                } else {\n                    url = url.slice(1, -1);\n                    if (url.indexOf(c) >= 0) {\n                        warning(\"Bad url string.\");\n                    }\n                }\n            }\n            if (!url) {\n                warning(\"Missing url.\");\n            }\n            advance();\n            if (option.safe && ux.test(url)) {\n                error(\"ADsafe URL violation.\");\n            }\n            urls.push(url);\n            return true;\n        }\n        return false;\n    }\n\n\n    cssAny = [cssUrl, function () {\n        for (;;) {\n            if (nexttoken.identifier) {\n                switch (nexttoken.value.toLowerCase()) {\n                case 'url':\n                    cssUrl();\n                    break;\n                case 'expression':\n                    warning(\"Unexpected expression '{a}'.\",\n                        nexttoken, nexttoken.value);\n                    advance();\n                    break;\n                default:\n                    advance();\n                }\n            } else {\n                if (nexttoken.id === ';' || nexttoken.id === '!'  ||\n                        nexttoken.id === '(end)' || nexttoken.id === '}') {\n                    return true;\n                }\n                advance();\n            }\n        }\n    }];\n\n\n    cssBorderStyle = [\n        'none', 'dashed', 'dotted', 'double', 'groove',\n        'hidden', 'inset', 'outset', 'ridge', 'solid'\n    ];\n\n    cssBreak = [\n        'auto', 'always', 'avoid', 'left', 'right'\n    ];\n\n    cssMedia = {\n        'all': true,\n        'braille': true,\n        'embossed': true,\n        'handheld': true,\n        'print': true,\n        'projection': true,\n        'screen': true,\n        'speech': true,\n        'tty': true,\n        'tv': true\n    };\n\n    cssOverflow = [\n        'auto', 'hidden', 'scroll', 'visible'\n    ];\n\n    cssAttributeData = {\n        background: [\n            true, 'background-attachment', 'background-color',\n            'background-image', 'background-position', 'background-repeat'\n        ],\n        'background-attachment': ['scroll', 'fixed'],\n        'background-color': ['transparent', cssColor],\n        'background-image': ['none', cssUrl],\n        'background-position': [\n            2, [cssLength, 'top', 'bottom', 'left', 'right', 'center']\n        ],\n        'background-repeat': [\n            'repeat', 'repeat-x', 'repeat-y', 'no-repeat'\n        ],\n        'border': [true, 'border-color', 'border-style', 'border-width'],\n        'border-bottom': [\n            true, 'border-bottom-color', 'border-bottom-style',\n            'border-bottom-width'\n        ],\n        'border-bottom-color': cssColor,\n        'border-bottom-style': cssBorderStyle,\n        'border-bottom-width': cssWidth,\n        'border-collapse': ['collapse', 'separate'],\n        'border-color': ['transparent', 4, cssColor],\n        'border-left': [\n            true, 'border-left-color', 'border-left-style', 'border-left-width'\n        ],\n        'border-left-color': cssColor,\n        'border-left-style': cssBorderStyle,\n        'border-left-width': cssWidth,\n        'border-right': [\n            true, 'border-right-color', 'border-right-style',\n            'border-right-width'\n        ],\n        'border-right-color': cssColor,\n        'border-right-style': cssBorderStyle,\n        'border-right-width': cssWidth,\n        'border-spacing': [2, cssLength],\n        'border-style': [4, cssBorderStyle],\n        'border-top': [\n            true, 'border-top-color', 'border-top-style', 'border-top-width'\n        ],\n        'border-top-color': cssColor,\n        'border-top-style': cssBorderStyle,\n        'border-top-width': cssWidth,\n        'border-width': [4, cssWidth],\n        bottom: [cssLength, 'auto'],\n        'caption-side' : ['bottom', 'left', 'right', 'top'],\n        clear: ['both', 'left', 'none', 'right'],\n        clip: [cssShape, 'auto'],\n        color: cssColor,\n        content: [\n            'open-quote', 'close-quote', 'no-open-quote', 'no-close-quote',\n            cssString, cssUrl, cssCounter, cssAttr\n        ],\n        'counter-increment': [\n            cssName, 'none'\n        ],\n        'counter-reset': [\n            cssName, 'none'\n        ],\n        cursor: [\n            cssUrl, 'auto', 'crosshair', 'default', 'e-resize', 'help', 'move',\n            'n-resize', 'ne-resize', 'nw-resize', 'pointer', 's-resize',\n            'se-resize', 'sw-resize', 'w-resize', 'text', 'wait'\n        ],\n        direction: ['ltr', 'rtl'],\n        display: [\n            'block', 'compact', 'inline', 'inline-block', 'inline-table',\n            'list-item', 'marker', 'none', 'run-in', 'table', 'table-caption',\n            'table-cell', 'table-column', 'table-column-group',\n            'table-footer-group', 'table-header-group', 'table-row',\n            'table-row-group'\n        ],\n        'empty-cells': ['show', 'hide'],\n        'float': ['left', 'none', 'right'],\n        font: [\n            'caption', 'icon', 'menu', 'message-box', 'small-caption',\n            'status-bar', true, 'font-size', 'font-style', 'font-weight',\n            'font-family'\n        ],\n        'font-family': cssCommaList,\n        'font-size': [\n            'xx-small', 'x-small', 'small', 'medium', 'large', 'x-large',\n            'xx-large', 'larger', 'smaller', cssLength\n        ],\n        'font-size-adjust': ['none', cssNumber],\n        'font-stretch': [\n            'normal', 'wider', 'narrower', 'ultra-condensed',\n            'extra-condensed', 'condensed', 'semi-condensed',\n            'semi-expanded', 'expanded', 'extra-expanded'\n        ],\n        'font-style': [\n            'normal', 'italic', 'oblique'\n        ],\n        'font-variant': [\n            'normal', 'small-caps'\n        ],\n        'font-weight': [\n            'normal', 'bold', 'bolder', 'lighter', cssNumber\n        ],\n        height: [cssLength, 'auto'],\n        left: [cssLength, 'auto'],\n        'letter-spacing': ['normal', cssLength],\n        'line-height': ['normal', cssLineHeight],\n        'list-style': [\n            true, 'list-style-image', 'list-style-position', 'list-style-type'\n        ],\n        'list-style-image': ['none', cssUrl],\n        'list-style-position': ['inside', 'outside'],\n        'list-style-type': [\n            'circle', 'disc', 'square', 'decimal', 'decimal-leading-zero',\n            'lower-roman', 'upper-roman', 'lower-greek', 'lower-alpha',\n            'lower-latin', 'upper-alpha', 'upper-latin', 'hebrew', 'katakana',\n            'hiragana-iroha', 'katakana-oroha', 'none'\n        ],\n        margin: [4, cssMargin],\n        'margin-bottom': cssMargin,\n        'margin-left': cssMargin,\n        'margin-right': cssMargin,\n        'margin-top': cssMargin,\n        'marker-offset': [cssLength, 'auto'],\n        'max-height': [cssLength, 'none'],\n        'max-width': [cssLength, 'none'],\n        'min-height': cssLength,\n        'min-width': cssLength,\n        opacity: cssNumber,\n        outline: [true, 'outline-color', 'outline-style', 'outline-width'],\n        'outline-color': ['invert', cssColor],\n        'outline-style': [\n            'dashed', 'dotted', 'double', 'groove', 'inset', 'none',\n            'outset', 'ridge', 'solid'\n        ],\n        'outline-width': cssWidth,\n        overflow: cssOverflow,\n        'overflow-x': cssOverflow,\n        'overflow-y': cssOverflow,\n        padding: [4, cssLength],\n        'padding-bottom': cssLength,\n        'padding-left': cssLength,\n        'padding-right': cssLength,\n        'padding-top': cssLength,\n        'page-break-after': cssBreak,\n        'page-break-before': cssBreak,\n        position: ['absolute', 'fixed', 'relative', 'static'],\n        quotes: [8, cssString],\n        right: [cssLength, 'auto'],\n        'table-layout': ['auto', 'fixed'],\n        'text-align': ['center', 'justify', 'left', 'right'],\n        'text-decoration': [\n            'none', 'underline', 'overline', 'line-through', 'blink'\n        ],\n        'text-indent': cssLength,\n        'text-shadow': ['none', 4, [cssColor, cssLength]],\n        'text-transform': ['capitalize', 'uppercase', 'lowercase', 'none'],\n        top: [cssLength, 'auto'],\n        'unicode-bidi': ['normal', 'embed', 'bidi-override'],\n        'vertical-align': [\n            'baseline', 'bottom', 'sub', 'super', 'top', 'text-top', 'middle',\n            'text-bottom', cssLength\n        ],\n        visibility: ['visible', 'hidden', 'collapse'],\n        'white-space': [\n            'normal', 'nowrap', 'pre', 'pre-line', 'pre-wrap', 'inherit'\n        ],\n        width: [cssLength, 'auto'],\n        'word-spacing': ['normal', cssLength],\n        'word-wrap': ['break-word', 'normal'],\n        'z-index': ['auto', cssNumber]\n    };\n\n    function styleAttribute() {\n        var v;\n        while (nexttoken.id === '*' || nexttoken.id === '#' ||\n                nexttoken.value === '_') {\n            if (!option.css) {\n                warning(\"Unexpected '{a}'.\", nexttoken, nexttoken.value);\n            }\n            advance();\n        }\n        if (nexttoken.id === '-') {\n            if (!option.css) {\n                warning(\"Unexpected '{a}'.\", nexttoken, nexttoken.value);\n            }\n            advance('-');\n            if (!nexttoken.identifier) {\n                warning(\n\"Expected a non-standard style attribute and instead saw '{a}'.\",\n                    nexttoken, nexttoken.value);\n            }\n            advance();\n            return cssAny;\n        } else {\n            if (!nexttoken.identifier) {\n                warning(\"Excepted a style attribute, and instead saw '{a}'.\",\n                    nexttoken, nexttoken.value);\n            } else {\n                if (is_own(cssAttributeData, nexttoken.value)) {\n                    v = cssAttributeData[nexttoken.value];\n                } else {\n                    v = cssAny;\n                    if (!option.css) {\n                        warning(\"Unrecognized style attribute '{a}'.\",\n                                nexttoken, nexttoken.value);\n                    }\n                }\n            }\n            advance();\n            return v;\n        }\n    }\n\n\n    function styleValue(v) {\n        var i = 0,\n            n,\n            once,\n            match,\n            round,\n            start = 0,\n            vi;\n        switch (typeof v) {\n        case 'function':\n            return v();\n        case 'string':\n            if (nexttoken.identifier && nexttoken.value === v) {\n                advance();\n                return true;\n            }\n            return false;\n        }\n        for (;;) {\n            if (i >= v.length) {\n                return false;\n            }\n            vi = v[i];\n            i += 1;\n            if (vi === true) {\n                break;\n            } else if (typeof vi === 'number') {\n                n = vi;\n                vi = v[i];\n                i += 1;\n            } else {\n                n = 1;\n            }\n            match = false;\n            while (n > 0) {\n                if (styleValue(vi)) {\n                    match = true;\n                    n -= 1;\n                } else {\n                    break;\n                }\n            }\n            if (match) {\n                return true;\n            }\n        }\n        start = i;\n        once = [];\n        for (;;) {\n            round = false;\n            for (i = start; i < v.length; i += 1) {\n                if (!once[i]) {\n                    if (styleValue(cssAttributeData[v[i]])) {\n                        match = true;\n                        round = true;\n                        once[i] = true;\n                        break;\n                    }\n                }\n            }\n            if (!round) {\n                return match;\n            }\n        }\n    }\n\n    function styleChild() {\n        if (nexttoken.id === '(number)') {\n            advance();\n            if (nexttoken.value === 'n' && nexttoken.identifier) {\n                adjacent();\n                advance();\n                if (nexttoken.id === '+') {\n                    adjacent();\n                    advance('+');\n                    adjacent();\n                    advance('(number)');\n                }\n            }\n            return;\n        } else {\n            switch (nexttoken.value) {\n            case 'odd':\n            case 'even':\n                if (nexttoken.identifier) {\n                    advance();\n                    return;\n                }\n            }\n        }\n        warning(\"Unexpected token '{a}'.\", nexttoken, nexttoken.value);\n    }\n\n    function substyle() {\n        var v;\n        for (;;) {\n            if (nexttoken.id === '}' || nexttoken.id === '(end)' ||\n                    xquote && nexttoken.id === xquote) {\n                return;\n            }\n            while (nexttoken.id === ';') {\n                warning(\"Misplaced ';'.\");\n                advance(';');\n            }\n            v = styleAttribute();\n            advance(':');\n            if (nexttoken.identifier && nexttoken.value === 'inherit') {\n                advance();\n            } else {\n                if (!styleValue(v)) {\n                    warning(\"Unexpected token '{a}'.\", nexttoken,\n                        nexttoken.value);\n                    advance();\n                }\n            }\n            if (nexttoken.id === '!') {\n                advance('!');\n                adjacent();\n                if (nexttoken.identifier && nexttoken.value === 'important') {\n                    advance();\n                } else {\n                    warning(\"Expected '{a}' and instead saw '{b}'.\",\n                        nexttoken, 'important', nexttoken.value);\n                }\n            }\n            if (nexttoken.id === '}' || nexttoken.id === xquote) {\n                warning(\"Missing '{a}'.\", nexttoken, ';');\n            } else {\n                advance(';');\n            }\n        }\n    }\n\n    function styleSelector() {\n        if (nexttoken.identifier) {\n            if (!is_own(htmltag, option.cap ?\n                    nexttoken.value.toLowerCase() : nexttoken.value)) {\n                warning(\"Expected a tagName, and instead saw {a}.\",\n                    nexttoken, nexttoken.value);\n            }\n            advance();\n        } else {\n            switch (nexttoken.id) {\n            case '>':\n            case '+':\n                advance();\n                styleSelector();\n                break;\n            case ':':\n                advance(':');\n                switch (nexttoken.value) {\n                case 'active':\n                case 'after':\n                case 'before':\n                case 'checked':\n                case 'disabled':\n                case 'empty':\n                case 'enabled':\n                case 'first-child':\n                case 'first-letter':\n                case 'first-line':\n                case 'first-of-type':\n                case 'focus':\n                case 'hover':\n                case 'last-child':\n                case 'last-of-type':\n                case 'link':\n                case 'only-of-type':\n                case 'root':\n                case 'target':\n                case 'visited':\n                    advance();\n                    break;\n                case 'lang':\n                    advance();\n                    advance('(');\n                    if (!nexttoken.identifier) {\n                        warning(\"Expected a lang code, and instead saw :{a}.\",\n                            nexttoken, nexttoken.value);\n                    }\n                    advance(')');\n                    break;\n                case 'nth-child':\n                case 'nth-last-child':\n                case 'nth-last-of-type':\n                case 'nth-of-type':\n                    advance();\n                    advance('(');\n                    styleChild();\n                    advance(')');\n                    break;\n                case 'not':\n                    advance();\n                    advance('(');\n                    if (nexttoken.id === ':' && peek(0).value === 'not') {\n                        warning(\"Nested not.\");\n                    }\n                    styleSelector();\n                    advance(')');\n                    break;\n                default:\n                    warning(\"Expected a pseudo, and instead saw :{a}.\",\n                        nexttoken, nexttoken.value);\n                }\n                break;\n            case '#':\n                advance('#');\n                if (!nexttoken.identifier) {\n                    warning(\"Expected an id, and instead saw #{a}.\",\n                        nexttoken, nexttoken.value);\n                }\n                advance();\n                break;\n            case '*':\n                advance('*');\n                break;\n            case '.':\n                advance('.');\n                if (!nexttoken.identifier) {\n                    warning(\"Expected a class, and instead saw #.{a}.\",\n                        nexttoken, nexttoken.value);\n                }\n                advance();\n                break;\n            case '[':\n                advance('[');\n                if (!nexttoken.identifier) {\n                    warning(\"Expected an attribute, and instead saw [{a}].\",\n                        nexttoken, nexttoken.value);\n                }\n                advance();\n                if (nexttoken.id === '=' || nexttoken.value === '~=' ||\n                        nexttoken.value === '$=' ||\n                        nexttoken.value === '|=' ||\n                        nexttoken.id === '*=' ||\n                        nexttoken.id === '^=') {\n                    advance();\n                    if (nexttoken.type !== '(string)') {\n                        warning(\"Expected a string, and instead saw {a}.\",\n                            nexttoken, nexttoken.value);\n                    }\n                    advance();\n                }\n                advance(']');\n                break;\n            default:\n                error(\"Expected a CSS selector, and instead saw {a}.\",\n                    nexttoken, nexttoken.value);\n            }\n        }\n    }\n\n    function stylePattern() {\n        if (nexttoken.id === '{') {\n            warning(\"Expected a style pattern, and instead saw '{a}'.\", nexttoken,\n                nexttoken.id);\n        }\n        for (;;) {\n            styleSelector();\n            if (nexttoken.id === '</' || nexttoken.id === '{' ||\n                    nexttoken.id === '(end)') {\n                return '';\n            }\n            if (nexttoken.id === ',') {\n                comma();\n            }\n        }\n    }\n\n    function stylelist() {\n        while (nexttoken.id !== '</' && nexttoken.id !== '(end)') {\n            stylePattern();\n            xmode = 'styleproperty';\n            if (nexttoken.id === ';') {\n                advance(';');\n            } else {\n                advance('{');\n                substyle();\n                xmode = 'style';\n                advance('}');\n            }\n        }\n    }\n\n    function styles() {\n        var i;\n        while (nexttoken.id === '@') {\n            i = peek();\n            advance('@');\n            if (nexttoken.identifier) {\n                switch (nexttoken.value) {\n                case 'import':\n                    advance();\n                    if (!cssUrl()) {\n                        warning(\"Expected '{a}' and instead saw '{b}'.\",\n                            nexttoken, 'url', nexttoken.value);\n                        advance();\n                    }\n                    advance(';');\n                    break;\n                case 'media':\n                    advance();\n                    for (;;) {\n                        if (!nexttoken.identifier || cssMedia[nexttoken.value] === true) {\n                            error(\"Expected a CSS media type, and instead saw '{a}'.\", nexttoken, nexttoken.id);\n                        }\n                        advance();\n                        if (nexttoken.id !== ',') {\n                            break;\n                        }\n                        advance(',');\n                    }\n                    advance('{');\n                    stylelist();\n                    advance('}');\n                    break;\n                default:\n                    warning(\"Expected an at-rule, and instead saw @{a}.\",\n                        nexttoken, nexttoken.value);\n                }\n            } else {\n                warning(\"Expected an at-rule, and instead saw '{a}'.\",\n                    nexttoken, nexttoken.value);\n            }\n        }\n        stylelist();\n    }\n\n\n// HTML parsing.\n\n    function doBegin(n) {\n        if (n !== 'html' && !option.fragment) {\n            if (n === 'div' && option.adsafe) {\n                error(\"ADSAFE: Use the fragment option.\");\n            } else {\n                error(\"Expected '{a}' and instead saw '{b}'.\",\n                    token, 'html', n);\n            }\n        }\n        if (option.adsafe) {\n            if (n === 'html') {\n                error(\n\"Currently, ADsafe does not operate on whole HTML documents. It operates on <div> fragments and .js files.\", token);\n            }\n            if (option.fragment) {\n                if (n !== 'div') {\n                    error(\"ADsafe violation: Wrap the widget in a div.\", token);\n                }\n            } else {\n                error(\"Use the fragment option.\", token);\n            }\n        }\n        option.browser = true;\n        assume();\n    }\n\n    function doAttribute(n, a, v) {\n        var u, x;\n        if (a === 'id') {\n            u = typeof v === 'string' ? v.toUpperCase() : '';\n            if (ids[u] === true) {\n                warning(\"Duplicate id='{a}'.\", nexttoken, v);\n            }\n            if (!/^[A-Za-z][A-Za-z0-9._:\\-]*$/.test(v)) {\n                warning(\"Bad id: '{a}'.\", nexttoken, v);\n            } else if (option.adsafe) {\n                if (adsafe_id) {\n                    if (v.slice(0, adsafe_id.length) !== adsafe_id) {\n                        warning(\"ADsafe violation: An id must have a '{a}' prefix\",\n                                nexttoken, adsafe_id);\n                    } else if (!/^[A-Z]+_[A-Z]+$/.test(v)) {\n                        warning(\"ADSAFE violation: bad id.\");\n                    }\n                } else {\n                    adsafe_id = v;\n                    if (!/^[A-Z]+_$/.test(v)) {\n                        warning(\"ADSAFE violation: bad id.\");\n                    }\n                }\n            }\n            x = v.search(dx);\n            if (x >= 0) {\n                warning(\"Unexpected character '{a}' in {b}.\", token, v.charAt(x), a);\n            }\n            ids[u] = true;\n        } else if (a === 'class' || a === 'type' || a === 'name') {\n            x = v.search(qx);\n            if (x >= 0) {\n                warning(\"Unexpected character '{a}' in {b}.\", token, v.charAt(x), a);\n            }\n            ids[u] = true;\n        } else if (a === 'href' || a === 'background' ||\n                a === 'content' || a === 'data' ||\n                a.indexOf('src') >= 0 || a.indexOf('url') >= 0) {\n            if (option.safe && ux.test(v)) {\n                error(\"ADsafe URL violation.\");\n            }\n            urls.push(v);\n        } else if (a === 'for') {\n            if (option.adsafe) {\n                if (adsafe_id) {\n                    if (v.slice(0, adsafe_id.length) !== adsafe_id) {\n                        warning(\"ADsafe violation: An id must have a '{a}' prefix\",\n                                nexttoken, adsafe_id);\n                    } else if (!/^[A-Z]+_[A-Z]+$/.test(v)) {\n                        warning(\"ADSAFE violation: bad id.\");\n                    }\n                } else {\n                    warning(\"ADSAFE violation: bad id.\");\n                }\n            }\n        } else if (a === 'name') {\n            if (option.adsafe && v.indexOf('_') >= 0) {\n                warning(\"ADsafe name violation.\");\n            }\n        }\n    }\n\n    function doTag(n, a) {\n        var i, t = htmltag[n], x;\n        src = false;\n        if (!t) {\n            error(\"Unrecognized tag '<{a}>'.\",\n                    nexttoken,\n                    n === n.toLowerCase() ? n :\n                        n + ' (capitalization error)');\n        }\n        if (stack.length > 0) {\n            if (n === 'html') {\n                error(\"Too many <html> tags.\", token);\n            }\n            x = t.parent;\n            if (x) {\n                if (x.indexOf(' ' + stack[stack.length - 1].name + ' ') < 0) {\n                    error(\"A '<{a}>' must be within '<{b}>'.\",\n                            token, n, x);\n                }\n            } else if (!option.adsafe && !option.fragment) {\n                i = stack.length;\n                do {\n                    if (i <= 0) {\n                        error(\"A '<{a}>' must be within '<{b}>'.\",\n                                token, n, 'body');\n                    }\n                    i -= 1;\n                } while (stack[i].name !== 'body');\n            }\n        }\n        switch (n) {\n        case 'div':\n            if (option.adsafe && stack.length === 1 && !adsafe_id) {\n                warning(\"ADSAFE violation: missing ID_.\");\n            }\n            break;\n        case 'script':\n            xmode = 'script';\n            advance('>');\n            indent = nexttoken.from;\n            if (a.lang) {\n                warning(\"lang is deprecated.\", token);\n            }\n            if (option.adsafe && stack.length !== 1) {\n                warning(\"ADsafe script placement violation.\", token);\n            }\n            if (a.src) {\n                if (option.adsafe && (!adsafe_may || !approved[a.src])) {\n                    warning(\"ADsafe unapproved script source.\", token);\n                }\n                if (a.type) {\n                    warning(\"type is unnecessary.\", token);\n                }\n            } else {\n                if (adsafe_went) {\n                    error(\"ADsafe script violation.\", token);\n                }\n                statements('script');\n            }\n            xmode = 'html';\n            advance('</');\n            if (!nexttoken.identifier && nexttoken.value !== 'script') {\n                warning(\"Expected '{a}' and instead saw '{b}'.\",\n                        nexttoken, 'script', nexttoken.value);\n            }\n            advance();\n            xmode = 'outer';\n            break;\n        case 'style':\n            xmode = 'style';\n            advance('>');\n            styles();\n            xmode = 'html';\n            advance('</');\n            if (!nexttoken.identifier && nexttoken.value !== 'style') {\n                warning(\"Expected '{a}' and instead saw '{b}'.\",\n                        nexttoken, 'style', nexttoken.value);\n            }\n            advance();\n            xmode = 'outer';\n            break;\n        case 'input':\n            switch (a.type) {\n            case 'radio':\n            case 'checkbox':\n            case 'button':\n            case 'reset':\n            case 'submit':\n                break;\n            case 'text':\n            case 'file':\n            case 'password':\n            case 'file':\n            case 'hidden':\n            case 'image':\n                if (option.adsafe && a.autocomplete !== 'off') {\n                    warning(\"ADsafe autocomplete violation.\");\n                }\n                break;\n            default:\n                warning(\"Bad input type.\");\n            }\n            break;\n        case 'applet':\n        case 'body':\n        case 'embed':\n        case 'frame':\n        case 'frameset':\n        case 'head':\n        case 'iframe':\n        case 'noembed':\n        case 'noframes':\n        case 'object':\n        case 'param':\n            if (option.adsafe) {\n                warning(\"ADsafe violation: Disallowed tag: \" + n);\n            }\n            break;\n        }\n    }\n\n\n    function closetag(n) {\n        return '</' + n + '>';\n    }\n\n    function html() {\n        var a, attributes, e, n, q, t, v, w = option.white, wmode;\n        xmode = 'html';\n        xquote = '';\n        stack = null;\n        for (;;) {\n            switch (nexttoken.value) {\n            case '<':\n                xmode = 'html';\n                advance('<');\n                attributes = {};\n                t = nexttoken;\n                if (!t.identifier) {\n                    warning(\"Bad identifier {a}.\", t, t.value);\n                }\n                n = t.value;\n                if (option.cap) {\n                    n = n.toLowerCase();\n                }\n                t.name = n;\n                advance();\n                if (!stack) {\n                    stack = [];\n                    doBegin(n);\n                }\n                v = htmltag[n];\n                if (typeof v !== 'object') {\n                    error(\"Unrecognized tag '<{a}>'.\", t, n);\n                }\n                e = v.empty;\n                t.type = n;\n                for (;;) {\n                    if (nexttoken.id === '/') {\n                        advance('/');\n                        if (nexttoken.id !== '>') {\n                            warning(\"Expected '{a}' and instead saw '{b}'.\",\n                                    nexttoken, '>', nexttoken.value);\n                        }\n                        break;\n                    }\n                    if (nexttoken.id && nexttoken.id.substr(0, 1) === '>') {\n                        break;\n                    }\n                    if (!nexttoken.identifier) {\n                        if (nexttoken.id === '(end)' || nexttoken.id === '(error)') {\n                            error(\"Missing '>'.\", nexttoken);\n                        }\n                        warning(\"Bad identifier.\");\n                    }\n                    option.white = true;\n                    nonadjacent(token, nexttoken);\n                    a = nexttoken.value;\n                    option.white = w;\n                    advance();\n                    if (!option.cap && a !== a.toLowerCase()) {\n                        warning(\"Attribute '{a}' not all lower case.\", nexttoken, a);\n                    }\n                    a = a.toLowerCase();\n                    xquote = '';\n                    if (is_own(attributes, a)) {\n                        warning(\"Attribute '{a}' repeated.\", nexttoken, a);\n                    }\n                    if (a.slice(0, 2) === 'on') {\n                        if (!option.on) {\n                            warning(\"Avoid HTML event handlers.\");\n                        }\n                        xmode = 'scriptstring';\n                        advance('=');\n                        q = nexttoken.id;\n                        if (q !== '\"' && q !== \"'\") {\n                            error(\"Missing quote.\");\n                        }\n                        xquote = q;\n                        wmode = option.white;\n                        option.white = false;\n                        advance(q);\n                        statements('on');\n                        option.white = wmode;\n                        if (nexttoken.id !== q) {\n                            error(\"Missing close quote on script attribute.\");\n                        }\n                        xmode = 'html';\n                        xquote = '';\n                        advance(q);\n                        v = false;\n                    } else if (a === 'style') {\n                        xmode = 'scriptstring';\n                        advance('=');\n                        q = nexttoken.id;\n                        if (q !== '\"' && q !== \"'\") {\n                            error(\"Missing quote.\");\n                        }\n                        xmode = 'styleproperty';\n                        xquote = q;\n                        advance(q);\n                        substyle();\n                        xmode = 'html';\n                        xquote = '';\n                        advance(q);\n                        v = false;\n                    } else {\n                        if (nexttoken.id === '=') {\n                            advance('=');\n                            v = nexttoken.value;\n                            if (!nexttoken.identifier &&\n                                    nexttoken.id !== '\"' &&\n                                    nexttoken.id !== '\\'' &&\n                                    nexttoken.type !== '(string)' &&\n                                    nexttoken.type !== '(number)' &&\n                                    nexttoken.type !== '(color)') {\n                                warning(\"Expected an attribute value and instead saw '{a}'.\", token, a);\n                            }\n                            advance();\n                        } else {\n                            v = true;\n                        }\n                    }\n                    attributes[a] = v;\n                    doAttribute(n, a, v);\n                }\n                doTag(n, attributes);\n                if (!e) {\n                    stack.push(t);\n                }\n                xmode = 'outer';\n                advance('>');\n                break;\n            case '</':\n                xmode = 'html';\n                advance('</');\n                if (!nexttoken.identifier) {\n                    warning(\"Bad identifier.\");\n                }\n                n = nexttoken.value;\n                if (option.cap) {\n                    n = n.toLowerCase();\n                }\n                advance();\n                if (!stack) {\n                    error(\"Unexpected '{a}'.\", nexttoken, closetag(n));\n                }\n                t = stack.pop();\n                if (!t) {\n                    error(\"Unexpected '{a}'.\", nexttoken, closetag(n));\n                }\n                if (t.name !== n) {\n                    error(\"Expected '{a}' and instead saw '{b}'.\",\n                            nexttoken, closetag(t.name), closetag(n));\n                }\n                if (nexttoken.id !== '>') {\n                    error(\"Missing '{a}'.\", nexttoken, '>');\n                }\n                xmode = 'outer';\n                advance('>');\n                break;\n            case '<!':\n                if (option.safe) {\n                    warning(\"ADsafe HTML violation.\");\n                }\n                xmode = 'html';\n                for (;;) {\n                    advance();\n                    if (nexttoken.id === '>' || nexttoken.id === '(end)') {\n                        break;\n                    }\n                    if (nexttoken.value.indexOf('--') >= 0) {\n                        error(\"Unexpected --.\");\n                    }\n                    if (nexttoken.value.indexOf('<') >= 0) {\n                        error(\"Unexpected <.\");\n                    }\n                    if (nexttoken.value.indexOf('>') >= 0) {\n                        error(\"Unexpected >.\");\n                    }\n                }\n                xmode = 'outer';\n                advance('>');\n                break;\n            case '(end)':\n                return;\n            default:\n                if (nexttoken.id === '(end)') {\n                    error(\"Missing '{a}'.\", nexttoken,\n                            '</' + stack[stack.length - 1].value + '>');\n                } else {\n                    advance();\n                }\n            }\n            if (stack && stack.length === 0 && (option.adsafe ||\n                    !option.fragment || nexttoken.id === '(end)')) {\n                break;\n            }\n        }\n        if (nexttoken.id !== '(end)') {\n            error(\"Unexpected material after the end.\");\n        }\n    }\n\n\n// Build the syntax table by declaring the syntactic elements of the language.\n\n    type('(number)', function () {\n        return this;\n    });\n    type('(string)', function () {\n        return this;\n    });\n\n    syntax['(identifier)'] = {\n        type: '(identifier)',\n        lbp: 0,\n        identifier: true,\n        nud: function () {\n            var v = this.value,\n                s = scope[v],\n                f;\n            if (typeof s === 'function') {\n\n// Protection against accidental inheritance.\n\n                s = undefined;\n            } else if (typeof s === 'boolean') {\n                f = funct;\n                funct = functions[0];\n                addlabel(v, 'var');\n                s = funct;\n                funct = f;\n            }\n\n// The name is in scope and defined in the current function.\n\n            if (funct === s) {\n\n//      Change 'unused' to 'var', and reject labels.\n\n                switch (funct[v]) {\n                case 'unused':\n                    funct[v] = 'var';\n                    break;\n                case 'unction':\n                    funct[v] = 'function';\n                    this['function'] = true;\n                    break;\n                case 'function':\n                    this['function'] = true;\n                    break;\n                case 'label':\n                    warning(\"'{a}' is a statement label.\", token, v);\n                    break;\n                }\n\n// The name is not defined in the function.  If we are in the global scope,\n// then we have an undefined variable.\n\n            } else if (funct['(global)']) {\n                if (option.undef && predefined[v] !== 'boolean') {\n                    warning(\"'{a}' is not defined.\", token, v);\n                }\n                note_implied(token);\n\n// If the name is already defined in the current\n// function, but not as outer, then there is a scope error.\n\n            } else {\n                switch (funct[v]) {\n                case 'closure':\n                case 'function':\n                case 'var':\n                case 'unused':\n                    warning(\"'{a}' used out of scope.\", token, v);\n                    break;\n                case 'label':\n                    warning(\"'{a}' is a statement label.\", token, v);\n                    break;\n                case 'outer':\n                case 'global':\n                    break;\n                default:\n\n// If the name is defined in an outer function, make an outer entry, and if\n// it was unused, make it var.\n\n                    if (s === true) {\n                        funct[v] = true;\n                    } else if (s === null) {\n                        warning(\"'{a}' is not allowed.\", token, v);\n                        note_implied(token);\n                    } else if (typeof s !== 'object') {\n                        if (option.undef) {\n                            warning(\"'{a}' is not defined.\", token, v);\n                        } else {\n                            funct[v] = true;\n                        }\n                        note_implied(token);\n                    } else {\n                        switch (s[v]) {\n                        case 'function':\n                        case 'unction':\n                            this['function'] = true;\n                            s[v] = 'closure';\n                            funct[v] = s['(global)'] ? 'global' : 'outer';\n                            break;\n                        case 'var':\n                        case 'unused':\n                            s[v] = 'closure';\n                            funct[v] = s['(global)'] ? 'global' : 'outer';\n                            break;\n                        case 'closure':\n                        case 'parameter':\n                            funct[v] = s['(global)'] ? 'global' : 'outer';\n                            break;\n                        case 'label':\n                            warning(\"'{a}' is a statement label.\", token, v);\n                        }\n                    }\n                }\n            }\n            return this;\n        },\n        led: function () {\n            error(\"Expected an operator and instead saw '{a}'.\",\n                nexttoken, nexttoken.value);\n        }\n    };\n\n    type('(regexp)', function () {\n        return this;\n    });\n\n\n// ECMAScript parser\n\n    delim('(endline)');\n    delim('(begin)');\n    delim('(end)').reach = true;\n    delim('</').reach = true;\n    delim('<!');\n    delim('<!--');\n    delim('--\>');\n    delim('(error)').reach = true;\n    delim('}').reach = true;\n    delim(')');\n    delim(']');\n    delim('\"').reach = true;\n    delim(\"'\").reach = true;\n    delim(';');\n    delim(':').reach = true;\n    delim(',');\n    delim('#');\n    delim('@');\n    reserve('else');\n    reserve('case').reach = true;\n    reserve('catch');\n    reserve('default').reach = true;\n    reserve('finally');\n    reservevar('arguments', function (x) {\n        if (strict_mode && funct['(global)']) {\n            warning(\"Strict violation.\", x);\n        } else if (option.safe) {\n            warning(\"ADsafe violation.\", x);\n        }\n    });\n    reservevar('eval', function (x) {\n        if (option.safe) {\n            warning(\"ADsafe violation.\", x);\n        }\n    });\n    reservevar('false');\n    reservevar('Infinity');\n    reservevar('NaN');\n    reservevar('null');\n    reservevar('this', function (x) {\n        if (strict_mode && ((funct['(statement)'] &&\n                funct['(name)'].charAt(0) > 'Z') || funct['(global)'])) {\n            warning(\"Strict violation.\", x);\n        } else if (option.safe) {\n            warning(\"ADsafe violation.\", x);\n        }\n    });\n    reservevar('true');\n    reservevar('undefined');\n    assignop('=', 'assign', 20);\n    assignop('+=', 'assignadd', 20);\n    assignop('-=', 'assignsub', 20);\n    assignop('*=', 'assignmult', 20);\n    assignop('/=', 'assigndiv', 20).nud = function () {\n        error(\"A regular expression literal can be confused with '/='.\");\n    };\n    assignop('%=', 'assignmod', 20);\n    bitwiseassignop('&=', 'assignbitand', 20);\n    bitwiseassignop('|=', 'assignbitor', 20);\n    bitwiseassignop('^=', 'assignbitxor', 20);\n    bitwiseassignop('<<=', 'assignshiftleft', 20);\n    bitwiseassignop('>>=', 'assignshiftright', 20);\n    bitwiseassignop('>>>=', 'assignshiftrightunsigned', 20);\n    infix('?', function (left, that) {\n        that.left = left;\n        that.right = parse(10);\n        advance(':');\n        that['else'] = parse(10);\n        return that;\n    }, 30);\n\n    infix('||', 'or', 40);\n    infix('&&', 'and', 50);\n    bitwise('|', 'bitor', 70);\n    bitwise('^', 'bitxor', 80);\n    bitwise('&', 'bitand', 90);\n    relation('==', function (left, right) {\n        if (option.eqeqeq) {\n            warning(\"Expected '{a}' and instead saw '{b}'.\",\n                    this, '===', '==');\n        } else if (isPoorRelation(left)) {\n            warning(\"Use '{a}' to compare with '{b}'.\",\n                this, '===', left.value);\n        } else if (isPoorRelation(right)) {\n            warning(\"Use '{a}' to compare with '{b}'.\",\n                this, '===', right.value);\n        }\n        return this;\n    });\n    relation('===');\n    relation('!=', function (left, right) {\n        if (option.eqeqeq) {\n            warning(\"Expected '{a}' and instead saw '{b}'.\",\n                    this, '!==', '!=');\n        } else if (isPoorRelation(left)) {\n            warning(\"Use '{a}' to compare with '{b}'.\",\n                    this, '!==', left.value);\n        } else if (isPoorRelation(right)) {\n            warning(\"Use '{a}' to compare with '{b}'.\",\n                    this, '!==', right.value);\n        }\n        return this;\n    });\n    relation('!==');\n    relation('<');\n    relation('>');\n    relation('<=');\n    relation('>=');\n    bitwise('<<', 'shiftleft', 120);\n    bitwise('>>', 'shiftright', 120);\n    bitwise('>>>', 'shiftrightunsigned', 120);\n    infix('in', 'in', 120);\n    infix('instanceof', 'instanceof', 120);\n    infix('+', function (left, that) {\n        var right = parse(130);\n        if (left && right && left.id === '(string)' && right.id === '(string)') {\n            left.value += right.value;\n            left.character = right.character;\n            if (jx.test(left.value)) {\n                warning(\"JavaScript URL.\", left);\n            }\n            return left;\n        }\n        that.left = left;\n        that.right = right;\n        return that;\n    }, 130);\n    prefix('+', 'num');\n    prefix('+++', function () {\n        warning(\"Confusing pluses.\");\n        this.right = parse(150);\n        this.arity = 'unary';\n        return this;\n    });\n    infix('+++', function (left) {\n        warning(\"Confusing pluses.\");\n        this.left = left;\n        this.right = parse(130);\n        return this;\n    }, 130);\n    infix('-', 'sub', 130);\n    prefix('-', 'neg');\n    prefix('---', function () {\n        warning(\"Confusing minuses.\");\n        this.right = parse(150);\n        this.arity = 'unary';\n        return this;\n    });\n    infix('---', function (left) {\n        warning(\"Confusing minuses.\");\n        this.left = left;\n        this.right = parse(130);\n        return this;\n    }, 130);\n    infix('*', 'mult', 140);\n    infix('/', 'div', 140);\n    infix('%', 'mod', 140);\n\n    suffix('++', 'postinc');\n    prefix('++', 'preinc');\n    syntax['++'].exps = true;\n\n    suffix('--', 'postdec');\n    prefix('--', 'predec');\n    syntax['--'].exps = true;\n    prefix('delete', function () {\n        var p = parse(0);\n        if (!p || (p.id !== '.' && p.id !== '[')) {\n            warning(\"Variables should not be deleted.\");\n        }\n        this.first = p;\n        return this;\n    }).exps = true;\n\n\n    prefix('~', function () {\n        if (option.bitwise) {\n            warning(\"Unexpected '{a}'.\", this, '~');\n        }\n        parse(150);\n        return this;\n    });\n    prefix('!', function () {\n        this.right = parse(150);\n        this.arity = 'unary';\n        if (bang[this.right.id] === true) {\n            warning(\"Confusing use of '{a}'.\", this, '!');\n        }\n        return this;\n    });\n    prefix('typeof', 'typeof');\n    prefix('new', function () {\n        var c = parse(155), i;\n        if (c && c.id !== 'function') {\n            if (c.identifier) {\n                c['new'] = true;\n                switch (c.value) {\n                case 'Object':\n                    warning(\"Use the object literal notation {}.\", token);\n                    break;\n                case 'Array':\n                    if (nexttoken.id !== '(') {\n                        warning(\"Use the array literal notation [].\", token);\n                    } else {\n                        advance('(');\n                        if (nexttoken.id === ')') {\n                            warning(\"Use the array literal notation [].\", token);\n                        } else {\n                            i = parse(0);\n                            c.dimension = i;\n                            if ((i.id === '(number)' && /[.+\\-Ee]/.test(i.value)) ||\n                                    (i.id === '-' && !i.right) ||\n                                    i.id === '(string)' || i.id === '[' ||\n                                    i.id === '{' || i.id === 'true' ||\n                                    i.id === 'false' ||\n                                    i.id === 'null' || i.id === 'undefined' ||\n                                    i.id === 'Infinity') {\n                                warning(\"Use the array literal notation [].\", token);\n                            }\n                            if (nexttoken.id !== ')') {\n                                error(\"Use the array literal notation [].\", token);\n                            }\n                        }\n                        advance(')');\n                    }\n                    this.first = c;\n                    return this;\n                case 'Number':\n                case 'String':\n                case 'Boolean':\n                case 'Math':\n                case 'JSON':\n                    warning(\"Do not use {a} as a constructor.\", token, c.value);\n                    break;\n                case 'Function':\n                    if (!option.evil) {\n                        warning(\"The Function constructor is eval.\");\n                    }\n                    break;\n                case 'Date':\n                case 'RegExp':\n                    break;\n                default:\n                    if (c.id !== 'function') {\n                        i = c.value.substr(0, 1);\n                        if (option.newcap && (i < 'A' || i > 'Z')) {\n                            warning(\n                    \"A constructor name should start with an uppercase letter.\",\n                                token);\n                        }\n                    }\n                }\n            } else {\n                if (c.id !== '.' && c.id !== '[' && c.id !== '(') {\n                    warning(\"Bad constructor.\", token);\n                }\n            }\n        } else {\n            warning(\"Weird construction. Delete 'new'.\", this);\n        }\n        adjacent(token, nexttoken);\n        if (nexttoken.id !== '(') {\n            warning(\"Missing '()' invoking a constructor.\");\n        }\n        this.first = c;\n        return this;\n    });\n    syntax['new'].exps = true;\n\n    infix('.', function (left, that) {\n        adjacent(prevtoken, token);\n        nobreak();\n        var m = identifier();\n        if (typeof m === 'string') {\n            countMember(m);\n        }\n        that.left = left;\n        that.right = m;\n        if (left && left.value === 'arguments' &&\n                (m === 'callee' || m === 'caller')) {\n            warning(\"Avoid arguments.{a}.\", left, m);\n        } else if (!option.evil && left && left.value === 'document' &&\n                (m === 'write' || m === 'writeln')) {\n            warning(\"document.write can be a form of eval.\", left);\n        } else if (option.adsafe) {\n            if (left && left.value === 'ADSAFE') {\n                if (m === 'id' || m === 'lib') {\n                    warning(\"ADsafe violation.\", that);\n                } else if (m === 'go') {\n                    if (xmode !== 'script') {\n                        warning(\"ADsafe violation.\", that);\n                    } else if (adsafe_went || nexttoken.id !== '(' ||\n                            peek(0).id !== '(string)' ||\n                            peek(0).value !== adsafe_id ||\n                            peek(1).id !== ',') {\n                        error(\"ADsafe violation: go.\", that);\n                    }\n                    adsafe_went = true;\n                    adsafe_may = false;\n                }\n            }\n        }\n        if (!option.evil && (m === 'eval' || m === 'execScript')) {\n            warning('eval is evil.');\n        } else if (option.safe) {\n            for (;;) {\n                if (banned[m] === true) {\n                    warning(\"ADsafe restricted word '{a}'.\", token, m);\n                }\n                if (typeof predefined[left.value] !== 'boolean' ||\n                        nexttoken.id === '(') {\n                    break;\n                }\n                if (standard_member[m] === true) {\n                    if (nexttoken.id === '.') {\n                        warning(\"ADsafe violation.\", that);\n                    }\n                    break;\n                }\n                if (nexttoken.id !== '.') {\n                    warning(\"ADsafe violation.\", that);\n                    break;\n                }\n                advance('.');\n                token.left = that;\n                token.right = m;\n                that = token;\n                m = identifier();\n                if (typeof m === 'string') {\n                    countMember(m);\n                }\n            }\n        }\n        return that;\n    }, 160, true);\n\n    infix('(', function (left, that) {\n        if (prevtoken.id !== '}' && prevtoken.id !== ')') {\n            nobreak(prevtoken, token);\n        }\n        nospace();\n        if (option.immed && !left.immed && left.id === 'function') {\n            warning(\"Wrap an immediate function invocation in parentheses \" +\n                \"to assist the reader in understanding that the expression \" +\n                \"is the result of a function, and not the function itself.\");\n        }\n        var n = 0,\n            p = [];\n        if (left) {\n            if (left.type === '(identifier)') {\n                if (left.value.match(/^[A-Z]([A-Z0-9_$]*[a-z][A-Za-z0-9_$]*)?$/)) {\n                    if (left.value !== 'Number' && left.value !== 'String' &&\n                            left.value !== 'Boolean' &&\n                            left.value !== 'Date') {\n                        if (left.value === 'Math') {\n                            warning(\"Math is not a function.\", left);\n                        } else if (option.newcap) {\n                            warning(\n\"Missing 'new' prefix when invoking a constructor.\", left);\n                        }\n                    }\n                }\n            } else if (left.id === '.') {\n                if (option.safe && left.left.value === 'Math' &&\n                        left.right === 'random') {\n                    warning(\"ADsafe violation.\", left);\n                }\n            }\n        }\n        if (nexttoken.id !== ')') {\n            for (;;) {\n                p[p.length] = parse(10);\n                n += 1;\n                if (nexttoken.id !== ',') {\n                    break;\n                }\n                comma();\n            }\n        }\n        advance(')');\n        nospace(prevtoken, token);\n        if (typeof left === 'object') {\n            if (left.value === 'parseInt' && n === 1) {\n                warning(\"Missing radix parameter.\", left);\n            }\n            if (!option.evil) {\n                if (left.value === 'eval' || left.value === 'Function' ||\n                        left.value === 'execScript') {\n                    warning(\"eval is evil.\", left);\n                } else if (p[0] && p[0].id === '(string)' &&\n                       (left.value === 'setTimeout' ||\n                        left.value === 'setInterval')) {\n                    warning(\n    \"Implied eval is evil. Pass a function instead of a string.\", left);\n                }\n            }\n            if (!left.identifier && left.id !== '.' && left.id !== '[' &&\n                    left.id !== '(' && left.id !== '&&' && left.id !== '||' &&\n                    left.id !== '?') {\n                warning(\"Bad invocation.\", left);\n            }\n        }\n        that.left = left;\n        return that;\n    }, 155, true).exps = true;\n\n    prefix('(', function () {\n        nospace();\n        if (nexttoken.id === 'function') {\n            nexttoken.immed = true;\n        }\n        var v = parse(0);\n        advance(')', this);\n        nospace(prevtoken, token);\n        if (option.immed && v.id === 'function') {\n            if (nexttoken.id === '(') {\n                warning(\n\"Move the invocation into the parens that contain the function.\", nexttoken);\n            } else {\n                warning(\n\"Do not wrap function literals in parens unless they are to be immediately invoked.\",\n                        this);\n            }\n        }\n        return v;\n    });\n\n    infix('[', function (left, that) {\n        nobreak(prevtoken, token);\n        nospace();\n        var e = parse(0), s;\n        if (e && e.type === '(string)') {\n            if (option.safe && banned[e.value] === true) {\n                warning(\"ADsafe restricted word '{a}'.\", that, e.value);\n            } else if (!option.evil &&\n                    (e.value === 'eval' || e.value === 'execScript')) {\n                warning(\"eval is evil.\", that);\n            } else if (option.safe &&\n                    (e.value.charAt(0) === '_' || e.value.charAt(0) === '-')) {\n                warning(\"ADsafe restricted subscript '{a}'.\", that, e.value);\n            }\n            countMember(e.value);\n            if (!option.sub && ix.test(e.value)) {\n                s = syntax[e.value];\n                if (!s || !s.reserved) {\n                    warning(\"['{a}'] is better written in dot notation.\",\n                            e, e.value);\n                }\n            }\n        } else if (!e || e.type !== '(number)' || e.value < 0) {\n            if (option.safe) {\n                warning('ADsafe subscripting.');\n            }\n        }\n        advance(']', that);\n        nospace(prevtoken, token);\n        that.left = left;\n        that.right = e;\n        return that;\n    }, 160, true);\n\n    prefix('[', function () {\n        var b = token.line !== nexttoken.line;\n        this.first = [];\n        if (b) {\n            indent += option.indent;\n            if (nexttoken.from === indent + option.indent) {\n                indent += option.indent;\n            }\n        }\n        while (nexttoken.id !== '(end)') {\n            while (nexttoken.id === ',') {\n                warning(\"Extra comma.\");\n                advance(',');\n            }\n            if (nexttoken.id === ']') {\n                break;\n            }\n            if (b && token.line !== nexttoken.line) {\n                indentation();\n            }\n            this.first.push(parse(10));\n            if (nexttoken.id === ',') {\n                comma();\n                if (nexttoken.id === ']' && !option.es5) {\n                    warning(\"Extra comma.\", token);\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n        if (b) {\n            indent -= option.indent;\n            indentation();\n        }\n        advance(']', this);\n        return this;\n    }, 160);\n\n\n    function property_name() {\n        var id = optionalidentifier(true);\n        if (!id) {\n            if (nexttoken.id === '(string)') {\n                id = nexttoken.value;\n                if (option.adsafe &&\n                        (id.charAt(0) === '_' ||\n                         id.charAt(id.length - 1) === '_')) {\n                    warning(\"Unexpected {a} in '{b}'.\", token,\n                        \"dangling '_'\", id);\n                }\n                advance();\n            } else if (nexttoken.id === '(number)') {\n                id = nexttoken.value.toString();\n                advance();\n            }\n        }\n        return id;\n    }\n\n\n    function functionparams() {\n        var i, t = nexttoken, p = [];\n        advance('(');\n        nospace();\n        if (nexttoken.id === ')') {\n            advance(')');\n            nospace(prevtoken, token);\n            return;\n        }\n        for (;;) {\n            i = identifier();\n            p.push(i);\n            addlabel(i, 'parameter');\n            if (nexttoken.id === ',') {\n                comma();\n            } else {\n                advance(')', t);\n                nospace(prevtoken, token);\n                return p;\n            }\n        }\n    }\n\n\n    function doFunction(i, statement) {\n        var f, s = scope;\n        scope = Object.create(s);\n        funct = {\n            '(name)'     : i || '\"' + anonname + '\"',\n            '(line)'     : nexttoken.line,\n            '(context)'  : funct,\n            '(breakage)' : 0,\n            '(loopage)'  : 0,\n            '(scope)'    : scope,\n            '(statement)': statement\n        };\n        f = funct;\n        token.funct = funct;\n        functions.push(funct);\n        if (i) {\n            addlabel(i, 'function');\n        }\n        funct['(params)'] = functionparams();\n\n        block(false);\n        scope = s;\n        funct['(last)'] = token.line;\n        funct = funct['(context)'];\n        return f;\n    }\n\n\n    (function (x) {\n        x.nud = function () {\n            var b, f, i, j, p, seen = {}, t;\n            b = token.line !== nexttoken.line;\n            if (b) {\n                indent += option.indent;\n                if (nexttoken.from === indent + option.indent) {\n                    indent += option.indent;\n                }\n            }\n            for (;;) {\n                if (nexttoken.id === '}') {\n                    break;\n                }\n                if (b) {\n                    indentation();\n                }\n                if (nexttoken.value === 'get' && peek().id !== ':') {\n                    advance('get');\n                    if (!option.es5) {\n                        error(\"get/set are ES5 features.\");\n                    }\n                    i = property_name();\n                    if (!i) {\n                        error(\"Missing property name.\");\n                    }\n                    t = nexttoken;\n                    adjacent(token, nexttoken);\n                    f = doFunction(i);\n                    if (funct['(loopage)']) {\n                        warning(\"Don't make functions within a loop.\", t);\n                    }\n                    p = f['(params)'];\n                    if (p) {\n                        warning(\"Unexpected parameter '{a}' in get {b} function.\", t, p[0], i);\n                    }\n                    adjacent(token, nexttoken);\n                    advance(',');\n                    indentation();\n                    advance('set');\n                    j = property_name();\n                    if (i !== j) {\n                        error(\"Expected {a} and instead saw {b}.\", token, i, j);\n                    }\n                    t = nexttoken;\n                    adjacent(token, nexttoken);\n                    f = doFunction(i);\n                    p = f['(params)'];\n                    if (!p || p.length !== 1 || p[0] !== 'value') {\n                        warning(\"Expected (value) in set {a} function.\", t, i);\n                    }\n                } else {\n                    i = property_name();\n                    if (typeof i !== 'string') {\n                        break;\n                    }\n                    advance(':');\n                    nonadjacent(token, nexttoken);\n                    parse(10);\n                }\n                if (seen[i] === true) {\n                    warning(\"Duplicate member '{a}'.\", nexttoken, i);\n                }\n                seen[i] = true;\n                countMember(i);\n                if (nexttoken.id === ',') {\n                    comma();\n                    if (nexttoken.id === ',') {\n                        warning(\"Extra comma.\", token);\n                    } else if (nexttoken.id === '}' && !option.es5) {\n                        warning(\"Extra comma.\", token);\n                    }\n                } else {\n                    break;\n                }\n            }\n            if (b) {\n                indent -= option.indent;\n                indentation();\n            }\n            advance('}', this);\n            return this;\n        };\n        x.fud = function () {\n            error(\"Expected to see a statement and instead saw a block.\", token);\n        };\n    }(delim('{')));\n\n\n    var varstatement = function varstatement(prefix) {\n\n// JavaScript does not have block scope. It only has function scope. So,\n// declaring a variable in a block can have unexpected consequences.\n\n        var id, name, value;\n\n        if (funct['(onevar)'] && option.onevar) {\n            warning(\"Too many var statements.\");\n        } else if (!funct['(global)']) {\n            funct['(onevar)'] = true;\n        }\n        this.first = [];\n        for (;;) {\n            nonadjacent(token, nexttoken);\n            id = identifier();\n            if (funct['(global)'] && predefined[id] === false) {\n                warning(\"Redefinition of '{a}'.\", token, id);\n            }\n            addlabel(id, 'unused');\n            if (prefix) {\n                break;\n            }\n            name = token;\n            this.first.push(token);\n            if (nexttoken.id === '=') {\n                nonadjacent(token, nexttoken);\n                advance('=');\n                nonadjacent(token, nexttoken);\n                if (nexttoken.id === 'undefined') {\n                    warning(\"It is not necessary to initialize '{a}' to 'undefined'.\", token, id);\n                }\n                if (peek(0).id === '=' && nexttoken.identifier) {\n                    advance();\n                    advance('=');\n                    advance();\n//                    error(\"Variable {a} was not declared correctly.\",\n//                            nexttoken, nexttoken.value);\n                }\n                value = parse(0);\n                name.first = value;\n            }\n            if (nexttoken.id !== ',') {\n                break;\n            }\n            comma();\n        }\n        return this;\n    };\n\n\n    stmt('var', varstatement).exps = true;\n\n\n    blockstmt('function', function () {\n        if (inblock) {\n            warning(\n\"Function statements cannot be placed in blocks. Use a function expression or move the statement to the top of the outer function.\", token);\n\n        }\n        var i = identifier();\n        adjacent(token, nexttoken);\n        addlabel(i, 'unction');\n        doFunction(i, true);\n        if (nexttoken.id === '(' && nexttoken.line === token.line) {\n            error(\n\"Function statements are not invocable. Wrap the whole function invocation in parens.\");\n        }\n        return this;\n    });\n\n    prefix('function', function () {\n        var i = optionalidentifier();\n        if (i) {\n            adjacent(token, nexttoken);\n        } else {\n            nonadjacent(token, nexttoken);\n        }\n        doFunction(i);\n        if (funct['(loopage)']) {\n            warning(\"Don't make functions within a loop.\");\n        }\n        return this;\n    });\n\n    blockstmt('if', function () {\n        var t = nexttoken;\n        advance('(');\n        nonadjacent(this, t);\n        nospace();\n        parse(20);\n        if (nexttoken.id === '=') {\n            warning(\"Expected a conditional expression and instead saw an assignment.\");\n            advance('=');\n            parse(20);\n        }\n        advance(')', t);\n        nospace(prevtoken, token);\n        block(true);\n        if (nexttoken.id === 'else') {\n            nonadjacent(token, nexttoken);\n            advance('else');\n            if (nexttoken.id === 'if' || nexttoken.id === 'switch') {\n                statement(true);\n            } else {\n                block(true);\n            }\n        }\n        return this;\n    });\n\n    blockstmt('try', function () {\n        var b, e, s;\n        if (option.adsafe) {\n            warning(\"ADsafe try violation.\", this);\n        }\n        block(false);\n        if (nexttoken.id === 'catch') {\n            advance('catch');\n            nonadjacent(token, nexttoken);\n            advance('(');\n            s = scope;\n            scope = Object.create(s);\n            e = nexttoken.value;\n            if (nexttoken.type !== '(identifier)') {\n                warning(\"Expected an identifier and instead saw '{a}'.\",\n                    nexttoken, e);\n            } else {\n                addlabel(e, 'exception');\n            }\n            advance();\n            advance(')');\n            block(false);\n            b = true;\n            scope = s;\n        }\n        if (nexttoken.id === 'finally') {\n            advance('finally');\n            block(false);\n            return;\n        } else if (!b) {\n            error(\"Expected '{a}' and instead saw '{b}'.\",\n                    nexttoken, 'catch', nexttoken.value);\n        }\n        return this;\n    });\n\n    blockstmt('while', function () {\n        var t = nexttoken;\n        funct['(breakage)'] += 1;\n        funct['(loopage)'] += 1;\n        advance('(');\n        nonadjacent(this, t);\n        nospace();\n        parse(20);\n        if (nexttoken.id === '=') {\n            warning(\"Expected a conditional expression and instead saw an assignment.\");\n            advance('=');\n            parse(20);\n        }\n        advance(')', t);\n        nospace(prevtoken, token);\n        block(true);\n        funct['(breakage)'] -= 1;\n        funct['(loopage)'] -= 1;\n        return this;\n    }).labelled = true;\n\n    reserve('with');\n\n    blockstmt('switch', function () {\n        var t = nexttoken,\n            g = false;\n        funct['(breakage)'] += 1;\n        advance('(');\n        nonadjacent(this, t);\n        nospace();\n        this.condition = parse(20);\n        advance(')', t);\n        nospace(prevtoken, token);\n        nonadjacent(token, nexttoken);\n        t = nexttoken;\n        advance('{');\n        nonadjacent(token, nexttoken);\n        indent += option.indent;\n        this.cases = [];\n        for (;;) {\n            switch (nexttoken.id) {\n            case 'case':\n                switch (funct['(verb)']) {\n                case 'break':\n                case 'case':\n                case 'continue':\n                case 'return':\n                case 'switch':\n                case 'throw':\n                    break;\n                default:\n                    warning(\n                        \"Expected a 'break' statement before 'case'.\",\n                        token);\n                }\n                indentation(-option.indent);\n                advance('case');\n                this.cases.push(parse(20));\n                g = true;\n                advance(':');\n                funct['(verb)'] = 'case';\n                break;\n            case 'default':\n                switch (funct['(verb)']) {\n                case 'break':\n                case 'continue':\n                case 'return':\n                case 'throw':\n                    break;\n                default:\n                    warning(\n                        \"Expected a 'break' statement before 'default'.\",\n                        token);\n                }\n                indentation(-option.indent);\n                advance('default');\n                g = true;\n                advance(':');\n                break;\n            case '}':\n                indent -= option.indent;\n                indentation();\n                advance('}', t);\n                if (this.cases.length === 1 || this.condition.id === 'true' ||\n                        this.condition.id === 'false') {\n                    warning(\"This 'switch' should be an 'if'.\", this);\n                }\n                funct['(breakage)'] -= 1;\n                funct['(verb)'] = undefined;\n                return;\n            case '(end)':\n                error(\"Missing '{a}'.\", nexttoken, '}');\n                return;\n            default:\n                if (g) {\n                    switch (token.id) {\n                    case ',':\n                        error(\"Each value should have its own case label.\");\n                        return;\n                    case ':':\n                        statements();\n                        break;\n                    default:\n                        error(\"Missing ':' on a case clause.\", token);\n                    }\n                } else {\n                    error(\"Expected '{a}' and instead saw '{b}'.\",\n                        nexttoken, 'case', nexttoken.value);\n                }\n            }\n        }\n    }).labelled = true;\n\n    stmt('debugger', function () {\n        if (!option.debug) {\n            warning(\"All 'debugger' statements should be removed.\");\n        }\n        return this;\n    }).exps = true;\n\n    (function () {\n        var x = stmt('do', function () {\n            funct['(breakage)'] += 1;\n            funct['(loopage)'] += 1;\n            this.first = block(true);\n            advance('while');\n            var t = nexttoken;\n            nonadjacent(token, t);\n            advance('(');\n            nospace();\n            parse(20);\n            if (nexttoken.id === '=') {\n                warning(\"Expected a conditional expression and instead saw an assignment.\");\n                advance('=');\n                parse(20);\n            }\n            advance(')', t);\n            nospace(prevtoken, token);\n            funct['(breakage)'] -= 1;\n            funct['(loopage)'] -= 1;\n            return this;\n        });\n        x.labelled = true;\n        x.exps = true;\n    }());\n\n    blockstmt('for', function () {\n        var f = option.forin, s, t = nexttoken;\n        funct['(breakage)'] += 1;\n        funct['(loopage)'] += 1;\n        advance('(');\n        nonadjacent(this, t);\n        nospace();\n        if (peek(nexttoken.id === 'var' ? 1 : 0).id === 'in') {\n            if (nexttoken.id === 'var') {\n                advance('var');\n                varstatement(true);\n            } else {\n                switch (funct[nexttoken.value]) {\n                case 'unused':\n                    funct[nexttoken.value] = 'var';\n                    break;\n                case 'var':\n                    break;\n                default:\n                    warning(\"Bad for in variable '{a}'.\",\n                            nexttoken, nexttoken.value);\n                }\n                advance();\n            }\n            advance('in');\n            parse(20);\n            advance(')', t);\n            s = block(true);\n            if (!f && (s.length > 1 || typeof s[0] !== 'object' ||\n                    s[0].value !== 'if')) {\n                warning(\"The body of a for in should be wrapped in an if statement to filter unwanted properties from the prototype.\", this);\n            }\n            funct['(breakage)'] -= 1;\n            funct['(loopage)'] -= 1;\n            return this;\n        } else {\n            if (nexttoken.id !== ';') {\n                if (nexttoken.id === 'var') {\n                    advance('var');\n                    varstatement();\n                } else {\n                    for (;;) {\n                        parse(0, 'for');\n                        if (nexttoken.id !== ',') {\n                            break;\n                        }\n                        comma();\n                    }\n                }\n            }\n            nolinebreak(token);\n            advance(';');\n            if (nexttoken.id !== ';') {\n                parse(20);\n                if (nexttoken.id === '=') {\n                    warning(\"Expected a conditional expression and instead saw an assignment.\");\n                    advance('=');\n                    parse(20);\n                }\n            }\n            nolinebreak(token);\n            advance(';');\n            if (nexttoken.id === ';') {\n                error(\"Expected '{a}' and instead saw '{b}'.\",\n                        nexttoken, ')', ';');\n            }\n            if (nexttoken.id !== ')') {\n                for (;;) {\n                    parse(0, 'for');\n                    if (nexttoken.id !== ',') {\n                        break;\n                    }\n                    comma();\n                }\n            }\n            advance(')', t);\n            nospace(prevtoken, token);\n            block(true);\n            funct['(breakage)'] -= 1;\n            funct['(loopage)'] -= 1;\n            return this;\n        }\n    }).labelled = true;\n\n\n    stmt('break', function () {\n        var v = nexttoken.value;\n        if (funct['(breakage)'] === 0) {\n            warning(\"Unexpected '{a}'.\", nexttoken, this.value);\n        }\n        nolinebreak(this);\n        if (nexttoken.id !== ';') {\n            if (token.line === nexttoken.line) {\n                if (funct[v] !== 'label') {\n                    warning(\"'{a}' is not a statement label.\", nexttoken, v);\n                } else if (scope[v] !== funct) {\n                    warning(\"'{a}' is out of scope.\", nexttoken, v);\n                }\n                this.first = nexttoken;\n                advance();\n            }\n        }\n        reachable('break');\n        return this;\n    }).exps = true;\n\n\n    stmt('continue', function () {\n        var v = nexttoken.value;\n        if (funct['(breakage)'] === 0) {\n            warning(\"Unexpected '{a}'.\", nexttoken, this.value);\n        }\n        nolinebreak(this);\n        if (nexttoken.id !== ';') {\n            if (token.line === nexttoken.line) {\n                if (funct[v] !== 'label') {\n                    warning(\"'{a}' is not a statement label.\", nexttoken, v);\n                } else if (scope[v] !== funct) {\n                    warning(\"'{a}' is out of scope.\", nexttoken, v);\n                }\n                this.first = nexttoken;\n                advance();\n            }\n        } else if (!funct['(loopage)']) {\n            warning(\"Unexpected '{a}'.\", nexttoken, this.value);\n        }\n        reachable('continue');\n        return this;\n    }).exps = true;\n\n\n    stmt('return', function () {\n        nolinebreak(this);\n        if (nexttoken.id === '(regexp)') {\n            warning(\"Wrap the /regexp/ literal in parens to disambiguate the slash operator.\");\n        }\n        if (nexttoken.id !== ';' && !nexttoken.reach) {\n            nonadjacent(token, nexttoken);\n            this.first = parse(20);\n        }\n        reachable('return');\n        return this;\n    }).exps = true;\n\n\n    stmt('throw', function () {\n        nolinebreak(this);\n        nonadjacent(token, nexttoken);\n        this.first = parse(20);\n        reachable('throw');\n        return this;\n    }).exps = true;\n\n    reserve('void');\n\n//  Superfluous reserved words\n\n    reserve('class');\n    reserve('const');\n    reserve('enum');\n    reserve('export');\n    reserve('extends');\n    reserve('import');\n    reserve('super');\n\n    reserve('let');\n    reserve('yield');\n    reserve('implements');\n    reserve('interface');\n    reserve('package');\n    reserve('private');\n    reserve('protected');\n    reserve('public');\n    reserve('static');\n\n\n// Parse JSON\n\n    function jsonValue() {\n\n        function jsonObject() {\n            var o = {}, t = nexttoken;\n            advance('{');\n            if (nexttoken.id !== '}') {\n                for (;;) {\n                    if (nexttoken.id === '(end)') {\n                        error(\"Missing '}' to match '{' from line {a}.\",\n                                nexttoken, t.line);\n                    } else if (nexttoken.id === '}') {\n                        warning(\"Unexpected comma.\", token);\n                        break;\n                    } else if (nexttoken.id === ',') {\n                        error(\"Unexpected comma.\", nexttoken);\n                    } else if (nexttoken.id !== '(string)') {\n                        warning(\"Expected a string and instead saw {a}.\",\n                                nexttoken, nexttoken.value);\n                    }\n                    if (o[nexttoken.value] === true) {\n                        warning(\"Duplicate key '{a}'.\",\n                                nexttoken, nexttoken.value);\n                    } else if (nexttoken.value === '__proto__') {\n                        warning(\"Stupid key '{a}'.\",\n                                nexttoken, nexttoken.value);\n                    } else {\n                        o[nexttoken.value] = true;\n                    }\n                    advance();\n                    advance(':');\n                    jsonValue();\n                    if (nexttoken.id !== ',') {\n                        break;\n                    }\n                    advance(',');\n                }\n            }\n            advance('}');\n        }\n\n        function jsonArray() {\n            var t = nexttoken;\n            advance('[');\n            if (nexttoken.id !== ']') {\n                for (;;) {\n                    if (nexttoken.id === '(end)') {\n                        error(\"Missing ']' to match '[' from line {a}.\",\n                                nexttoken, t.line);\n                    } else if (nexttoken.id === ']') {\n                        warning(\"Unexpected comma.\", token);\n                        break;\n                    } else if (nexttoken.id === ',') {\n                        error(\"Unexpected comma.\", nexttoken);\n                    }\n                    jsonValue();\n                    if (nexttoken.id !== ',') {\n                        break;\n                    }\n                    advance(',');\n                }\n            }\n            advance(']');\n        }\n\n        switch (nexttoken.id) {\n        case '{':\n            jsonObject();\n            break;\n        case '[':\n            jsonArray();\n            break;\n        case 'true':\n        case 'false':\n        case 'null':\n        case '(number)':\n        case '(string)':\n            advance();\n            break;\n        case '-':\n            advance('-');\n            if (token.character !== nexttoken.from) {\n                warning(\"Unexpected space after '-'.\", token);\n            }\n            adjacent(token, nexttoken);\n            advance('(number)');\n            break;\n        default:\n            error(\"Expected a JSON value.\", nexttoken);\n        }\n    }\n\n\n// The actual JSLINT function itself.\n\n    var itself = function (s, o) {\n        var a, i;\n        JSLINT.errors = [];\n        predefined = Object.create(standard);\n        if (o) {\n            a = o.predef;\n            if (a instanceof Array) {\n                for (i = 0; i < a.length; i += 1) {\n                    predefined[a[i]] = true;\n                }\n            }\n            if (o.adsafe) {\n                o.safe = true;\n            }\n            if (o.safe) {\n                o.browser =\n                o.css     =\n                o.debug   =\n                o.devel   =\n                o.evil    =\n                o.forin   =\n                o.on      =\n                o.rhino   =\n                o.windows =\n                o.sub     =\n                o.widget  = false;\n\n                o.eqeqeq  =\n                o.nomen   =\n                o.safe    =\n                o.strict  =\n                o.undef   = true;\n\n                predefined.Date =\n                predefined['eval'] =\n                predefined.Function =\n                predefined.Object = null;\n\n                predefined.ADSAFE =\n                predefined.lib = false;\n            }\n            option = o;\n        } else {\n            option = {};\n        }\n        option.indent = option.indent || 4;\n        option.maxerr = option.maxerr || 50;\n        adsafe_id = '';\n        adsafe_may = false;\n        adsafe_went = false;\n        approved = {};\n        if (option.approved) {\n            for (i = 0; i < option.approved.length; i += 1) {\n                approved[option.approved[i]] = option.approved[i];\n            }\n        } else {\n            approved.test = 'test';\n        }\n        tab = '';\n        for (i = 0; i < option.indent; i += 1) {\n            tab += ' ';\n        }\n        indent = 1;\n        global = Object.create(predefined);\n        scope = global;\n        funct = {\n            '(global)': true,\n            '(name)': '(global)',\n            '(scope)': scope,\n            '(breakage)': 0,\n            '(loopage)': 0\n        };\n        functions = [funct];\n        ids = {};\n        urls = [];\n        src = false;\n        xmode = false;\n        stack = null;\n        member = {};\n        membersOnly = null;\n        implied = {};\n        inblock = false;\n        lookahead = [];\n        jsonmode = false;\n        warnings = 0;\n        lex.init(s);\n        prereg = true;\n        strict_mode = false;\n\n        prevtoken = token = nexttoken = syntax['(begin)'];\n        assume();\n\n        try {\n            advance();\n            if (nexttoken.value.charAt(0) === '<') {\n                html();\n                if (option.adsafe && !adsafe_went) {\n                    warning(\"ADsafe violation: Missing ADSAFE.go.\", this);\n                }\n            } else {\n                switch (nexttoken.id) {\n                case '{':\n                case '[':\n                    option.laxbreak = true;\n                    jsonmode = true;\n                    jsonValue();\n                    break;\n                case '@':\n                case '*':\n                case '#':\n                case '.':\n                case ':':\n                    xmode = 'style';\n                    advance();\n                    if (token.id !== '@' || !nexttoken.identifier ||\n                            nexttoken.value !== 'charset' || token.line !== 1 ||\n                            token.from !== 1) {\n                        error(\"A css file should begin with @charset 'UTF-8';\");\n                    }\n                    advance();\n                    if (nexttoken.type !== '(string)' &&\n                            nexttoken.value !== 'UTF-8') {\n                        error(\"A css file should begin with @charset 'UTF-8';\");\n                    }\n                    advance();\n                    advance(';');\n                    styles();\n                    break;\n\n                default:\n                    if (option.adsafe && option.fragment) {\n                        error(\"Expected '{a}' and instead saw '{b}'.\",\n                            nexttoken, '<div>', nexttoken.value);\n                    }\n                    statements('lib');\n                }\n            }\n            advance('(end)');\n        } catch (e) {\n            if (e) {\n                JSLINT.errors.push({\n                    reason    : e.message,\n                    line      : e.line || nexttoken.line,\n                    character : e.character || nexttoken.from\n                }, null);\n            }\n        }\n        return JSLINT.errors.length === 0;\n    };\n\n    function is_array(o) {\n        return Object.prototype.toString.apply(o) === '[object Array]';\n    }\n\n    function to_array(o) {\n        var a = [], k;\n        for (k in o) {\n            if (is_own(o, k)) {\n                a.push(k);\n            }\n        }\n        return a;\n    }\n\n\n// Data summary.\n\n    itself.data = function () {\n\n        var data = {functions: []}, fu, globals, implieds = [], f, i, j,\n            members = [], n, unused = [], v;\n        if (itself.errors.length) {\n            data.errors = itself.errors;\n        }\n\n        if (jsonmode) {\n            data.json = true;\n        }\n\n        for (n in implied) {\n            if (is_own(implied, n)) {\n                implieds.push({\n                    name: n,\n                    line: implied[n]\n                });\n            }\n        }\n        if (implieds.length > 0) {\n            data.implieds = implieds;\n        }\n\n        if (urls.length > 0) {\n            data.urls = urls;\n        }\n\n        globals = to_array(scope);\n        if (globals.length > 0) {\n            data.globals = globals;\n        }\n\n        for (i = 1; i < functions.length; i += 1) {\n            f = functions[i];\n            fu = {};\n            for (j = 0; j < functionicity.length; j += 1) {\n                fu[functionicity[j]] = [];\n            }\n            for (n in f) {\n                if (is_own(f, n) && n.charAt(0) !== '(') {\n                    v = f[n];\n                    if (v === 'unction') {\n                        v = 'unused';\n                    }\n                    if (is_array(fu[v])) {\n                        fu[v].push(n);\n                        if (v === 'unused') {\n                            unused.push({\n                                name: n,\n                                line: f['(line)'],\n                                'function': f['(name)']\n                            });\n                        }\n                    }\n                }\n            }\n            for (j = 0; j < functionicity.length; j += 1) {\n                if (fu[functionicity[j]].length === 0) {\n                    delete fu[functionicity[j]];\n                }\n            }\n            fu.name = f['(name)'];\n            fu.param = f['(params)'];\n            fu.line = f['(line)'];\n            fu.last = f['(last)'];\n            data.functions.push(fu);\n        }\n\n        if (unused.length > 0) {\n            data.unused = unused;\n        }\n\n        members = [];\n        for (n in member) {\n            if (typeof member[n] === 'number') {\n                data.member = member;\n                break;\n            }\n        }\n\n        return data;\n    };\n\n    itself.report = function (option) {\n        var data = itself.data();\n\n        var a = [], c, e, err, f, i, k, l, m = '', n, o = [], s;\n\n        function detail(h, array) {\n            var b, i, singularity;\n            if (array) {\n                o.push('<div><i>' + h + '</i> ');\n                array = array.sort();\n                for (i = 0; i < array.length; i += 1) {\n                    if (array[i] !== singularity) {\n                        singularity = array[i];\n                        o.push((b ? ', ' : '') + singularity);\n                        b = true;\n                    }\n                }\n                o.push('</div>');\n            }\n        }\n\n\n        if (data.errors || data.implieds || data.unused) {\n            err = true;\n            o.push('<div id=errors><i>Error:</i>');\n            if (data.errors) {\n                for (i = 0; i < data.errors.length; i += 1) {\n                    c = data.errors[i];\n                    if (c) {\n                        e = c.evidence || '';\n                        o.push('<p>Problem' + (isFinite(c.line) ? ' at line ' +\n                                c.line + ' character ' + c.character : '') +\n                                ': ' + c.reason.entityify() +\n                                '</p><p class=evidence>' +\n                                (e && (e.length > 80 ? e.slice(0, 77) + '...' :\n                                e).entityify()) + '</p>');\n                    }\n                }\n            }\n\n            if (data.implieds) {\n                s = [];\n                for (i = 0; i < data.implieds.length; i += 1) {\n                    s[i] = '<code>' + data.implieds[i].name + '</code>&nbsp;<i>' +\n                        data.implieds[i].line + '</i>';\n                }\n                o.push('<p><i>Implied global:</i> ' + s.join(', ') + '</p>');\n            }\n\n            if (data.unused) {\n                s = [];\n                for (i = 0; i < data.unused.length; i += 1) {\n                    s[i] = '<code><u>' + data.unused[i].name + '</u></code>&nbsp;<i>' +\n                        data.unused[i].line + '</i> <code>' +\n                        data.unused[i]['function'] + '</code>';\n                }\n                o.push('<p><i>Unused variable:</i> ' + s.join(', ') + '</p>');\n            }\n            if (data.json) {\n                o.push('<p>JSON: bad.</p>');\n            }\n            o.push('</div>');\n        }\n\n        if (!option) {\n\n            o.push('<br><div id=functions>');\n\n            if (data.urls) {\n                detail(\"URLs<br>\", data.urls, '<br>');\n            }\n\n            if (xmode === 'style') {\n                o.push('<p>CSS.</p>');\n            } else if (data.json && !err) {\n                o.push('<p>JSON: good.</p>');\n            } else if (data.globals) {\n                o.push('<div><i>Global</i> ' +\n                        data.globals.sort().join(', ') + '</div>');\n            } else {\n                o.push('<div><i>No new global variables introduced.</i></div>');\n            }\n\n            for (i = 0; i < data.functions.length; i += 1) {\n                f = data.functions[i];\n\n                o.push('<br><div class=function><i>' + f.line + '-' +\n                        f.last + '</i> ' + (f.name || '') + '(' +\n                        (f.param ? f.param.join(', ') : '') + ')</div>');\n                detail('<big><b>Unused</b></big>', f.unused);\n                detail('Closure', f.closure);\n                detail('Variable', f['var']);\n                detail('Exception', f.exception);\n                detail('Outer', f.outer);\n                detail('Global', f.global);\n                detail('Label', f.label);\n            }\n\n            if (data.member) {\n                a = to_array(data.member);\n                if (a.length) {\n                    a = a.sort();\n                    m = '<br><pre id=members>/*members ';\n                    l = 10;\n                    for (i = 0; i < a.length; i += 1) {\n                        k = a[i];\n                        n = k.name();\n                        if (l + n.length > 72) {\n                            o.push(m + '<br>');\n                            m = '    ';\n                            l = 1;\n                        }\n                        l += n.length + 2;\n                        if (data.member[k] === 1) {\n                            n = '<i>' + n + '</i>';\n                        }\n                        if (i < a.length - 1) {\n                            n += ', ';\n                        }\n                        m += n;\n                    }\n                    o.push(m + '<br>*/</pre>');\n                }\n                o.push('</div>');\n            }\n        }\n        return o.join('');\n    };\n    itself.jslint = itself;\n\n    itself.edition = '2010-11-18';\n\n    return itself;\n\n}());\n");
jsio.setCachedSrc("../../packages/util/path.js","var util = jsio.__jsio.__util;\n\nexports.buildPath = util.buildPath;\nexports.resolveRelativePath = util.resolveRelativePath;\nexports.splitPath = util.splitPath;\nexports.makeRelativePath = util.makeRelativePath;");jsio.setCachedSrc("../../packages/util/syntax.js","jsio('import .jslint');\n\nvar isBrowser = jsio.__env.name == 'browser',\n\tisRhino = jsio.__env.name == 'rhino',\n\tbase = jsio('base'),\n\tglobals = ['exports', 'jsio', 'logger'];\n\nfor (var i in base) {\n\tglobals.push(i);\n}\n\nexports = function(code, opts) {\n\topts = opts || exports.defaultOpts;\n\tif (!jslint(code, opts) && opts.display) {\n\t\texports.display(jslint.errors);\n\t}\n\treturn jslint.errors;\n}\n\nexports.display = function(result, title) {\n\tvar log = [title || ''],\n\t\thtml = ['<div class=\"_jsioLint_title\">' + (title || '') + '</div>'],\n\t\tcss = [\n\t\t\t \"._jsioLint_title { color: #FFF; padding-bottom: 6px; border-bottom: 3px dashed #888; margin-bottom: 30px }\"\n\t\t\t,\"._jsioLint_whitespace {color: #444}\"\n\t\t\t,\"._jsioLint_lineNum { color: rgb(153,207,80)}\"\n\t\t\t,\"._jsioLint_charNum { color: rgb(51,135,204)}\"\n\t\t\t,\"._jsioLint_reason { color: rgb(137,189,255)}\"\n\t\t\t,\"._jsioLint_evidence { color:rgb(226,137,100)}\"\n\t\t];\n\t\n\tfunction pointTo(line, i) {\n\t\treturn new Array(i).join(' ') + '\\u21D1<span class=\"_jsioLint_charNum\">@' + e.character + '</span>\\n';\n\t}\n\t\n\tfunction whitespace(line) {\n\t\treturn line.replace(/ /g, '<span class=\"_jsioLint_whitespace\">\\u00B7</span>').replace(/\\t/g, '<span class=\"_jsioLint_whitespace\">\\u21FE   </span>');\n\t}\n\t\n\tfor (var i = 0, e; e = result[i]; ++i) {\n\t\tlog.push(e.line + '-' + e.character + ': ' + e.reason + '\\n> ' + e.evidence)\n\t\thtml.push('<span class=\"_jsioLint_lineNum\">line ' + e.line + '</span>');\n\t\thtml.push(': ');\n\t\thtml.push('<span class=\"_jsioLint_reason\">' + e.reason + '</span>');\n\t\tif ('evidence' in e) {\n\t\t\thtml.push('<div class=\"_jsioLint_evidence\">' + whitespace(e.evidence) + '</div>');\n\t\t\thtml.push(pointTo(e.evidence, e.character));\n\t\t}\n\t\thtml.push('\\n');\n\t}\n\t\n\tlogger.log(log.join('\\n'));\n\t\n\tjsio('util/browser').$({\n\t\ttag: 'pre',\n\t\tid: 'syntaxCheck',\n\t\tstyle: {\n\t\t\tpadding: '50px',\n\t\t\tfontSize: '16px'\n\t\t},\n\t\thtml: '<style>' + css.join('') + '</style>' + html.join(''),\n\t\tparent: $({\n\t\t\ttag: 'div',\n\t\t\tstyle: {\n\t\t\t\tbackground: '#000',\n\t\t\t\tposition: 'absolute',\n\t\t\t\ttop: '0px',\n\t\t\t\tleft: '0px',\n\t\t\t\tmargin: '0px',\n\t\t\t\tpadding: '0px',\n\t\t\t\tcolor: '#AAA',\n\t\t\t\twidth: '100%',\n\t\t\t\theight: '100%',\n\t\t\t\toverflow: 'auto',\n\t\t\t\tfontWeight: 'bold',\n\t\t\t\tfontFamily: 'consolas, \"courier new\"',\n\t\t\t\tzIndex: 2000000\n\t\t\t},\n\t\t\tparent: document.body\n\t\t})\n\t});\n}\n\nexports.defaultOpts = {\n    adsafe     : false, // if ADsafe should be enforced\n    bitwise    : false, // if bitwise operators should not be allowed\n    browser    : isBrowser, // if the standard browser globals should be predefined\n    cap        : true, // if upper case HTML should be allowed\n    css        : true, // if CSS workarounds should be tolerated\n    debug      : true, // if debugger statements should be allowed\n    devel      : true, // if logging should be allowed (console, alert, etc.)\n    eqeqeq     : false, // if === should be required\n    es5        : false, // if ES5 syntax should be allowed\n    evil       : false, // if eval should be allowed\n    forin      : false, // if for in statements must filter\n    fragment   : true, // if HTML fragments should be allowed\n    immed      : true, // if immediate invocations must be wrapped in parens\n    laxbreak   : true, // if line breaks should not be checked\n    newcap     : true, // if constructor names must be capitalized\n    nomen      : false, // if names should be checked\n    on         : true, // if HTML event handlers should be allowed\n    onevar     : false, // if only one var statement per function should be allowed\n    passfail   : false, // if the scan should stop on first error\n    plusplus   : false, // if increment/decrement should not be allowed\n    regexp     : false, // if the . should not be allowed in regexp literals\n    rhino      : isRhino, // if the Rhino environment globals should be predefined\n    undef      : false, // if variables should be declared before used\n    safe       : false, // if use of some browser features should be restricted\n    windows    : false, // if MS Windows-specific globals should be predefined\n    strict     : false, // require the \"use strict\"; pragma\n    sub        : true, // if all forms of subscript notation are tolerated\n    white      : false, // if strict whitespace rules apply\n    widget     : false,  // if the Yahoo Widgets globals should be predefined\n    predef     : globals // list of globals\n};\n\nexports.warnOpts = {\n    adsafe     : false, // if ADsafe should be enforced\n    bitwise    : false, // if bitwise operators should not be allowed\n    browser    : true, // if the standard browser globals should be predefined\n    cap        : true, // if upper case HTML should be allowed\n    css        : true, // if CSS workarounds should be tolerated\n    debug      : false, // if debugger statements should be allowed\n    devel      : false, // if logging should be allowed (console, alert, etc.)\n    eqeqeq     : false, // if === should be required\n    es5        : false, // if ES5 syntax should be allowed\n    evil       : false, // if eval should be allowed\n    forin      : false, // if for in statements must filter\n    fragment   : true, // if HTML fragments should be allowed\n    immed      : true, // if immediate invocations must be wrapped in parens\n    laxbreak   : true, // if line breaks should not be checked\n    newcap     : true, // if constructor names must be capitalized\n    nomen      : false, // if names should be checked\n    on         : true, // if HTML event handlers should be allowed\n    onevar     : false, // if only one var statement per function should be allowed\n    passfail   : false, // if the scan should stop on first error\n    plusplus   : false, // if increment/decrement should not be allowed\n    regexp     : false, // if the . should not be allowed in regexp literals\n    rhino      : true, // if the Rhino environment globals should be predefined\n    undef      : false, // if variables should be declared before used\n    safe       : false, // if use of some browser features should be restricted\n    windows    : true, // if MS Windows-specific globals should be predefined\n    strict     : false, // require the \"use strict\"; pragma\n    sub        : true, // if all forms of subscript notation are tolerated\n    white      : true, // if strict whitespace rules apply\n    widget     : false  // if the Yahoo Widgets globals should be predefined\n};\n");
jsio.setCachedSrc("../../packages/util/underscore.js","//     (c) 2010 Jeremy Ashkenas, DocumentCloud Inc.\n//     Underscore is freely distributable under the MIT license.\n//     Portions of Underscore are inspired or borrowed from Prototype,\n//     Oliver Steele's Functional, and John Resig's Micro-Templating.\n//     For all details and documentation:\n//     http://documentcloud.github.com/underscore\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `global` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Establish the object that gets thrown to break out of a loop iteration.\n  var breaker = typeof StopIteration !== 'undefined' ? StopIteration : '__break__';\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var slice                 = ArrayProto.slice,\n      unshift               = ArrayProto.unshift,\n      toString              = ObjProto.toString,\n      hasOwnProperty        = ObjProto.hasOwnProperty,\n      propertyIsEnumerable  = ObjProto.propertyIsEnumerable;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeForEach      = ArrayProto.forEach,\n    nativeMap          = ArrayProto.map,\n    nativeReduce       = ArrayProto.reduce,\n    nativeReduceRight  = ArrayProto.reduceRight,\n    nativeFilter       = ArrayProto.filter,\n    nativeEvery        = ArrayProto.every,\n    nativeSome         = ArrayProto.some,\n    nativeIndexOf      = ArrayProto.indexOf,\n    nativeLastIndexOf  = ArrayProto.lastIndexOf,\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys;\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) { return new wrapper(obj); };\n\n  // Export the Underscore object for **CommonJS**.\n  if (typeof exports !== 'undefined') exports._ = _;\n\n  // Export Underscore to the global scope.\n  root._ = _;\n\n  // Current version.\n  _.VERSION = '1.1.2';\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles objects implementing `forEach`, arrays, and raw objects.\n  // Delegates to **ECMAScript 5**'s native `forEach` if available.\n  var each = _.each = _.forEach = function(obj, iterator, context) {\n    try {\n      if (nativeForEach && obj.forEach === nativeForEach) {\n        obj.forEach(iterator, context);\n      } else if (_.isNumber(obj.length)) {\n        for (var i = 0, l = obj.length; i < l; i++) iterator.call(context, obj[i], i, obj);\n      } else {\n        for (var key in obj) {\n          if (hasOwnProperty.call(obj, key)) iterator.call(context, obj[key], key, obj);\n        }\n      }\n    } catch(e) {\n      if (e != breaker) throw e;\n    }\n    return obj;\n  };\n\n  // Return the results of applying the iterator to each element.\n  // Delegates to **ECMAScript 5**'s native `map` if available.\n  _.map = function(obj, iterator, context) {\n    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n    var results = [];\n    each(obj, function(value, index, list) {\n      results[results.length] = iterator.call(context, value, index, list);\n    });\n    return results;\n  };\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.\n  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {\n    if (nativeReduce && obj.reduce === nativeReduce) {\n      if (context) iterator = _.bind(iterator, context);\n      return obj.reduce(iterator, memo);\n    }\n    each(obj, function(value, index, list) {\n      memo = iterator.call(context, memo, value, index, list);\n    });\n    return memo;\n  };\n\n  // The right-associative version of reduce, also known as `foldr`.\n  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.\n  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {\n    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\n      if (context) iterator = _.bind(iterator, context);\n      return obj.reduceRight(iterator, memo);\n    }\n    var reversed = (_.isArray(obj) ? obj.slice() : _.toArray(obj)).reverse();\n    return _.reduce(reversed, iterator, memo, context);\n  };\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, iterator, context) {\n    var result;\n    each(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) {\n        result = value;\n        _.breakLoop();\n      }\n    });\n    return result;\n  };\n\n  // Return all the elements that pass a truth test.\n  // Delegates to **ECMAScript 5**'s native `filter` if available.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, iterator, context) {\n    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);\n    var results = [];\n    each(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) results[results.length] = value;\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, iterator, context) {\n    var results = [];\n    each(obj, function(value, index, list) {\n      if (!iterator.call(context, value, index, list)) results[results.length] = value;\n    });\n    return results;\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Delegates to **ECMAScript 5**'s native `every` if available.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, iterator, context) {\n    iterator = iterator || _.identity;\n    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);\n    var result = true;\n    each(obj, function(value, index, list) {\n      if (!(result = result && iterator.call(context, value, index, list))) _.breakLoop();\n    });\n    return result;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Delegates to **ECMAScript 5**'s native `some` if available.\n  // Aliased as `any`.\n  _.some = _.any = function(obj, iterator, context) {\n    iterator = iterator || _.identity;\n    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);\n    var result = false;\n    each(obj, function(value, index, list) {\n      if (result = iterator.call(context, value, index, list)) _.breakLoop();\n    });\n    return result;\n  };\n\n  // Determine if a given value is included in the array or object using `===`.\n  // Aliased as `contains`.\n  _.include = _.contains = function(obj, target) {\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\n    var found = false;\n    each(obj, function(value) {\n      if (found = value === target) _.breakLoop();\n    });\n    return found;\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    return _.map(obj, function(value) {\n      return (method ? value[method] : value).apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, function(value){ return value[key]; });\n  };\n\n  // Return the maximum element or (element-based computation).\n  _.max = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj)) return Math.max.apply(Math, obj);\n    var result = {computed : -Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed >= result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj)) return Math.min.apply(Math, obj);\n    var result = {computed : Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed < result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Sort the object's values by a criterion produced by an iterator.\n  _.sortBy = function(obj, iterator, context) {\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value : value,\n        criteria : iterator.call(context, value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria, b = right.criteria;\n      return a < b ? -1 : a > b ? 1 : 0;\n    }), 'value');\n  };\n\n  // Use a comparator function to figure out at what index an object should\n  // be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iterator) {\n    iterator = iterator || _.identity;\n    var low = 0, high = array.length;\n    while (low < high) {\n      var mid = (low + high) >> 1;\n      iterator(array[mid]) < iterator(obj) ? low = mid + 1 : high = mid;\n    }\n    return low;\n  };\n\n  // Safely convert anything iterable into a real, live array.\n  _.toArray = function(iterable) {\n    if (!iterable)                return [];\n    if (iterable.toArray)         return iterable.toArray();\n    if (_.isArray(iterable))      return iterable;\n    if (_.isArguments(iterable))  return slice.call(iterable);\n    return _.values(iterable);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    return _.toArray(obj).length;\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head`. The **guard** check allows it to work\n  // with `_.map`.\n  _.first = _.head = function(array, n, guard) {\n    return n && !guard ? slice.call(array, 0, n) : array[0];\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail`.\n  // Especially useful on the arguments object. Passing an **index** will return\n  // the rest of the values in the array from that index onward. The **guard**\n  // check allows it to work with `_.map`.\n  _.rest = _.tail = function(array, index, guard) {\n    return slice.call(array, _.isUndefined(index) || guard ? 1 : index);\n  };\n\n  // Get the last element of an array.\n  _.last = function(array) {\n    return array[array.length - 1];\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, function(value){ return !!value; });\n  };\n\n  // Return a completely flattened version of an array.\n  _.flatten = function(array) {\n    return _.reduce(array, function(memo, value) {\n      if (_.isArray(value)) return memo.concat(_.flatten(value));\n      memo[memo.length] = value;\n      return memo;\n    }, []);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    var values = slice.call(arguments, 1);\n    return _.filter(array, function(value){ return !_.include(values, value); });\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted) {\n    return _.reduce(array, function(memo, el, i) {\n      if (0 == i || (isSorted === true ? _.last(memo) != el : !_.include(memo, el))) memo[memo.length] = el;\n      return memo;\n    }, []);\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  _.intersect = function(array) {\n    var rest = slice.call(arguments, 1);\n    return _.filter(_.uniq(array), function(item) {\n      return _.every(rest, function(other) {\n        return _.indexOf(other, item) >= 0;\n      });\n    });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    var args = slice.call(arguments);\n    var length = _.max(_.pluck(args, 'length'));\n    var results = new Array(length);\n    for (var i = 0; i < length; i++) results[i] = _.pluck(args, \"\" + i);\n    return results;\n  };\n\n  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),\n  // we need this function. Return the position of the first occurence of an\n  // item in an array, or -1 if the item is not included in the array.\n  // Delegates to **ECMAScript 5**'s native `indexOf` if available.\n  _.indexOf = function(array, item) {\n    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item);\n    for (var i = 0, l = array.length; i < l; i++) if (array[i] === item) return i;\n    return -1;\n  };\n\n\n  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.\n  _.lastIndexOf = function(array, item) {\n    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) return array.lastIndexOf(item);\n    var i = array.length;\n    while (i--) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    var args  = slice.call(arguments),\n        solo  = args.length <= 1,\n        start = solo ? 0 : args[0],\n        stop  = solo ? args[0] : args[1],\n        step  = args[2] || 1,\n        len   = Math.max(Math.ceil((stop - start) / step), 0),\n        idx   = 0,\n        range = new Array(len);\n    while (idx < len) {\n      range[idx++] = start;\n      start += step;\n    }\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Binding with arguments is also known as `curry`.\n  _.bind = function(func, obj) {\n    var args = slice.call(arguments, 2);\n    return function() {\n      return func.apply(obj || {}, args.concat(slice.call(arguments)));\n    };\n  };\n\n  // Bind all of an object's methods to that object. Useful for ensuring that\n  // all callbacks defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var funcs = slice.call(arguments, 1);\n    if (funcs.length == 0) funcs = _.functions(obj);\n    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memo = {};\n    hasher = hasher || _.identity;\n    return function() {\n      var key = hasher.apply(this, arguments);\n      return key in memo ? memo[key] : (memo[key] = func.apply(this, arguments));\n    };\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){ return func.apply(func, args); }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = function(func) {\n    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return function() {\n      var args = [func].concat(slice.call(arguments));\n      return wrapper.apply(wrapper, args);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var funcs = slice.call(arguments);\n    return function() {\n      var args = slice.call(arguments);\n      for (var i=funcs.length-1; i >= 0; i--) {\n        args = [funcs[i].apply(this, args)];\n      }\n      return args[0];\n    };\n  };\n\n  // Object Functions\n  // ----------------\n\n  // Retrieve the names of an object's properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = nativeKeys || function(obj) {\n    if (_.isArray(obj)) return _.range(0, obj.length);\n    var keys = [];\n    for (var key in obj) if (hasOwnProperty.call(obj, key)) keys[keys.length] = key;\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    return _.map(obj, _.identity);\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    return _.filter(_.keys(obj), function(key){ return _.isFunction(obj[key]); }).sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      for (var prop in source) obj[prop] = source[prop];\n    });\n    return obj;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    // Check object identity.\n    if (a === b) return true;\n    // Different types?\n    var atype = typeof(a), btype = typeof(b);\n    if (atype != btype) return false;\n    // Basic equality test (watch out for coercions).\n    if (a == b) return true;\n    // One is falsy and the other truthy.\n    if ((!a && b) || (a && !b)) return false;\n    // One of them implements an isEqual()?\n    if (a.isEqual) return a.isEqual(b);\n    // Check dates' integer values.\n    if (_.isDate(a) && _.isDate(b)) return a.getTime() === b.getTime();\n    // Both are NaN?\n    if (_.isNaN(a) && _.isNaN(b)) return false;\n    // Compare regular expressions.\n    if (_.isRegExp(a) && _.isRegExp(b))\n      return a.source     === b.source &&\n             a.global     === b.global &&\n             a.ignoreCase === b.ignoreCase &&\n             a.multiline  === b.multiline;\n    // If a is not an object by this point, we can't handle it.\n    if (atype !== 'object') return false;\n    // Check for different array lengths before comparing contents.\n    if (a.length && (a.length !== b.length)) return false;\n    // Nothing else worked, deep compare the contents.\n    var aKeys = _.keys(a), bKeys = _.keys(b);\n    // Different object sizes?\n    if (aKeys.length != bKeys.length) return false;\n    // Recursive comparison of contents.\n    for (var key in a) if (!(key in b) || !_.isEqual(a[key], b[key])) return false;\n    return true;\n  };\n\n  // Is a given array or object empty?\n  _.isEmpty = function(obj) {\n    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;\n    for (var key in obj) if (hasOwnProperty.call(obj, key)) return false;\n    return true;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType == 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return !!(obj && obj.concat && obj.unshift && !obj.callee);\n  };\n\n  // Is a given variable an arguments object?\n  _.isArguments = function(obj) {\n    return !!(obj && obj.callee);\n  };\n\n  // Is a given value a function?\n  _.isFunction = function(obj) {\n    return !!(obj && obj.constructor && obj.call && obj.apply);\n  };\n\n  // Is a given value a string?\n  _.isString = function(obj) {\n    return !!(obj === '' || (obj && obj.charCodeAt && obj.substr));\n  };\n\n  // Is a given value a number?\n  _.isNumber = function(obj) {\n    return (obj === +obj) || (toString.call(obj) === '[object Number]');\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false;\n  };\n\n  // Is a given value a date?\n  _.isDate = function(obj) {\n    return !!(obj && obj.getTimezoneOffset && obj.setUTCFullYear);\n  };\n\n  // Is the given value a regular expression?\n  _.isRegExp = function(obj) {\n    return !!(obj && obj.test && obj.exec && (obj.ignoreCase || obj.ignoreCase === false));\n  };\n\n  // Is the given value NaN -- this one is interesting. NaN != NaN, and\n  // isNaN(undefined) == true, so we make sure it's a number first.\n  _.isNaN = function(obj) {\n    return _.isNumber(obj) && isNaN(obj);\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return typeof obj == 'undefined';\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iterators.\n  _.identity = function(value) {\n    return value;\n  };\n\n  // Run a function **n** times.\n  _.times = function (n, iterator, context) {\n    for (var i = 0; i < n; i++) iterator.call(context, i);\n  };\n\n  // Break out of the middle of an iteration.\n  _.breakLoop = function() {\n    throw breaker;\n  };\n\n  // Add your own custom functions to the Underscore object, ensuring that\n  // they're correctly added to the OOP wrapper as well.\n  _.mixin = function(obj) {\n    each(_.functions(obj), function(name){\n      addToWrapper(name, _[name] = obj[name]);\n    });\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = idCounter++;\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g\n  };\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  _.template = function(str, data) {\n    var c  = _.templateSettings;\n    var tmpl = 'var __p=[],print=function(){__p.push.apply(__p,arguments);};' +\n      'with(obj||{}){__p.push(\\'' +\n      str.replace(/'/g, \"\\\\'\")\n         .replace(c.interpolate, function(match, code) {\n           return \"',\" + code.replace(/\\\\'/g, \"'\") + \",'\";\n         })\n         .replace(c.evaluate || null, function(match, code) {\n           return \"');\" + code.replace(/\\\\'/g, \"'\")\n                              .replace(/[\\r\\n\\t]/g, ' ') + \"__p.push('\";\n         })\n         .replace(/\\r/g, '\\\\r')\n         .replace(/\\n/g, '\\\\n')\n         .replace(/\\t/g, '\\\\t')\n         + \"');}return __p.join('');\";\n    var func = new Function('obj', tmpl);\n    return data ? func(data) : func;\n  };\n\n  // The OOP Wrapper\n  // ---------------\n\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n  var wrapper = function(obj) { this._wrapped = obj; };\n\n  // Expose `wrapper.prototype` as `_.prototype`\n  _.prototype = wrapper.prototype;\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(obj, chain) {\n    return chain ? _(obj).chain() : obj;\n  };\n\n  // A method to easily add functions to the OOP wrapper.\n  var addToWrapper = function(name, func) {\n    wrapper.prototype[name] = function() {\n      var args = slice.call(arguments);\n      unshift.call(args, this._wrapped);\n      return result(func.apply(_, args), this._chain);\n    };\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    wrapper.prototype[name] = function() {\n      method.apply(this._wrapped, arguments);\n      return result(this._wrapped, this._chain);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    wrapper.prototype[name] = function() {\n      return result(method.apply(this._wrapped, arguments), this._chain);\n    };\n  });\n\n  // Start chaining a wrapped Underscore object.\n  wrapper.prototype.chain = function() {\n    this._chain = true;\n    return this;\n  };\n\n  // Extracts the result from a wrapped and chained object.\n  wrapper.prototype.value = function() {\n    return this._wrapped;\n  };\n\n})();\n");
jsio.setCachedSrc("../../packages/index.js","// This is strictly for nodejs, not browsers.\nrequire('./jsio');\n\n");jsio.setCachedSrc("../../packages/logging.js","exports.UIWatcher = Class(function() {\n\t\n});");
jsio("import .compiler").start()